<?xml version="1.0" encoding="UTF-8"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:okp="okapi-framework:xliff-extensions" xmlns:its="http://www.w3.org/2005/11/its" xmlns:itsxlf="http://www.w3.org/ns/its-xliff/" its:version="2.0">
<file original="rrefsqlj35034.dita" source-language="en" target-language="fr" datatype="xml" okp:inputEncoding="utf-8" okp:configId="/home/jimh/Code/Okapi/okapi/okapi/filters/xmlstream/target/classes/net/sf/okapi/filters/xmlstream/dita.yml">
<header><tool tool-id="okapi" tool-name="okapi-tests" tool-version="M29" tool-company="okapi"></tool></header>
<body>
<trans-unit id="tu1">
<source xml:lang="en">INNER JOIN operation</source>
<seg-source><mrk mid="0" mtype="seg">INNER JOIN operation</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">INNER JOIN operation</mrk></target>
</trans-unit>
<trans-unit id="tu2">
<source xml:lang="en">INNER JOIN operation</source>
<seg-source><mrk mid="0" mtype="seg">INNER JOIN operation</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">INNER JOIN operation</mrk></target>
</trans-unit>
<trans-unit id="tu3">
<source xml:lang="en">An INNER JOIN is a <bpt id="1" ctype="x-xref">&lt;xref href="rrefsqlj29840.dita#rrefsqlj29840"&gt;</bpt>JOIN operation<ept id="1">&lt;/xref&gt;</ept> that allows you to specify an explicit join clause.</source>
<seg-source><mrk mid="0" mtype="seg">An INNER JOIN is a <bpt id="1" ctype="x-xref">&lt;xref href="rrefsqlj29840.dita#rrefsqlj29840"&gt;</bpt>JOIN operation<ept id="1">&lt;/xref&gt;</ept> that allows you to specify an explicit join clause.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">An INNER JOIN is a <bpt id="1" ctype="x-xref">&lt;xref href="rrefsqlj29840.dita#rrefsqlj29840"&gt;</bpt>JOIN operation<ept id="1">&lt;/xref&gt;</ept> that allows you to specify an explicit join clause.</mrk></target>
</trans-unit>
<trans-unit id="tu4">
<source xml:lang="en">Syntax</source>
<seg-source><mrk mid="0" mtype="seg">Syntax</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Syntax</mrk></target>
</trans-unit>
<trans-unit id="tu5">
<source xml:lang="en"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt><bpt id="2" ctype="x-i">&lt;i&gt;</bpt><bpt id="3" ctype="x-xref">&lt;xref href="rreftableexpression.dita#rreftableexpression"&gt;</bpt>tableExpression<ept id="3">&lt;/xref&gt;</ept><ept id="2">&lt;/i&gt;</ept> [ INNER ] JOIN <bpt id="4" ctype="x-i">&lt;i&gt;</bpt><bpt id="5" ctype="x-xref">&lt;xref href="rreftableexpression.dita#rreftableexpression"&gt;</bpt>tableExpression<ept id="5">&lt;/xref&gt;</ept><ept id="4">&lt;/i&gt;</ept> { ON <bpt id="6" ctype="x-i">&lt;i&gt;</bpt><bpt id="7" ctype="x-xref">&lt;xref
href="rrefsqlj23075.dita#rrefsqlj23075"&gt;</bpt>booleanExpression<ept id="7">&lt;/xref&gt;</ept><ept id="6">&lt;/i&gt;</ept> | <bpt id="8" ctype="x-i">&lt;i&gt;</bpt><bpt id="9" ctype="x-xref">&lt;xref href="rrefsqljusing.dita#rrefsqljusing"&gt;</bpt>USING clause<ept id="9">&lt;/xref&gt;</ept><ept id="8">&lt;/i&gt;</ept> }<ept id="1">&lt;/b&gt;</ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt><bpt id="2" ctype="x-i">&lt;i&gt;</bpt><bpt id="3" ctype="x-xref">&lt;xref href="rreftableexpression.dita#rreftableexpression"&gt;</bpt>tableExpression<ept id="3">&lt;/xref&gt;</ept><ept id="2">&lt;/i&gt;</ept> [ INNER ] JOIN <bpt id="4" ctype="x-i">&lt;i&gt;</bpt><bpt id="5" ctype="x-xref">&lt;xref href="rreftableexpression.dita#rreftableexpression"&gt;</bpt>tableExpression<ept id="5">&lt;/xref&gt;</ept><ept id="4">&lt;/i&gt;</ept> { ON <bpt id="6" ctype="x-i">&lt;i&gt;</bpt><bpt id="7" ctype="x-xref">&lt;xref
href="rrefsqlj23075.dita#rrefsqlj23075"&gt;</bpt>booleanExpression<ept id="7">&lt;/xref&gt;</ept><ept id="6">&lt;/i&gt;</ept> | <bpt id="8" ctype="x-i">&lt;i&gt;</bpt><bpt id="9" ctype="x-xref">&lt;xref href="rrefsqljusing.dita#rrefsqljusing"&gt;</bpt>USING clause<ept id="9">&lt;/xref&gt;</ept><ept id="8">&lt;/i&gt;</ept> }<ept id="1">&lt;/b&gt;</ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt><bpt id="2" ctype="x-i">&lt;i&gt;</bpt><bpt id="3" ctype="x-xref">&lt;xref href="rreftableexpression.dita#rreftableexpression"&gt;</bpt>tableExpression<ept id="3">&lt;/xref&gt;</ept><ept id="2">&lt;/i&gt;</ept> [ INNER ] JOIN <bpt id="4" ctype="x-i">&lt;i&gt;</bpt><bpt id="5" ctype="x-xref">&lt;xref href="rreftableexpression.dita#rreftableexpression"&gt;</bpt>tableExpression<ept id="5">&lt;/xref&gt;</ept><ept id="4">&lt;/i&gt;</ept> { ON <bpt id="6" ctype="x-i">&lt;i&gt;</bpt><bpt id="7" ctype="x-xref">&lt;xref
href="rrefsqlj23075.dita#rrefsqlj23075"&gt;</bpt>booleanExpression<ept id="7">&lt;/xref&gt;</ept><ept id="6">&lt;/i&gt;</ept> | <bpt id="8" ctype="x-i">&lt;i&gt;</bpt><bpt id="9" ctype="x-xref">&lt;xref href="rrefsqljusing.dita#rrefsqljusing"&gt;</bpt>USING clause<ept id="9">&lt;/xref&gt;</ept><ept id="8">&lt;/i&gt;</ept> }<ept id="1">&lt;/b&gt;</ept></mrk></target>
</trans-unit>
<trans-unit id="tu6">
<source xml:lang="en">You can specify the join clause by specifying ON with a boolean expression.</source>
<seg-source><mrk mid="0" mtype="seg">You can specify the join clause by specifying ON with a boolean expression.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">You can specify the join clause by specifying ON with a boolean expression.</mrk></target>
</trans-unit>
<trans-unit id="tu7">
<source xml:lang="en">ON clause</source>
<seg-source><mrk mid="0" mtype="seg">ON clause</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">ON clause</mrk></target>
</trans-unit>
<trans-unit id="tu8">
<source xml:lang="en">part of INNER JOIN expression</source>
<seg-source><mrk mid="0" mtype="seg">part of INNER JOIN expression</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">part of INNER JOIN expression</mrk></target>
</trans-unit>
<trans-unit id="tu9">
<source xml:lang="en">The scope of expressions in the ON clause includes the current tables and any tables in outer query blocks to the current SELECT. In the following example, the ON clause refers to the current tables:</source>
<seg-source><mrk mid="0" mtype="seg">The scope of expressions in the ON clause includes the current tables and any tables in outer query blocks to the current SELECT.</mrk><mrk mid="1" mtype="seg"> In the following example, the ON clause refers to the current tables:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">The scope of expressions in the ON clause includes the current tables and any tables in outer query blocks to the current SELECT.</mrk><mrk mid="1" mtype="seg"> In the following example, the ON clause refers to the current tables:</mrk></target>
</trans-unit>
<trans-unit id="tu10">
<source xml:lang="en"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>SELECT * FROM SAMP.EMPLOYEE INNER JOIN SAMP.STAFF ON EMPLOYEE.SALARY &lt; STAFF.SALARY <ept id="1">&lt;/b&gt;</ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>SELECT * FROM SAMP.EMPLOYEE INNER JOIN SAMP.STAFF ON EMPLOYEE.SALARY &lt; STAFF.SALARY <ept id="1">&lt;/b&gt;</ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>SELECT * FROM SAMP.EMPLOYEE INNER JOIN SAMP.STAFF ON EMPLOYEE.SALARY &lt; STAFF.SALARY <ept id="1">&lt;/b&gt;</ept></mrk></target>
</trans-unit>
<trans-unit id="tu11">
<source xml:lang="en">The ON clause can reference tables not being joined and does not have to reference either of the tables being joined (though typically it does).</source>
<seg-source><mrk mid="0" mtype="seg">The ON clause can reference tables not being joined and does not have to reference either of the tables being joined (though typically it does).</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">The ON clause can reference tables not being joined and does not have to reference either of the tables being joined (though typically it does).</mrk></target>
</trans-unit>
<trans-unit id="tu12">
<source xml:lang="en">Examples</source>
<seg-source><mrk mid="0" mtype="seg">Examples</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Examples</mrk></target>
</trans-unit>
<trans-unit id="tu13">
<source xml:lang="en"><it id="1" ctype="x-b" pos="open">&lt;b&gt;</it><bpt id="2" ctype="x-ph">&lt;ph&gt;</bpt>-- Join the EMP_ACT and EMPLOYEE tables<ept id="2">&lt;/ph&gt;</ept> -- select all the columns from the EMP_ACT table and -- add the employee's surname (LASTNAME) from the EMPLOYEE table -- to each row of the result SELECT SAMP.EMP_ACT.*, LASTNAME FROM SAMP.EMP_ACT JOIN SAMP.EMPLOYEE ON EMP_ACT.EMPNO = EMPLOYEE.EMPNO -- Join the EMPLOYEE and DEPARTMENT tables, -- select the employee number (EMPNO), -- employee surname (LASTNAME), -- department number (WORKDEPT in the EMPLOYEE table and DEPTNO in the -- DEPARTMENT table) -- and department name (DEPTNAME) -- of all employees who were born (BIRTHDATE) earlier than 1930. SELECT EMPNO, LASTNAME, WORKDEPT, DEPTNAME FROM SAMP.EMPLOYEE JOIN SAMP.DEPARTMENT ON WORKDEPT = DEPTNO AND YEAR(BIRTHDATE) &lt; 1930 <bpt id="3" ctype="x-ph">&lt;ph&gt;</bpt>-- Another example of "generating" new data values, <ept id="3">&lt;/ph&gt;</ept> -- using a query which selects from a VALUES clause (which is an -- alternate form of a fullselect). -- This query shows how a table can be derived called "X" -- having 2 columns "R1" and "R2" and 1 row of data SELECT * FROM (VALUES (3, 4), (1, 5), (2, 6)) AS VALUESTABLE1(C1, C2) JOIN (VALUES (3, 2), (1, 2), (0, 3)) AS VALUESTABLE2(c1, c2) ON VALUESTABLE1.c1 = VALUESTABLE2.c1 -- This results in: -- C1 |C2 |C1 |2 -- ----------------------------------------------- -- 3 |4 |3 |2 -- 1 |5 |1 |2 <bpt id="4" ctype="x-ph">&lt;ph&gt;</bpt> -- List every department with the employee number and -- last name of the manager<ept id="4">&lt;/ph&gt;</ept> SELECT DEPTNO, DEPTNAME, EMPNO, LASTNAME FROM DEPARTMENT INNER JOIN EMPLOYEE ON MGRNO = EMPNO <bpt id="5" ctype="x-ph">&lt;ph&gt;</bpt>-- List every employee number and last name -- with the employee number and last name of their manager<ept id="5">&lt;/ph&gt;</ept> SELECT E.EMPNO, E.LASTNAME, M.EMPNO, M.LASTNAME FROM EMPLOYEE E INNER JOIN DEPARTMENT INNER JOIN EMPLOYEE M ON MGRNO = M.EMPNO ON E.WORKDEPT = DEPTNO<it id="1" ctype="x-b" pos="close">&lt;/b&gt;</it></source>
<seg-source><mrk mid="0" mtype="seg"><it id="1" ctype="x-b" pos="open">&lt;b&gt;</it><bpt id="2" ctype="x-ph">&lt;ph&gt;</bpt>-- Join the EMP_ACT and EMPLOYEE tables<ept id="2">&lt;/ph&gt;</ept> -- select all the columns from the EMP_ACT table and -- add the employee's surname (LASTNAME) from the EMPLOYEE table -- to each row of the result SELECT SAMP.EMP_ACT.*, LASTNAME FROM SAMP.EMP_ACT JOIN SAMP.EMPLOYEE ON EMP_ACT.EMPNO = EMPLOYEE.EMPNO -- Join the EMPLOYEE and DEPARTMENT tables, -- select the employee number (EMPNO), -- employee surname (LASTNAME), -- department number (WORKDEPT in the EMPLOYEE table and DEPTNO in the -- DEPARTMENT table) -- and department name (DEPTNAME) -- of all employees who were born (BIRTHDATE) earlier than 1930.</mrk><mrk mid="1" mtype="seg"> SELECT EMPNO, LASTNAME, WORKDEPT, DEPTNAME FROM SAMP.EMPLOYEE JOIN SAMP.DEPARTMENT ON WORKDEPT = DEPTNO AND YEAR(BIRTHDATE) &lt; 1930 <bpt id="3" ctype="x-ph">&lt;ph&gt;</bpt>-- Another example of "generating" new data values, <ept id="3">&lt;/ph&gt;</ept> -- using a query which selects from a VALUES clause (which is an -- alternate form of a fullselect).</mrk><mrk mid="2" mtype="seg"> -- This query shows how a table can be derived called "X" -- having 2 columns "R1" and "R2" and 1 row of data SELECT * FROM (VALUES (3, 4), (1, 5), (2, 6)) AS VALUESTABLE1(C1, C2) JOIN (VALUES (3, 2), (1, 2), (0, 3)) AS VALUESTABLE2(c1, c2) ON VALUESTABLE1.c1 = VALUESTABLE2.c1 -- This results in: -- C1 |C2 |C1 |2 -- ----------------------------------------------- -- 3 |4 |3 |2 -- 1 |5 |1 |2 <bpt id="4" ctype="x-ph">&lt;ph&gt;</bpt> -- List every department with the employee number and -- last name of the manager<ept id="4">&lt;/ph&gt;</ept> SELECT DEPTNO, DEPTNAME, EMPNO, LASTNAME FROM DEPARTMENT INNER JOIN EMPLOYEE ON MGRNO = EMPNO <bpt id="5" ctype="x-ph">&lt;ph&gt;</bpt>-- List every employee number and last name -- with the employee number and last name of their manager<ept id="5">&lt;/ph&gt;</ept> SELECT E.EMPNO, E.LASTNAME, M.EMPNO, M.LASTNAME FROM EMPLOYEE E INNER JOIN DEPARTMENT INNER JOIN EMPLOYEE M ON MGRNO = M.EMPNO ON E.WORKDEPT = DEPTNO<it id="1" ctype="x-b" pos="close">&lt;/b&gt;</it></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><it id="1" ctype="x-b" pos="open">&lt;b&gt;</it><bpt id="2" ctype="x-ph">&lt;ph&gt;</bpt>-- Join the EMP_ACT and EMPLOYEE tables<ept id="2">&lt;/ph&gt;</ept> -- select all the columns from the EMP_ACT table and -- add the employee's surname (LASTNAME) from the EMPLOYEE table -- to each row of the result SELECT SAMP.EMP_ACT.*, LASTNAME FROM SAMP.EMP_ACT JOIN SAMP.EMPLOYEE ON EMP_ACT.EMPNO = EMPLOYEE.EMPNO -- Join the EMPLOYEE and DEPARTMENT tables, -- select the employee number (EMPNO), -- employee surname (LASTNAME), -- department number (WORKDEPT in the EMPLOYEE table and DEPTNO in the -- DEPARTMENT table) -- and department name (DEPTNAME) -- of all employees who were born (BIRTHDATE) earlier than 1930.</mrk><mrk mid="1" mtype="seg"> SELECT EMPNO, LASTNAME, WORKDEPT, DEPTNAME FROM SAMP.EMPLOYEE JOIN SAMP.DEPARTMENT ON WORKDEPT = DEPTNO AND YEAR(BIRTHDATE) &lt; 1930 <bpt id="3" ctype="x-ph">&lt;ph&gt;</bpt>-- Another example of "generating" new data values, <ept id="3">&lt;/ph&gt;</ept> -- using a query which selects from a VALUES clause (which is an -- alternate form of a fullselect).</mrk><mrk mid="2" mtype="seg"> -- This query shows how a table can be derived called "X" -- having 2 columns "R1" and "R2" and 1 row of data SELECT * FROM (VALUES (3, 4), (1, 5), (2, 6)) AS VALUESTABLE1(C1, C2) JOIN (VALUES (3, 2), (1, 2), (0, 3)) AS VALUESTABLE2(c1, c2) ON VALUESTABLE1.c1 = VALUESTABLE2.c1 -- This results in: -- C1 |C2 |C1 |2 -- ----------------------------------------------- -- 3 |4 |3 |2 -- 1 |5 |1 |2 <bpt id="4" ctype="x-ph">&lt;ph&gt;</bpt> -- List every department with the employee number and -- last name of the manager<ept id="4">&lt;/ph&gt;</ept> SELECT DEPTNO, DEPTNAME, EMPNO, LASTNAME FROM DEPARTMENT INNER JOIN EMPLOYEE ON MGRNO = EMPNO <bpt id="5" ctype="x-ph">&lt;ph&gt;</bpt>-- List every employee number and last name -- with the employee number and last name of their manager<ept id="5">&lt;/ph&gt;</ept> SELECT E.EMPNO, E.LASTNAME, M.EMPNO, M.LASTNAME FROM EMPLOYEE E INNER JOIN DEPARTMENT INNER JOIN EMPLOYEE M ON MGRNO = M.EMPNO ON E.WORKDEPT = DEPTNO<it id="1" ctype="x-b" pos="close">&lt;/b&gt;</it></mrk></target>
</trans-unit>
</body>
</file>
</xliff>
