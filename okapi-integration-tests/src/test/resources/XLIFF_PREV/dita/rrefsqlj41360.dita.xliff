<?xml version="1.0" encoding="UTF-8"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:okp="okapi-framework:xliff-extensions" xmlns:its="http://www.w3.org/2005/11/its" xmlns:itsxlf="http://www.w3.org/ns/its-xliff/" its:version="2.0">
<file original="rrefsqlj41360.dita" source-language="en" target-language="fr" datatype="xml" okp:inputEncoding="utf-8" okp:configId="/home/jimh/Code/Okapi/okapi/okapi/filters/xmlstream/target/classes/net/sf/okapi/filters/xmlstream/dita.yml">
<header><tool tool-id="okapi" tool-name="okapi-tests" tool-version="M29" tool-company="okapi"></tool></header>
<body>
<trans-unit id="tu1">
<source xml:lang="en">SELECT statement</source>
<seg-source><mrk mid="0" mtype="seg">SELECT statement</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">SELECT statement</mrk></target>
</trans-unit>
<trans-unit id="tu2">
<source xml:lang="en">SELECT statement</source>
<seg-source><mrk mid="0" mtype="seg">SELECT statement</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">SELECT statement</mrk></target>
</trans-unit>
<trans-unit id="tu3">
<source xml:lang="en">ORDER BY clause</source>
<seg-source><mrk mid="0" mtype="seg">ORDER BY clause</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">ORDER BY clause</mrk></target>
</trans-unit>
<trans-unit id="tu4">
<source xml:lang="en">needed to guarantee order of results</source>
<seg-source><mrk mid="0" mtype="seg">needed to guarantee order of results</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">needed to guarantee order of results</mrk></target>
</trans-unit>
<trans-unit id="tu5">
<source xml:lang="en">Syntax</source>
<seg-source><mrk mid="0" mtype="seg">Syntax</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Syntax</mrk></target>
</trans-unit>
<trans-unit id="tu6">
<source xml:lang="en"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt><bpt id="2" ctype="x-i">&lt;i&gt;</bpt><bpt id="3" ctype="x-xref">&lt;xref href="rrefsqlj21571.dita#rrefsqlj21571"&gt;</bpt>query<ept id="3">&lt;/xref&gt;</ept><ept id="2">&lt;/i&gt;</ept> [ <bpt id="4" ctype="x-i">&lt;i&gt;</bpt><bpt id="5" ctype="x-xref">&lt;xref href="rrefsqlj13658.dita#rrefsqlj13658"&gt;</bpt>ORDER BY clause<ept id="5">&lt;/xref&gt;</ept><ept id="4">&lt;/i&gt;</ept> ] [ <bpt id="6" ctype="x-i">&lt;i&gt;</bpt><bpt id="7" ctype="x-xref">&lt;xref href="rrefsqljoffsetfetch.dita#rrefsqljoffsetfetch"&gt;</bpt>result offset clause<ept id="7">&lt;/xref&gt;</ept><ept id="6">&lt;/i&gt;</ept> ] [ <bpt id="8" ctype="x-i">&lt;i&gt;</bpt><bpt id="9" ctype="x-xref">&lt;xref href="rrefsqljoffsetfetch.dita#rrefsqljoffsetfetch"&gt;</bpt>fetch first clause<ept id="9">&lt;/xref&gt;</ept><ept id="8">&lt;/i&gt;</ept> ] [ <bpt id="10" ctype="x-i">&lt;i&gt;</bpt><bpt id="11" ctype="x-xref">&lt;xref href="rrefsqlj31783.dita#rrefsqlj31783"&gt;</bpt>FOR UPDATE clause<ept id="11">&lt;/xref&gt;</ept><ept id="10">&lt;/i&gt;</ept> ] [ WITH { RR | RS | CS | UR } ]<ept id="1">&lt;/b&gt;</ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt><bpt id="2" ctype="x-i">&lt;i&gt;</bpt><bpt id="3" ctype="x-xref">&lt;xref href="rrefsqlj21571.dita#rrefsqlj21571"&gt;</bpt>query<ept id="3">&lt;/xref&gt;</ept><ept id="2">&lt;/i&gt;</ept> [ <bpt id="4" ctype="x-i">&lt;i&gt;</bpt><bpt id="5" ctype="x-xref">&lt;xref href="rrefsqlj13658.dita#rrefsqlj13658"&gt;</bpt>ORDER BY clause<ept id="5">&lt;/xref&gt;</ept><ept id="4">&lt;/i&gt;</ept> ] [ <bpt id="6" ctype="x-i">&lt;i&gt;</bpt><bpt id="7" ctype="x-xref">&lt;xref href="rrefsqljoffsetfetch.dita#rrefsqljoffsetfetch"&gt;</bpt>result offset clause<ept id="7">&lt;/xref&gt;</ept><ept id="6">&lt;/i&gt;</ept> ] [ <bpt id="8" ctype="x-i">&lt;i&gt;</bpt><bpt id="9" ctype="x-xref">&lt;xref href="rrefsqljoffsetfetch.dita#rrefsqljoffsetfetch"&gt;</bpt>fetch first clause<ept id="9">&lt;/xref&gt;</ept><ept id="8">&lt;/i&gt;</ept> ] [ <bpt id="10" ctype="x-i">&lt;i&gt;</bpt><bpt id="11" ctype="x-xref">&lt;xref href="rrefsqlj31783.dita#rrefsqlj31783"&gt;</bpt>FOR UPDATE clause<ept id="11">&lt;/xref&gt;</ept><ept id="10">&lt;/i&gt;</ept> ] [ WITH { RR | RS | CS | UR } ]<ept id="1">&lt;/b&gt;</ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt><bpt id="2" ctype="x-i">&lt;i&gt;</bpt><bpt id="3" ctype="x-xref">&lt;xref href="rrefsqlj21571.dita#rrefsqlj21571"&gt;</bpt>query<ept id="3">&lt;/xref&gt;</ept><ept id="2">&lt;/i&gt;</ept> [ <bpt id="4" ctype="x-i">&lt;i&gt;</bpt><bpt id="5" ctype="x-xref">&lt;xref href="rrefsqlj13658.dita#rrefsqlj13658"&gt;</bpt>ORDER BY clause<ept id="5">&lt;/xref&gt;</ept><ept id="4">&lt;/i&gt;</ept> ] [ <bpt id="6" ctype="x-i">&lt;i&gt;</bpt><bpt id="7" ctype="x-xref">&lt;xref href="rrefsqljoffsetfetch.dita#rrefsqljoffsetfetch"&gt;</bpt>result offset clause<ept id="7">&lt;/xref&gt;</ept><ept id="6">&lt;/i&gt;</ept> ] [ <bpt id="8" ctype="x-i">&lt;i&gt;</bpt><bpt id="9" ctype="x-xref">&lt;xref href="rrefsqljoffsetfetch.dita#rrefsqljoffsetfetch"&gt;</bpt>fetch first clause<ept id="9">&lt;/xref&gt;</ept><ept id="8">&lt;/i&gt;</ept> ] [ <bpt id="10" ctype="x-i">&lt;i&gt;</bpt><bpt id="11" ctype="x-xref">&lt;xref href="rrefsqlj31783.dita#rrefsqlj31783"&gt;</bpt>FOR UPDATE clause<ept id="11">&lt;/xref&gt;</ept><ept id="10">&lt;/i&gt;</ept> ] [ WITH { RR | RS | CS | UR } ]<ept id="1">&lt;/b&gt;</ept></mrk></target>
</trans-unit>
<trans-unit id="tu7">
<source xml:lang="en">A SELECT statement consists of a query with an optional <bpt id="1" ctype="x-xref">&lt;xref
href="rrefsqlj13658.dita#rrefsqlj13658"&gt;</bpt>ORDER BY clause<ept id="1">&lt;/xref&gt;</ept>, an optional <bpt id="2" ctype="x-xref">&lt;xref href="rrefsqljoffsetfetch.dita#rrefsqljoffsetfetch"&gt;</bpt>result offset clause<ept id="2">&lt;/xref&gt;</ept>, an optional <bpt id="3" ctype="x-xref">&lt;xref href="rrefsqljoffsetfetch.dita#rrefsqljoffsetfetch"&gt;</bpt>fetch first clause<ept id="3">&lt;/xref&gt;</ept>, an optional <bpt id="4" ctype="x-xref">&lt;xref href="rrefsqlj31783.dita#rrefsqlj31783"&gt;</bpt>FOR UPDATE clause<ept id="4">&lt;/xref&gt;</ept>, and an optional isolation level. The SELECT statement is so named because the typical first word of the query construct is SELECT. (A <bpt id="5" ctype="x-i">&lt;i&gt;</bpt>query<ept id="5">&lt;/i&gt;</ept> includes the VALUES expression and UNION, INTERSECT, and EXCEPT expressions as well as SELECT expressions).</source>
<seg-source><mrk mid="0" mtype="seg">A SELECT statement consists of a query with an optional <bpt id="1" ctype="x-xref">&lt;xref
href="rrefsqlj13658.dita#rrefsqlj13658"&gt;</bpt>ORDER BY clause<ept id="1">&lt;/xref&gt;</ept>, an optional <bpt id="2" ctype="x-xref">&lt;xref href="rrefsqljoffsetfetch.dita#rrefsqljoffsetfetch"&gt;</bpt>result offset clause<ept id="2">&lt;/xref&gt;</ept>, an optional <bpt id="3" ctype="x-xref">&lt;xref href="rrefsqljoffsetfetch.dita#rrefsqljoffsetfetch"&gt;</bpt>fetch first clause<ept id="3">&lt;/xref&gt;</ept>, an optional <bpt id="4" ctype="x-xref">&lt;xref href="rrefsqlj31783.dita#rrefsqlj31783"&gt;</bpt>FOR UPDATE clause<ept id="4">&lt;/xref&gt;</ept>, and an optional isolation level.</mrk><mrk mid="1" mtype="seg"> The SELECT statement is so named because the typical first word of the query construct is SELECT.</mrk><mrk mid="2" mtype="seg"> (A <bpt id="5" ctype="x-i">&lt;i&gt;</bpt>query<ept id="5">&lt;/i&gt;</ept> includes the VALUES expression and UNION, INTERSECT, and EXCEPT expressions as well as SELECT expressions).</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">A SELECT statement consists of a query with an optional <bpt id="1" ctype="x-xref">&lt;xref
href="rrefsqlj13658.dita#rrefsqlj13658"&gt;</bpt>ORDER BY clause<ept id="1">&lt;/xref&gt;</ept>, an optional <bpt id="2" ctype="x-xref">&lt;xref href="rrefsqljoffsetfetch.dita#rrefsqljoffsetfetch"&gt;</bpt>result offset clause<ept id="2">&lt;/xref&gt;</ept>, an optional <bpt id="3" ctype="x-xref">&lt;xref href="rrefsqljoffsetfetch.dita#rrefsqljoffsetfetch"&gt;</bpt>fetch first clause<ept id="3">&lt;/xref&gt;</ept>, an optional <bpt id="4" ctype="x-xref">&lt;xref href="rrefsqlj31783.dita#rrefsqlj31783"&gt;</bpt>FOR UPDATE clause<ept id="4">&lt;/xref&gt;</ept>, and an optional isolation level.</mrk><mrk mid="1" mtype="seg"> The SELECT statement is so named because the typical first word of the query construct is SELECT.</mrk><mrk mid="2" mtype="seg"> (A <bpt id="5" ctype="x-i">&lt;i&gt;</bpt>query<ept id="5">&lt;/i&gt;</ept> includes the VALUES expression and UNION, INTERSECT, and EXCEPT expressions as well as SELECT expressions).</mrk></target>
</trans-unit>
<trans-unit id="tu8">
<source xml:lang="en">The <bpt id="1" ctype="x-xref">&lt;xref href="rrefsqlj13658.dita#rrefsqlj13658"&gt;</bpt>ORDER BY clause<ept id="1">&lt;/xref&gt;</ept> guarantees the ordering of the <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>ResultSet<ept id="2">&lt;/i&gt;</ept>. The <bpt id="3" ctype="x-xref">&lt;xref href="rrefsqljoffsetfetch.dita#rrefsqljoffsetfetch"&gt;</bpt>result offset clause<ept id="3">&lt;/xref&gt;</ept> and the <bpt id="4" ctype="x-xref">&lt;xref href="rrefsqljoffsetfetch.dita#rrefsqljoffsetfetch"&gt;</bpt>fetch first clause<ept id="4">&lt;/xref&gt;</ept> can be used to fetch only a subset of the otherwise selected rows, possibly with an offset into the result set. The <bpt id="5" ctype="x-xref">&lt;xref href="rrefsqlj31783.dita#rrefsqlj31783"&gt;</bpt>FOR UPDATE clause<ept id="5">&lt;/xref&gt;</ept> makes the result set's cursor updatable. The SELECT statement supports the FOR FETCH ONLY clause. The FOR FETCH ONLY clause is synonymous with the FOR READ ONLY clause.</source>
<seg-source><mrk mid="0" mtype="seg">The <bpt id="1" ctype="x-xref">&lt;xref href="rrefsqlj13658.dita#rrefsqlj13658"&gt;</bpt>ORDER BY clause<ept id="1">&lt;/xref&gt;</ept> guarantees the ordering of the <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>ResultSet<ept id="2">&lt;/i&gt;</ept>.</mrk><mrk mid="1" mtype="seg"> The <bpt id="3" ctype="x-xref">&lt;xref href="rrefsqljoffsetfetch.dita#rrefsqljoffsetfetch"&gt;</bpt>result offset clause<ept id="3">&lt;/xref&gt;</ept> and the <bpt id="4" ctype="x-xref">&lt;xref href="rrefsqljoffsetfetch.dita#rrefsqljoffsetfetch"&gt;</bpt>fetch first clause<ept id="4">&lt;/xref&gt;</ept> can be used to fetch only a subset of the otherwise selected rows, possibly with an offset into the result set.</mrk><mrk mid="2" mtype="seg"> The <bpt id="5" ctype="x-xref">&lt;xref href="rrefsqlj31783.dita#rrefsqlj31783"&gt;</bpt>FOR UPDATE clause<ept id="5">&lt;/xref&gt;</ept> makes the result set's cursor updatable.</mrk><mrk mid="3" mtype="seg"> The SELECT statement supports the FOR FETCH ONLY clause.</mrk><mrk mid="4" mtype="seg"> The FOR FETCH ONLY clause is synonymous with the FOR READ ONLY clause.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">The <bpt id="1" ctype="x-xref">&lt;xref href="rrefsqlj13658.dita#rrefsqlj13658"&gt;</bpt>ORDER BY clause<ept id="1">&lt;/xref&gt;</ept> guarantees the ordering of the <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>ResultSet<ept id="2">&lt;/i&gt;</ept>.</mrk><mrk mid="1" mtype="seg"> The <bpt id="3" ctype="x-xref">&lt;xref href="rrefsqljoffsetfetch.dita#rrefsqljoffsetfetch"&gt;</bpt>result offset clause<ept id="3">&lt;/xref&gt;</ept> and the <bpt id="4" ctype="x-xref">&lt;xref href="rrefsqljoffsetfetch.dita#rrefsqljoffsetfetch"&gt;</bpt>fetch first clause<ept id="4">&lt;/xref&gt;</ept> can be used to fetch only a subset of the otherwise selected rows, possibly with an offset into the result set.</mrk><mrk mid="2" mtype="seg"> The <bpt id="5" ctype="x-xref">&lt;xref href="rrefsqlj31783.dita#rrefsqlj31783"&gt;</bpt>FOR UPDATE clause<ept id="5">&lt;/xref&gt;</ept> makes the result set's cursor updatable.</mrk><mrk mid="3" mtype="seg"> The SELECT statement supports the FOR FETCH ONLY clause.</mrk><mrk mid="4" mtype="seg"> The FOR FETCH ONLY clause is synonymous with the FOR READ ONLY clause.</mrk></target>
</trans-unit>
<trans-unit id="tu9">
<source xml:lang="en">You can set the isolation level in a SELECT statement using the <bpt id="1" ctype="x-codeph">&lt;codeph&gt;</bpt>WITH { RR | RS | CS | UR }<ept id="1">&lt;/codeph&gt;</ept> syntax.</source>
<seg-source><mrk mid="0" mtype="seg">You can set the isolation level in a SELECT statement using the <bpt id="1" ctype="x-codeph">&lt;codeph&gt;</bpt>WITH { RR | RS | CS | UR }<ept id="1">&lt;/codeph&gt;</ept> syntax.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">You can set the isolation level in a SELECT statement using the <bpt id="1" ctype="x-codeph">&lt;codeph&gt;</bpt>WITH { RR | RS | CS | UR }<ept id="1">&lt;/codeph&gt;</ept> syntax.</mrk></target>
</trans-unit>
<trans-unit id="tu10">
<source xml:lang="en">For queries that do not select a specific column from the tables involved in the SELECT statement (for example, queries that use <bpt id="1" ctype="x-codeph">&lt;codeph&gt;</bpt>COUNT(*)<ept id="1">&lt;/codeph&gt;</ept>), the user must have at least one column-level SELECT privilege or table-level SELECT privilege. See <bpt id="2" ctype="x-xref">&lt;xref href="rrefsqljgrant.dita#rrefsqljgrant"&gt;</bpt><ept id="2">&lt;/xref&gt;</ept> for more information.</source>
<seg-source><mrk mid="0" mtype="seg">For queries that do not select a specific column from the tables involved in the SELECT statement (for example, queries that use <bpt id="1" ctype="x-codeph">&lt;codeph&gt;</bpt>COUNT(*)<ept id="1">&lt;/codeph&gt;</ept>), the user must have at least one column-level SELECT privilege or table-level SELECT privilege.</mrk><mrk mid="1" mtype="seg"> See <bpt id="2" ctype="x-xref">&lt;xref href="rrefsqljgrant.dita#rrefsqljgrant"&gt;</bpt><ept id="2">&lt;/xref&gt;</ept> for more information.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">For queries that do not select a specific column from the tables involved in the SELECT statement (for example, queries that use <bpt id="1" ctype="x-codeph">&lt;codeph&gt;</bpt>COUNT(*)<ept id="1">&lt;/codeph&gt;</ept>), the user must have at least one column-level SELECT privilege or table-level SELECT privilege.</mrk><mrk mid="1" mtype="seg"> See <bpt id="2" ctype="x-xref">&lt;xref href="rrefsqljgrant.dita#rrefsqljgrant"&gt;</bpt><ept id="2">&lt;/xref&gt;</ept> for more information.</mrk></target>
</trans-unit>
<trans-unit id="tu11">
<source xml:lang="en">Example</source>
<seg-source><mrk mid="0" mtype="seg">Example</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Example</mrk></target>
</trans-unit>
<trans-unit id="tu12">
<source xml:lang="en"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt><bpt id="2" ctype="x-ph">&lt;ph&gt;</bpt>-- lists the names of the expression -- SAL+BONUS+COMM as TOTAL_PAY and -- orders by the new name TOTAL_PAY<ept id="2">&lt;/ph&gt;</ept> SELECT FIRSTNME, SALARY+BONUS+COMM AS TOTAL_PAY FROM EMPLOYEE ORDER BY TOTAL_PAY <bpt id="3" ctype="x-ph">&lt;ph&gt;</bpt>-- creating an updatable cursor with a FOR UPDATE clause -- to update the start date (PRSTDATE) and the end date (PRENDATE) -- columns in the PROJECT table<ept id="3">&lt;/ph&gt;</ept> SELECT PROJNO, PRSTDATE, PRENDATE FROM PROJECT FOR UPDATE OF PRSTDATE, PRENDATE <bpt id="4" ctype="x-ph">&lt;ph&gt;</bpt>-- set the isolation level to RR for this statement only <ept id="4">&lt;/ph&gt;</ept> SELECT * FROM Flights WHERE flight_id BETWEEN 'AA1111' AND 'AA1112' WITH RR<ept id="1">&lt;/b&gt;</ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt><bpt id="2" ctype="x-ph">&lt;ph&gt;</bpt>-- lists the names of the expression -- SAL+BONUS+COMM as TOTAL_PAY and -- orders by the new name TOTAL_PAY<ept id="2">&lt;/ph&gt;</ept> SELECT FIRSTNME, SALARY+BONUS+COMM AS TOTAL_PAY FROM EMPLOYEE ORDER BY TOTAL_PAY <bpt id="3" ctype="x-ph">&lt;ph&gt;</bpt>-- creating an updatable cursor with a FOR UPDATE clause -- to update the start date (PRSTDATE) and the end date (PRENDATE) -- columns in the PROJECT table<ept id="3">&lt;/ph&gt;</ept> SELECT PROJNO, PRSTDATE, PRENDATE FROM PROJECT FOR UPDATE OF PRSTDATE, PRENDATE <bpt id="4" ctype="x-ph">&lt;ph&gt;</bpt>-- set the isolation level to RR for this statement only <ept id="4">&lt;/ph&gt;</ept> SELECT * FROM Flights WHERE flight_id BETWEEN 'AA1111' AND 'AA1112' WITH RR<ept id="1">&lt;/b&gt;</ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt><bpt id="2" ctype="x-ph">&lt;ph&gt;</bpt>-- lists the names of the expression -- SAL+BONUS+COMM as TOTAL_PAY and -- orders by the new name TOTAL_PAY<ept id="2">&lt;/ph&gt;</ept> SELECT FIRSTNME, SALARY+BONUS+COMM AS TOTAL_PAY FROM EMPLOYEE ORDER BY TOTAL_PAY <bpt id="3" ctype="x-ph">&lt;ph&gt;</bpt>-- creating an updatable cursor with a FOR UPDATE clause -- to update the start date (PRSTDATE) and the end date (PRENDATE) -- columns in the PROJECT table<ept id="3">&lt;/ph&gt;</ept> SELECT PROJNO, PRSTDATE, PRENDATE FROM PROJECT FOR UPDATE OF PRSTDATE, PRENDATE <bpt id="4" ctype="x-ph">&lt;ph&gt;</bpt>-- set the isolation level to RR for this statement only <ept id="4">&lt;/ph&gt;</ept> SELECT * FROM Flights WHERE flight_id BETWEEN 'AA1111' AND 'AA1112' WITH RR<ept id="1">&lt;/b&gt;</ept></mrk></target>
</trans-unit>
<trans-unit id="tu13">
<source xml:lang="en">A SELECT statement returns a <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>ResultSet<ept id="1">&lt;/i&gt;</ept>. A <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>cursor<ept id="2">&lt;/i&gt;</ept> is a pointer to a specific row in <bpt id="3" ctype="x-i">&lt;i&gt;</bpt>ResultSet<ept id="3">&lt;/i&gt;</ept>. In Java applications, all <bpt id="4" ctype="x-i">&lt;i&gt;</bpt>ResultSets<ept id="4">&lt;/i&gt;</ept> have an underlying associated SQL cursor, often referred to as the result set's cursor. The cursor can be updatable, that is, you can update or delete rows as you step through the <bpt id="5" ctype="x-i">&lt;i&gt;</bpt>ResultSet<ept id="5">&lt;/i&gt;</ept> if the SELECT statement that generated it and its underlying query meet cursor updatability requirements, as detailed below. The FOR UPDATE clause can be used to ensure a compilation check that the SELECT statement meets the requiremments of a updatable cursors, or to limit the columns that can be updated.</source>
<seg-source><mrk mid="0" mtype="seg">A SELECT statement returns a <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>ResultSet<ept id="1">&lt;/i&gt;</ept>.</mrk><mrk mid="1" mtype="seg"> A <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>cursor<ept id="2">&lt;/i&gt;</ept> is a pointer to a specific row in <bpt id="3" ctype="x-i">&lt;i&gt;</bpt>ResultSet<ept id="3">&lt;/i&gt;</ept>.</mrk><mrk mid="2" mtype="seg"> In Java applications, all <bpt id="4" ctype="x-i">&lt;i&gt;</bpt>ResultSets<ept id="4">&lt;/i&gt;</ept> have an underlying associated SQL cursor, often referred to as the result set's cursor.</mrk><mrk mid="3" mtype="seg"> The cursor can be updatable, that is, you can update or delete rows as you step through the <bpt id="5" ctype="x-i">&lt;i&gt;</bpt>ResultSet<ept id="5">&lt;/i&gt;</ept> if the SELECT statement that generated it and its underlying query meet cursor updatability requirements, as detailed below.</mrk><mrk mid="4" mtype="seg"> The FOR UPDATE clause can be used to ensure a compilation check that the SELECT statement meets the requiremments of a updatable cursors, or to limit the columns that can be updated.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">A SELECT statement returns a <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>ResultSet<ept id="1">&lt;/i&gt;</ept>.</mrk><mrk mid="1" mtype="seg"> A <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>cursor<ept id="2">&lt;/i&gt;</ept> is a pointer to a specific row in <bpt id="3" ctype="x-i">&lt;i&gt;</bpt>ResultSet<ept id="3">&lt;/i&gt;</ept>.</mrk><mrk mid="2" mtype="seg"> In Java applications, all <bpt id="4" ctype="x-i">&lt;i&gt;</bpt>ResultSets<ept id="4">&lt;/i&gt;</ept> have an underlying associated SQL cursor, often referred to as the result set's cursor.</mrk><mrk mid="3" mtype="seg"> The cursor can be updatable, that is, you can update or delete rows as you step through the <bpt id="5" ctype="x-i">&lt;i&gt;</bpt>ResultSet<ept id="5">&lt;/i&gt;</ept> if the SELECT statement that generated it and its underlying query meet cursor updatability requirements, as detailed below.</mrk><mrk mid="4" mtype="seg"> The FOR UPDATE clause can be used to ensure a compilation check that the SELECT statement meets the requiremments of a updatable cursors, or to limit the columns that can be updated.</mrk></target>
</trans-unit>
<trans-unit id="tu14">
<source xml:lang="en">The ORDER BY clause allows you to order the results of the SELECT. Without the ORDER BY clause, the results are returned in random order.</source>
<seg-source><mrk mid="0" mtype="seg">The ORDER BY clause allows you to order the results of the SELECT.</mrk><mrk mid="1" mtype="seg"> Without the ORDER BY clause, the results are returned in random order.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">The ORDER BY clause allows you to order the results of the SELECT.</mrk><mrk mid="1" mtype="seg"> Without the ORDER BY clause, the results are returned in random order.</mrk></target>
</trans-unit>
<trans-unit id="tu15">
<source xml:lang="en">Requirements for updatable cursors and updatable ResultSets</source>
<seg-source><mrk mid="0" mtype="seg">Requirements for updatable cursors and updatable ResultSets</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Requirements for updatable cursors and updatable ResultSets</mrk></target>
</trans-unit>
<trans-unit id="tu16">
<source xml:lang="en">Only simple, single-table SELECT cursors can be updatable. The SELECT statement for updatable ResultSets has the same syntax as the SELECT statement for updatable cursors. To generate updatable cursors:</source>
<seg-source><mrk mid="0" mtype="seg">Only simple, single-table SELECT cursors can be updatable.</mrk><mrk mid="1" mtype="seg"> The SELECT statement for updatable ResultSets has the same syntax as the SELECT statement for updatable cursors.</mrk><mrk mid="2" mtype="seg"> To generate updatable cursors:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Only simple, single-table SELECT cursors can be updatable.</mrk><mrk mid="1" mtype="seg"> The SELECT statement for updatable ResultSets has the same syntax as the SELECT statement for updatable cursors.</mrk><mrk mid="2" mtype="seg"> To generate updatable cursors:</mrk></target>
</trans-unit>
<trans-unit id="tu17">
<source xml:lang="en">The SELECT statement must not include an ORDER BY clause.</source>
<seg-source><mrk mid="0" mtype="seg">The SELECT statement must not include an ORDER BY clause.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">The SELECT statement must not include an ORDER BY clause.</mrk></target>
</trans-unit>
<trans-unit id="tu18">
<source xml:lang="en">The underlying <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>query<ept id="1">&lt;/i&gt;</ept> must be a <bpt id="2" ctype="x-i">&lt;i&gt;</bpt><bpt id="3" ctype="x-xref">&lt;xref href="rrefselectexpression.dita#rrefselectexpression"&gt;</bpt>selectExpression<ept id="3">&lt;/xref&gt;</ept>.<ept id="2">&lt;/i&gt;</ept></source>
<seg-source><mrk mid="0" mtype="seg">The underlying <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>query<ept id="1">&lt;/i&gt;</ept> must be a <bpt id="2" ctype="x-i">&lt;i&gt;</bpt><bpt id="3" ctype="x-xref">&lt;xref href="rrefselectexpression.dita#rrefselectexpression"&gt;</bpt>selectExpression<ept id="3">&lt;/xref&gt;</ept>.<ept id="2">&lt;/i&gt;</ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">The underlying <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>query<ept id="1">&lt;/i&gt;</ept> must be a <bpt id="2" ctype="x-i">&lt;i&gt;</bpt><bpt id="3" ctype="x-xref">&lt;xref href="rrefselectexpression.dita#rrefselectexpression"&gt;</bpt>selectExpression<ept id="3">&lt;/xref&gt;</ept>.<ept id="2">&lt;/i&gt;</ept></mrk></target>
</trans-unit>
<trans-unit id="tu19">
<source xml:lang="en">The <bpt id="1" ctype="x-i">&lt;i&gt;</bpt><bpt id="2" ctype="x-xref">&lt;xref href="rrefselectexpression.dita#rrefselectexpression"&gt;</bpt>selectExpression<ept id="2">&lt;/xref&gt;</ept><ept id="1">&lt;/i&gt;</ept> in the underlying <bpt id="3" ctype="x-i">&lt;i&gt;</bpt>query<ept id="3">&lt;/i&gt;</ept> must not include:</source>
<seg-source><mrk mid="0" mtype="seg">The <bpt id="1" ctype="x-i">&lt;i&gt;</bpt><bpt id="2" ctype="x-xref">&lt;xref href="rrefselectexpression.dita#rrefselectexpression"&gt;</bpt>selectExpression<ept id="2">&lt;/xref&gt;</ept><ept id="1">&lt;/i&gt;</ept> in the underlying <bpt id="3" ctype="x-i">&lt;i&gt;</bpt>query<ept id="3">&lt;/i&gt;</ept> must not include:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">The <bpt id="1" ctype="x-i">&lt;i&gt;</bpt><bpt id="2" ctype="x-xref">&lt;xref href="rrefselectexpression.dita#rrefselectexpression"&gt;</bpt>selectExpression<ept id="2">&lt;/xref&gt;</ept><ept id="1">&lt;/i&gt;</ept> in the underlying <bpt id="3" ctype="x-i">&lt;i&gt;</bpt>query<ept id="3">&lt;/i&gt;</ept> must not include:</mrk></target>
</trans-unit>
<trans-unit id="tu20">
<source xml:lang="en">DISTINCT</source>
<seg-source><mrk mid="0" mtype="seg">DISTINCT</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">DISTINCT</mrk></target>
</trans-unit>
<trans-unit id="tu21">
<source xml:lang="en">Aggregates</source>
<seg-source><mrk mid="0" mtype="seg">Aggregates</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Aggregates</mrk></target>
</trans-unit>
<trans-unit id="tu22">
<source xml:lang="en">GROUP BY clause</source>
<seg-source><mrk mid="0" mtype="seg">GROUP BY clause</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">GROUP BY clause</mrk></target>
</trans-unit>
<trans-unit id="tu23">
<source xml:lang="en">HAVING clause</source>
<seg-source><mrk mid="0" mtype="seg">HAVING clause</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">HAVING clause</mrk></target>
</trans-unit>
<trans-unit id="tu24">
<source xml:lang="en">ORDER BY clause</source>
<seg-source><mrk mid="0" mtype="seg">ORDER BY clause</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">ORDER BY clause</mrk></target>
</trans-unit>
<trans-unit id="tu25">
<source xml:lang="en">The FROM clause in the underlying <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>query<ept id="1">&lt;/i&gt;</ept> must not have:</source>
<seg-source><mrk mid="0" mtype="seg">The FROM clause in the underlying <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>query<ept id="1">&lt;/i&gt;</ept> must not have:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">The FROM clause in the underlying <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>query<ept id="1">&lt;/i&gt;</ept> must not have:</mrk></target>
</trans-unit>
<trans-unit id="tu26">
<source xml:lang="en">More than one table in its FROM clause</source>
<seg-source><mrk mid="0" mtype="seg">More than one table in its FROM clause</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">More than one table in its FROM clause</mrk></target>
</trans-unit>
<trans-unit id="tu27">
<source xml:lang="en">Anything other than one table name</source>
<seg-source><mrk mid="0" mtype="seg">Anything other than one table name</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Anything other than one table name</mrk></target>
</trans-unit>
<trans-unit id="tu28">
<source xml:lang="en"><bpt id="1" ctype="x-i">&lt;i&gt;</bpt><bpt id="2" ctype="x-xref">&lt;xref href="rrefselectexpression.dita#rrefselectexpression"&gt;</bpt>selectExpression<ept id="2">&lt;/xref&gt;</ept><ept id="1">&lt;/i&gt;</ept>s</source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-i">&lt;i&gt;</bpt><bpt id="2" ctype="x-xref">&lt;xref href="rrefselectexpression.dita#rrefselectexpression"&gt;</bpt>selectExpression<ept id="2">&lt;/xref&gt;</ept><ept id="1">&lt;/i&gt;</ept>s</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-i">&lt;i&gt;</bpt><bpt id="2" ctype="x-xref">&lt;xref href="rrefselectexpression.dita#rrefselectexpression"&gt;</bpt>selectExpression<ept id="2">&lt;/xref&gt;</ept><ept id="1">&lt;/i&gt;</ept>s</mrk></target>
</trans-unit>
<trans-unit id="tu29">
<source xml:lang="en">Subqueries</source>
<seg-source><mrk mid="0" mtype="seg">Subqueries</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Subqueries</mrk></target>
</trans-unit>
<trans-unit id="tu30">
<source xml:lang="en">If the underlying <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>query<ept id="1">&lt;/i&gt;</ept> has a WHERE clause, the WHERE clause must not have subqueries.</source>
<seg-source><mrk mid="0" mtype="seg">If the underlying <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>query<ept id="1">&lt;/i&gt;</ept> has a WHERE clause, the WHERE clause must not have subqueries.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">If the underlying <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>query<ept id="1">&lt;/i&gt;</ept> has a WHERE clause, the WHERE clause must not have subqueries.</mrk></target>
</trans-unit>
<trans-unit id="tu31">
<source xml:lang="en">Cursors are read-only by default. To produce an updatable cursor besides meeting the requirements listed above, the concurrency mode for the ResultSet must be <bpt id="1" ctype="x-codeph">&lt;codeph&gt;</bpt>ResultSet.CONCUR_UPDATABLE<ept id="1">&lt;/codeph&gt;</ept> or the SELECT statement must have FOR UPDATE in the FOR clause (see <bpt id="2" ctype="x-xref">&lt;xref href="rrefsqlj31783.dita#rrefsqlj31783"&gt;</bpt><ept id="2">&lt;/xref&gt;</ept>).</source>
<seg-source><mrk mid="0" mtype="seg">Cursors are read-only by default.</mrk><mrk mid="1" mtype="seg"> To produce an updatable cursor besides meeting the requirements listed above, the concurrency mode for the ResultSet must be <bpt id="1" ctype="x-codeph">&lt;codeph&gt;</bpt>ResultSet.CONCUR_UPDATABLE<ept id="1">&lt;/codeph&gt;</ept> or the SELECT statement must have FOR UPDATE in the FOR clause (see <bpt id="2" ctype="x-xref">&lt;xref href="rrefsqlj31783.dita#rrefsqlj31783"&gt;</bpt><ept id="2">&lt;/xref&gt;</ept>).</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Cursors are read-only by default.</mrk><mrk mid="1" mtype="seg"> To produce an updatable cursor besides meeting the requirements listed above, the concurrency mode for the ResultSet must be <bpt id="1" ctype="x-codeph">&lt;codeph&gt;</bpt>ResultSet.CONCUR_UPDATABLE<ept id="1">&lt;/codeph&gt;</ept> or the SELECT statement must have FOR UPDATE in the FOR clause (see <bpt id="2" ctype="x-xref">&lt;xref href="rrefsqlj31783.dita#rrefsqlj31783"&gt;</bpt><ept id="2">&lt;/xref&gt;</ept>).</mrk></target>
</trans-unit>
<trans-unit id="tu32">
<source xml:lang="en">There is no SQL language statement to <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>assign<ept id="1">&lt;/i&gt;</ept> a name to a cursor. Instead, one can use the JDBC API to assign names to cursors or retrieve system-generated names. For more information, see "Naming or accessing the name of a cursor" in the <bpt id="2" ctype="x-cite">&lt;cite&gt;</bpt><bpt id="3" ctype="x-ph">&lt;ph conref="../conrefs.dita#pub/citdevelop"&gt;</bpt><ept id="3">&lt;/ph&gt;</ept><ept id="2">&lt;/cite&gt;</ept>.</source>
<seg-source><mrk mid="0" mtype="seg">There is no SQL language statement to <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>assign<ept id="1">&lt;/i&gt;</ept> a name to a cursor.</mrk><mrk mid="1" mtype="seg"> Instead, one can use the JDBC API to assign names to cursors or retrieve system-generated names.</mrk><mrk mid="2" mtype="seg"> For more information, see "Naming or accessing the name of a cursor" in the <bpt id="2" ctype="x-cite">&lt;cite&gt;</bpt><bpt id="3" ctype="x-ph">&lt;ph conref="../conrefs.dita#pub/citdevelop"&gt;</bpt><ept id="3">&lt;/ph&gt;</ept><ept id="2">&lt;/cite&gt;</ept>.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">There is no SQL language statement to <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>assign<ept id="1">&lt;/i&gt;</ept> a name to a cursor.</mrk><mrk mid="1" mtype="seg"> Instead, one can use the JDBC API to assign names to cursors or retrieve system-generated names.</mrk><mrk mid="2" mtype="seg"> For more information, see "Naming or accessing the name of a cursor" in the <bpt id="2" ctype="x-cite">&lt;cite&gt;</bpt><bpt id="3" ctype="x-ph">&lt;ph conref="../conrefs.dita#pub/citdevelop"&gt;</bpt><ept id="3">&lt;/ph&gt;</ept><ept id="2">&lt;/cite&gt;</ept>.</mrk></target>
</trans-unit>
<trans-unit id="tu33">
<source xml:lang="en">Statement dependency system</source>
<seg-source><mrk mid="0" mtype="seg">Statement dependency system</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Statement dependency system</mrk></target>
</trans-unit>
<trans-unit id="tu34">
<source xml:lang="en">The SELECT depends on all the tables and views named in the query and the conglomerates (units of storage such as heaps and indexes) chosen for access paths on those tables. CREATE INDEX does not invalidate a prepared SELECT statement. A DROP INDEX statement invalidates a prepared SELECT statement if the index is an access path in the statement. If the SELECT includes views, it also depends on the dictionary objects on which the view itself depends (see <bpt id="1" ctype="x-xref">&lt;xref href="rrefsqlj15446.dita#rrefsqlj15446"&gt;</bpt><ept id="1">&lt;/xref&gt;</ept>).</source>
<seg-source><mrk mid="0" mtype="seg">The SELECT depends on all the tables and views named in the query and the conglomerates (units of storage such as heaps and indexes) chosen for access paths on those tables.</mrk><mrk mid="1" mtype="seg"> CREATE INDEX does not invalidate a prepared SELECT statement.</mrk><mrk mid="2" mtype="seg"> A DROP INDEX statement invalidates a prepared SELECT statement if the index is an access path in the statement.</mrk><mrk mid="3" mtype="seg"> If the SELECT includes views, it also depends on the dictionary objects on which the view itself depends (see <bpt id="1" ctype="x-xref">&lt;xref href="rrefsqlj15446.dita#rrefsqlj15446"&gt;</bpt><ept id="1">&lt;/xref&gt;</ept>).</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">The SELECT depends on all the tables and views named in the query and the conglomerates (units of storage such as heaps and indexes) chosen for access paths on those tables.</mrk><mrk mid="1" mtype="seg"> CREATE INDEX does not invalidate a prepared SELECT statement.</mrk><mrk mid="2" mtype="seg"> A DROP INDEX statement invalidates a prepared SELECT statement if the index is an access path in the statement.</mrk><mrk mid="3" mtype="seg"> If the SELECT includes views, it also depends on the dictionary objects on which the view itself depends (see <bpt id="1" ctype="x-xref">&lt;xref href="rrefsqlj15446.dita#rrefsqlj15446"&gt;</bpt><ept id="1">&lt;/xref&gt;</ept>).</mrk></target>
</trans-unit>
<trans-unit id="tu35">
<source xml:lang="en">Any prepared UPDATE WHERE CURRENT or DELETE WHERE CURRENT statement against a cursor of a SELECT depends on the SELECT. Removing a SELECT through a <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>java.sql.Statement.close <ept id="1">&lt;/i&gt;</ept>request invalidates the UPDATE WHERE CURRENT or DELETE WHERE CURRENT.</source>
<seg-source><mrk mid="0" mtype="seg">Any prepared UPDATE WHERE CURRENT or DELETE WHERE CURRENT statement against a cursor of a SELECT depends on the SELECT.</mrk><mrk mid="1" mtype="seg"> Removing a SELECT through a <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>java.sql.Statement.close <ept id="1">&lt;/i&gt;</ept>request invalidates the UPDATE WHERE CURRENT or DELETE WHERE CURRENT.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Any prepared UPDATE WHERE CURRENT or DELETE WHERE CURRENT statement against a cursor of a SELECT depends on the SELECT.</mrk><mrk mid="1" mtype="seg"> Removing a SELECT through a <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>java.sql.Statement.close <ept id="1">&lt;/i&gt;</ept>request invalidates the UPDATE WHERE CURRENT or DELETE WHERE CURRENT.</mrk></target>
</trans-unit>
<trans-unit id="tu36">
<source xml:lang="en">The SELECT depends on all aliases used in the query. Dropping an alias invalidates a prepared SELECT statement if the statement uses the alias.</source>
<seg-source><mrk mid="0" mtype="seg">The SELECT depends on all aliases used in the query.</mrk><mrk mid="1" mtype="seg"> Dropping an alias invalidates a prepared SELECT statement if the statement uses the alias.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">The SELECT depends on all aliases used in the query.</mrk><mrk mid="1" mtype="seg"> Dropping an alias invalidates a prepared SELECT statement if the statement uses the alias.</mrk></target>
</trans-unit>
</body>
</file>
</xliff>
