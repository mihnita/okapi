<?xml version="1.0" encoding="UTF-8"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:okp="okapi-framework:xliff-extensions" xmlns:its="http://www.w3.org/2005/11/its" xmlns:itsxlf="http://www.w3.org/ns/its-xliff/" its:version="2.0">
<file original="rrefsqlj57522.dita" source-language="en" target-language="fr" datatype="xml" okp:inputEncoding="utf-8" okp:configId="/home/jimh/Code/Okapi/okapi/okapi/filters/xmlstream/target/classes/net/sf/okapi/filters/xmlstream/dita.yml">
<header><tool tool-id="okapi" tool-name="okapi-tests" tool-version="M29" tool-company="okapi"></tool></header>
<body>
<trans-unit id="tu1">
<source xml:lang="en">RIGHT OUTER JOIN operation</source>
<seg-source><mrk mid="0" mtype="seg">RIGHT OUTER JOIN operation</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">RIGHT OUTER JOIN operation</mrk></target>
</trans-unit>
<trans-unit id="tu2">
<source xml:lang="en">RIGHT OUTER JOIN operation</source>
<seg-source><mrk mid="0" mtype="seg">RIGHT OUTER JOIN operation</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">RIGHT OUTER JOIN operation</mrk></target>
</trans-unit>
<trans-unit id="tu3">
<source xml:lang="en">A RIGHT OUTER JOIN is one of the <bpt id="1" ctype="x-xref">&lt;xref href="rrefsqlj29840.dita#rrefsqlj29840"&gt;</bpt>JOIN operations<ept id="1">&lt;/xref&gt;</ept> that allow you to specify a JOIN clause. It preserves the unmatched rows from the second (right) table, joining them with a NULL in the shape of the first (left) table. A LEFT OUTER JOIN B is equivalent to B RIGHT OUTER JOIN A, with the columns in a different order.</source>
<seg-source><mrk mid="0" mtype="seg">A RIGHT OUTER JOIN is one of the <bpt id="1" ctype="x-xref">&lt;xref href="rrefsqlj29840.dita#rrefsqlj29840"&gt;</bpt>JOIN operations<ept id="1">&lt;/xref&gt;</ept> that allow you to specify a JOIN clause.</mrk><mrk mid="1" mtype="seg"> It preserves the unmatched rows from the second (right) table, joining them with a NULL in the shape of the first (left) table.</mrk><mrk mid="2" mtype="seg"> A LEFT OUTER JOIN B is equivalent to B RIGHT OUTER JOIN A, with the columns in a different order.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">A RIGHT OUTER JOIN is one of the <bpt id="1" ctype="x-xref">&lt;xref href="rrefsqlj29840.dita#rrefsqlj29840"&gt;</bpt>JOIN operations<ept id="1">&lt;/xref&gt;</ept> that allow you to specify a JOIN clause.</mrk><mrk mid="1" mtype="seg"> It preserves the unmatched rows from the second (right) table, joining them with a NULL in the shape of the first (left) table.</mrk><mrk mid="2" mtype="seg"> A LEFT OUTER JOIN B is equivalent to B RIGHT OUTER JOIN A, with the columns in a different order.</mrk></target>
</trans-unit>
<trans-unit id="tu4">
<source xml:lang="en">Syntax</source>
<seg-source><mrk mid="0" mtype="seg">Syntax</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Syntax</mrk></target>
</trans-unit>
<trans-unit id="tu5">
<source xml:lang="en"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt><bpt id="2" ctype="x-i">&lt;i&gt;</bpt><bpt id="3" ctype="x-xref">&lt;xref href="rreftableexpression.dita#rreftableexpression"&gt;</bpt>tableExpression<ept id="3">&lt;/xref&gt;</ept><ept id="2">&lt;/i&gt;</ept> RIGHT [ OUTER ] JOIN <bpt id="4" ctype="x-i">&lt;i
&gt;</bpt><bpt id="5" ctype="x-xref">&lt;xref href="rreftableexpression.dita#rreftableexpression"&gt;</bpt>tableExpression<ept id="5">&lt;/xref&gt;</ept><ept id="4">&lt;/i&gt;</ept> { ON <bpt id="6" ctype="x-i">&lt;i&gt;</bpt><bpt id="7" ctype="x-xref">&lt;xref
href="rrefsqlj23075.dita#rrefsqlj23075"&gt;</bpt>booleanExpression<ept id="7">&lt;/xref&gt;</ept><ept id="6">&lt;/i&gt;</ept> | <bpt id="8" ctype="x-i">&lt;i&gt;</bpt><bpt id="9" ctype="x-xref">&lt;xref href="rrefsqljusing.dita#rrefsqljusing"&gt;</bpt>USING clause<ept id="9">&lt;/xref&gt;</ept><ept id="8">&lt;/i&gt;</ept> }<ept id="1">&lt;/b&gt;</ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt><bpt id="2" ctype="x-i">&lt;i&gt;</bpt><bpt id="3" ctype="x-xref">&lt;xref href="rreftableexpression.dita#rreftableexpression"&gt;</bpt>tableExpression<ept id="3">&lt;/xref&gt;</ept><ept id="2">&lt;/i&gt;</ept> RIGHT [ OUTER ] JOIN <bpt id="4" ctype="x-i">&lt;i
&gt;</bpt><bpt id="5" ctype="x-xref">&lt;xref href="rreftableexpression.dita#rreftableexpression"&gt;</bpt>tableExpression<ept id="5">&lt;/xref&gt;</ept><ept id="4">&lt;/i&gt;</ept> { ON <bpt id="6" ctype="x-i">&lt;i&gt;</bpt><bpt id="7" ctype="x-xref">&lt;xref
href="rrefsqlj23075.dita#rrefsqlj23075"&gt;</bpt>booleanExpression<ept id="7">&lt;/xref&gt;</ept><ept id="6">&lt;/i&gt;</ept> | <bpt id="8" ctype="x-i">&lt;i&gt;</bpt><bpt id="9" ctype="x-xref">&lt;xref href="rrefsqljusing.dita#rrefsqljusing"&gt;</bpt>USING clause<ept id="9">&lt;/xref&gt;</ept><ept id="8">&lt;/i&gt;</ept> }<ept id="1">&lt;/b&gt;</ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt><bpt id="2" ctype="x-i">&lt;i&gt;</bpt><bpt id="3" ctype="x-xref">&lt;xref href="rreftableexpression.dita#rreftableexpression"&gt;</bpt>tableExpression<ept id="3">&lt;/xref&gt;</ept><ept id="2">&lt;/i&gt;</ept> RIGHT [ OUTER ] JOIN <bpt id="4" ctype="x-i">&lt;i
&gt;</bpt><bpt id="5" ctype="x-xref">&lt;xref href="rreftableexpression.dita#rreftableexpression"&gt;</bpt>tableExpression<ept id="5">&lt;/xref&gt;</ept><ept id="4">&lt;/i&gt;</ept> { ON <bpt id="6" ctype="x-i">&lt;i&gt;</bpt><bpt id="7" ctype="x-xref">&lt;xref
href="rrefsqlj23075.dita#rrefsqlj23075"&gt;</bpt>booleanExpression<ept id="7">&lt;/xref&gt;</ept><ept id="6">&lt;/i&gt;</ept> | <bpt id="8" ctype="x-i">&lt;i&gt;</bpt><bpt id="9" ctype="x-xref">&lt;xref href="rrefsqljusing.dita#rrefsqljusing"&gt;</bpt>USING clause<ept id="9">&lt;/xref&gt;</ept><ept id="8">&lt;/i&gt;</ept> }<ept id="1">&lt;/b&gt;</ept></mrk></target>
</trans-unit>
<trans-unit id="tu6">
<source xml:lang="en">The scope of expressions in the ON clause includes the current tables and any tables in query blocks outer to the current SELECT. The ON clause can reference tables not being joined and does not have to reference either of the tables being joined (though typically it does).</source>
<seg-source><mrk mid="0" mtype="seg">The scope of expressions in the ON clause includes the current tables and any tables in query blocks outer to the current SELECT.</mrk><mrk mid="1" mtype="seg"> The ON clause can reference tables not being joined and does not have to reference either of the tables being joined (though typically it does).</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">The scope of expressions in the ON clause includes the current tables and any tables in query blocks outer to the current SELECT.</mrk><mrk mid="1" mtype="seg"> The ON clause can reference tables not being joined and does not have to reference either of the tables being joined (though typically it does).</mrk></target>
</trans-unit>
<trans-unit id="tu7">
<source xml:lang="en">Example 1</source>
<seg-source><mrk mid="0" mtype="seg">Example 1</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Example 1</mrk></target>
</trans-unit>
<trans-unit id="tu8">
<source xml:lang="en"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>-- get all countries and corresponding cities, including -- countries without any cities<ept id="1">&lt;/b&gt;</ept> SELECT COUNTRIES.COUNTRY, CITIES.CITY_NAME FROM CITIES RIGHT OUTER JOIN COUNTRIES ON CITIES.COUNTRY_ISO_CODE = COUNTRIES.COUNTRY_ISO_CODE <bpt id="2" ctype="x-b">&lt;b&gt;</bpt>-- get all countries in Africa and corresponding cities, including -- countries without any cities <ept id="2">&lt;/b&gt;</ept> SELECT COUNTRIES.COUNTRY, CITIES.CITY_NAME FROM CITIES RIGHT OUTER JOIN COUNTRIES ON CITIES.COUNTRY_ISO_CODE = COUNTRIES.COUNTRY_ISO_CODE WHERE Countries.region = 'Africa' <bpt id="3" ctype="x-b">&lt;b&gt;</bpt>-- use the synonymous syntax, RIGHT JOIN, to achieve exactly -- the same results as in the example above <ept id="3">&lt;/b&gt;</ept> SELECT COUNTRIES.COUNTRY, CITIES.CITY_NAME FROM CITIES RIGHT JOIN COUNTRIES ON CITIES.COUNTRY_ISO_CODE = COUNTRIES.COUNTRY_ISO_CODE WHERE Countries.region = 'Africa'</source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>-- get all countries and corresponding cities, including -- countries without any cities<ept id="1">&lt;/b&gt;</ept> SELECT COUNTRIES.COUNTRY, CITIES.CITY_NAME FROM CITIES RIGHT OUTER JOIN COUNTRIES ON CITIES.COUNTRY_ISO_CODE = COUNTRIES.COUNTRY_ISO_CODE <bpt id="2" ctype="x-b">&lt;b&gt;</bpt>-- get all countries in Africa and corresponding cities, including -- countries without any cities <ept id="2">&lt;/b&gt;</ept> SELECT COUNTRIES.COUNTRY, CITIES.CITY_NAME FROM CITIES RIGHT OUTER JOIN COUNTRIES ON CITIES.COUNTRY_ISO_CODE = COUNTRIES.COUNTRY_ISO_CODE WHERE Countries.region = 'Africa' <bpt id="3" ctype="x-b">&lt;b&gt;</bpt>-- use the synonymous syntax, RIGHT JOIN, to achieve exactly -- the same results as in the example above <ept id="3">&lt;/b&gt;</ept> SELECT COUNTRIES.COUNTRY, CITIES.CITY_NAME FROM CITIES RIGHT JOIN COUNTRIES ON CITIES.COUNTRY_ISO_CODE = COUNTRIES.COUNTRY_ISO_CODE WHERE Countries.region = 'Africa'</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>-- get all countries and corresponding cities, including -- countries without any cities<ept id="1">&lt;/b&gt;</ept> SELECT COUNTRIES.COUNTRY, CITIES.CITY_NAME FROM CITIES RIGHT OUTER JOIN COUNTRIES ON CITIES.COUNTRY_ISO_CODE = COUNTRIES.COUNTRY_ISO_CODE <bpt id="2" ctype="x-b">&lt;b&gt;</bpt>-- get all countries in Africa and corresponding cities, including -- countries without any cities <ept id="2">&lt;/b&gt;</ept> SELECT COUNTRIES.COUNTRY, CITIES.CITY_NAME FROM CITIES RIGHT OUTER JOIN COUNTRIES ON CITIES.COUNTRY_ISO_CODE = COUNTRIES.COUNTRY_ISO_CODE WHERE Countries.region = 'Africa' <bpt id="3" ctype="x-b">&lt;b&gt;</bpt>-- use the synonymous syntax, RIGHT JOIN, to achieve exactly -- the same results as in the example above <ept id="3">&lt;/b&gt;</ept> SELECT COUNTRIES.COUNTRY, CITIES.CITY_NAME FROM CITIES RIGHT JOIN COUNTRIES ON CITIES.COUNTRY_ISO_CODE = COUNTRIES.COUNTRY_ISO_CODE WHERE Countries.region = 'Africa'</mrk></target>
</trans-unit>
<trans-unit id="tu9">
<source xml:lang="en">Example 2</source>
<seg-source><mrk mid="0" mtype="seg">Example 2</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Example 2</mrk></target>
</trans-unit>
<trans-unit id="tu10">
<source xml:lang="en"><it id="1" ctype="x-b" pos="open">&lt;b&gt;</it>-- a tableExpression can be a join operation. Therefore -- you can have multiple join operations in a FROM clause -- List every employee number and last name -- with the employee number and last name of their manager <it id="1" ctype="x-b" pos="close">&lt;/b&gt;</it> SELECT E.EMPNO, E.LASTNAME, M.EMPNO, M.LASTNAME FROM EMPLOYEE E RIGHT OUTER JOIN DEPARTMENT RIGHT OUTER JOIN EMPLOYEE M ON MGRNO = M.EMPNO ON E.WORKDEPT = DEPTNO</source>
<seg-source><mrk mid="0" mtype="seg"><it id="1" ctype="x-b" pos="open">&lt;b&gt;</it>-- a tableExpression can be a join operation.</mrk><mrk mid="1" mtype="seg"> Therefore -- you can have multiple join operations in a FROM clause -- List every employee number and last name -- with the employee number and last name of their manager <it id="1" ctype="x-b" pos="close">&lt;/b&gt;</it> SELECT E.EMPNO, E.LASTNAME, M.EMPNO, M.LASTNAME FROM EMPLOYEE E RIGHT OUTER JOIN DEPARTMENT RIGHT OUTER JOIN EMPLOYEE M ON MGRNO = M.EMPNO ON E.WORKDEPT = DEPTNO</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><it id="1" ctype="x-b" pos="open">&lt;b&gt;</it>-- a tableExpression can be a join operation.</mrk><mrk mid="1" mtype="seg"> Therefore -- you can have multiple join operations in a FROM clause -- List every employee number and last name -- with the employee number and last name of their manager <it id="1" ctype="x-b" pos="close">&lt;/b&gt;</it> SELECT E.EMPNO, E.LASTNAME, M.EMPNO, M.LASTNAME FROM EMPLOYEE E RIGHT OUTER JOIN DEPARTMENT RIGHT OUTER JOIN EMPLOYEE M ON MGRNO = M.EMPNO ON E.WORKDEPT = DEPTNO</mrk></target>
</trans-unit>
</body>
</file>
</xliff>
