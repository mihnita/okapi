<?xml version="1.0" encoding="UTF-8"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:okp="okapi-framework:xliff-extensions" xmlns:its="http://www.w3.org/2005/11/its" xmlns:itsxlf="http://www.w3.org/ns/its-xliff/" its:version="2.0">
<file original="rreffuncxmlparse.dita" source-language="en" target-language="fr" datatype="xml" okp:inputEncoding="utf-8" okp:configId="/home/jimh/Code/Okapi/okapi/okapi/filters/xmlstream/target/classes/net/sf/okapi/filters/xmlstream/dita.yml">
<header><tool tool-id="okapi" tool-name="okapi-tests" tool-version="M29" tool-company="okapi"></tool></header>
<body>
<trans-unit id="tu1">
<source xml:lang="en">XMLPARSE operator</source>
<seg-source><mrk mid="0" mtype="seg">XMLPARSE operator</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">XMLPARSE operator</mrk></target>
</trans-unit>
<trans-unit id="tu2">
<source xml:lang="en">XMLPARSE is a SQL/XML operator that you use to parse a character string expression into a <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> XML value.</source>
<seg-source><mrk mid="0" mtype="seg">XMLPARSE is a SQL/XML operator that you use to parse a character string expression into a <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> XML value.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">XMLPARSE is a SQL/XML operator that you use to parse a character string expression into a <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> XML value.</mrk></target>
</trans-unit>
<trans-unit id="tu3">
<source xml:lang="en">XMLPARSE operator</source>
<seg-source><mrk mid="0" mtype="seg">XMLPARSE operator</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">XMLPARSE operator</mrk></target>
</trans-unit>
<trans-unit id="tu4">
<source xml:lang="en">operators</source>
<seg-source><mrk mid="0" mtype="seg">operators</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">operators</mrk></target>
</trans-unit>
<trans-unit id="tu5">
<source xml:lang="en">XMLPARSE</source>
<seg-source><mrk mid="0" mtype="seg">XMLPARSE</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">XMLPARSE</mrk></target>
</trans-unit>
<trans-unit id="tu6">
<source xml:lang="en">XML</source>
<seg-source><mrk mid="0" mtype="seg">XML</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">XML</mrk></target>
</trans-unit>
<trans-unit id="tu7">
<source xml:lang="en">operators, XMLPARSE</source>
<seg-source><mrk mid="0" mtype="seg">operators, XMLPARSE</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">operators, XMLPARSE</mrk></target>
</trans-unit>
<trans-unit id="tu8">
<source xml:lang="en">You can use the result of this operator temporarily or you can store the result permanently in <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> XML columns. Whether temporary or permanent, you can use the XML value as an input to the other <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> XML operators, such as <bpt id="3" ctype="x-xref">&lt;xref href="rreffuncxmlexists.dita#rreffuncxmlexists"&gt;</bpt>XMLEXISTS<ept id="3">&lt;/xref&gt;</ept> and <bpt id="4" ctype="x-xref">&lt;xref
href="rreffuncxmlquery.dita#rreffuncxmlquery"&gt;</bpt>XMLQUERY<ept id="4">&lt;/xref&gt;</ept>.</source>
<seg-source><mrk mid="0" mtype="seg">You can use the result of this operator temporarily or you can store the result permanently in <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> XML columns.</mrk><mrk mid="1" mtype="seg"> Whether temporary or permanent, you can use the XML value as an input to the other <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> XML operators, such as <bpt id="3" ctype="x-xref">&lt;xref href="rreffuncxmlexists.dita#rreffuncxmlexists"&gt;</bpt>XMLEXISTS<ept id="3">&lt;/xref&gt;</ept> and <bpt id="4" ctype="x-xref">&lt;xref
href="rreffuncxmlquery.dita#rreffuncxmlquery"&gt;</bpt>XMLQUERY<ept id="4">&lt;/xref&gt;</ept>.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">You can use the result of this operator temporarily or you can store the result permanently in <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> XML columns.</mrk><mrk mid="1" mtype="seg"> Whether temporary or permanent, you can use the XML value as an input to the other <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> XML operators, such as <bpt id="3" ctype="x-xref">&lt;xref href="rreffuncxmlexists.dita#rreffuncxmlexists"&gt;</bpt>XMLEXISTS<ept id="3">&lt;/xref&gt;</ept> and <bpt id="4" ctype="x-xref">&lt;xref
href="rreffuncxmlquery.dita#rreffuncxmlquery"&gt;</bpt>XMLQUERY<ept id="4">&lt;/xref&gt;</ept>.</mrk></target>
</trans-unit>
<trans-unit id="tu9">
<source xml:lang="en">Syntax</source>
<seg-source><mrk mid="0" mtype="seg">Syntax</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Syntax</mrk></target>
</trans-unit>
<trans-unit id="tu10">
<source xml:lang="en"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>XMLPARSE ( DOCUMENT <bpt id="2" ctype="x-varname">&lt;varname&gt;</bpt>stringValueExpression<ept id="2">&lt;/varname&gt;</ept> PRESERVE WHITESPACE )<ept id="1">&lt;/b&gt;</ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>XMLPARSE ( DOCUMENT <bpt id="2" ctype="x-varname">&lt;varname&gt;</bpt>stringValueExpression<ept id="2">&lt;/varname&gt;</ept> PRESERVE WHITESPACE )<ept id="1">&lt;/b&gt;</ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>XMLPARSE ( DOCUMENT <bpt id="2" ctype="x-varname">&lt;varname&gt;</bpt>stringValueExpression<ept id="2">&lt;/varname&gt;</ept> PRESERVE WHITESPACE )<ept id="1">&lt;/b&gt;</ept></mrk></target>
</trans-unit>
<trans-unit id="tu11">
<source xml:lang="en">DOCUMENT</source>
<seg-source><mrk mid="0" mtype="seg">DOCUMENT</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">DOCUMENT</mrk></target>
</trans-unit>
<trans-unit id="tu12">
<source xml:lang="en">Required keyword that describes the type of XML input that <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> can parse. <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> can only parse string expressions that constitute well-formed XML documents. This is because <bpt id="3" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="3">&lt;/ph&gt;</ept> uses a JAXP parser to parse all string values. The JAXP parser expects the <bpt id="4" ctype="x-varname">&lt;varname&gt;</bpt>stringValueExpression<ept id="4">&lt;/varname&gt;</ept> to constitute a well-formed XML document. If the string does not constitute a well-formed document, JAXP throws an error. <bpt id="5" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="5">&lt;/ph&gt;</ept> catches the error and throws the error as a SQLException.</source>
<seg-source><mrk mid="0" mtype="seg">Required keyword that describes the type of XML input that <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> can parse.</mrk><mrk mid="1" mtype="seg"> <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> can only parse string expressions that constitute well-formed XML documents.</mrk><mrk mid="2" mtype="seg"> This is because <bpt id="3" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="3">&lt;/ph&gt;</ept> uses a JAXP parser to parse all string values.</mrk><mrk mid="3" mtype="seg"> The JAXP parser expects the <bpt id="4" ctype="x-varname">&lt;varname&gt;</bpt>stringValueExpression<ept id="4">&lt;/varname&gt;</ept> to constitute a well-formed XML document.</mrk><mrk mid="4" mtype="seg"> If the string does not constitute a well-formed document, JAXP throws an error.</mrk><mrk mid="5" mtype="seg"> <bpt id="5" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="5">&lt;/ph&gt;</ept> catches the error and throws the error as a SQLException.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Required keyword that describes the type of XML input that <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> can parse.</mrk><mrk mid="1" mtype="seg"> <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> can only parse string expressions that constitute well-formed XML documents.</mrk><mrk mid="2" mtype="seg"> This is because <bpt id="3" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="3">&lt;/ph&gt;</ept> uses a JAXP parser to parse all string values.</mrk><mrk mid="3" mtype="seg"> The JAXP parser expects the <bpt id="4" ctype="x-varname">&lt;varname&gt;</bpt>stringValueExpression<ept id="4">&lt;/varname&gt;</ept> to constitute a well-formed XML document.</mrk><mrk mid="4" mtype="seg"> If the string does not constitute a well-formed document, JAXP throws an error.</mrk><mrk mid="5" mtype="seg"> <bpt id="5" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="5">&lt;/ph&gt;</ept> catches the error and throws the error as a SQLException.</mrk></target>
</trans-unit>
<trans-unit id="tu13">
<source xml:lang="en"><bpt id="1" ctype="x-varname">&lt;varname&gt;</bpt>stringValueExpression<ept id="1">&lt;/varname&gt;</ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-varname">&lt;varname&gt;</bpt>stringValueExpression<ept id="1">&lt;/varname&gt;</ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-varname">&lt;varname&gt;</bpt>stringValueExpression<ept id="1">&lt;/varname&gt;</ept></mrk></target>
</trans-unit>
<trans-unit id="tu14">
<source xml:lang="en">Any expression that evaluates to a SQL character type, such as CHAR, VARCHAR, LONG VARCHAR, or CLOB. The <bpt id="1" ctype="x-varname">&lt;varname&gt;</bpt>stringValueExpression<ept id="1">&lt;/varname&gt;</ept> argument can also be a parameter. You must use the CAST function when you specify the parameter to indicate the type of value that is bound into the parameter. <bpt id="2" ctype="x-ph">&lt;ph
conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> must verify that the parameter is the correct data type before the value is parsed as an XML document. If a parameter is specified without the CAST function, or if the CAST is to a non-character datatype, <bpt id="3" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="3">&lt;/ph&gt;</ept> throws an error.</source>
<seg-source><mrk mid="0" mtype="seg">Any expression that evaluates to a SQL character type, such as CHAR, VARCHAR, LONG VARCHAR, or CLOB.</mrk><mrk mid="1" mtype="seg"> The <bpt id="1" ctype="x-varname">&lt;varname&gt;</bpt>stringValueExpression<ept id="1">&lt;/varname&gt;</ept> argument can also be a parameter.</mrk><mrk mid="2" mtype="seg"> You must use the CAST function when you specify the parameter to indicate the type of value that is bound into the parameter.</mrk><mrk mid="3" mtype="seg"> <bpt id="2" ctype="x-ph">&lt;ph
conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> must verify that the parameter is the correct data type before the value is parsed as an XML document.</mrk><mrk mid="4" mtype="seg"> If a parameter is specified without the CAST function, or if the CAST is to a non-character datatype, <bpt id="3" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="3">&lt;/ph&gt;</ept> throws an error.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Any expression that evaluates to a SQL character type, such as CHAR, VARCHAR, LONG VARCHAR, or CLOB.</mrk><mrk mid="1" mtype="seg"> The <bpt id="1" ctype="x-varname">&lt;varname&gt;</bpt>stringValueExpression<ept id="1">&lt;/varname&gt;</ept> argument can also be a parameter.</mrk><mrk mid="2" mtype="seg"> You must use the CAST function when you specify the parameter to indicate the type of value that is bound into the parameter.</mrk><mrk mid="3" mtype="seg"> <bpt id="2" ctype="x-ph">&lt;ph
conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> must verify that the parameter is the correct data type before the value is parsed as an XML document.</mrk><mrk mid="4" mtype="seg"> If a parameter is specified without the CAST function, or if the CAST is to a non-character datatype, <bpt id="3" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="3">&lt;/ph&gt;</ept> throws an error.</mrk></target>
</trans-unit>
<trans-unit id="tu15">
<source xml:lang="en">PRESERVE WHITESPACE</source>
<seg-source><mrk mid="0" mtype="seg">PRESERVE WHITESPACE</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">PRESERVE WHITESPACE</mrk></target>
</trans-unit>
<trans-unit id="tu16">
<source xml:lang="en">Required keywords that describe how <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> handles whitespace between consecutive XML nodes. When the PRESERVE WHITESPACE keywords are used, <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> preserves whitespace as dictated by the SQL/XML rules for preserving whitespace.</source>
<seg-source><mrk mid="0" mtype="seg">Required keywords that describe how <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> handles whitespace between consecutive XML nodes.</mrk><mrk mid="1" mtype="seg"> When the PRESERVE WHITESPACE keywords are used, <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> preserves whitespace as dictated by the SQL/XML rules for preserving whitespace.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Required keywords that describe how <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> handles whitespace between consecutive XML nodes.</mrk><mrk mid="1" mtype="seg"> When the PRESERVE WHITESPACE keywords are used, <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> preserves whitespace as dictated by the SQL/XML rules for preserving whitespace.</mrk></target>
</trans-unit>
<trans-unit id="tu17">
<source xml:lang="en">For more information on what constitutes a well-formed XML document, see the following specification: <bpt id="1" ctype="x-xref">&lt;xref format="html" href="http://www.w3.org/TR/REC-xml/#sec-well-formed"&gt;</bpt>http://www.w3.org/TR/REC-xml/#sec-well-formed<ept id="1">&lt;/xref&gt;</ept>.</source>
<seg-source><mrk mid="0" mtype="seg">For more information on what constitutes a well-formed XML document, see the following specification: <bpt id="1" ctype="x-xref">&lt;xref format="html" href="http://www.w3.org/TR/REC-xml/#sec-well-formed"&gt;</bpt>http://www.w3.org/TR/REC-xml/#sec-well-formed<ept id="1">&lt;/xref&gt;</ept>.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">For more information on what constitutes a well-formed XML document, see the following specification: <bpt id="1" ctype="x-xref">&lt;xref format="html" href="http://www.w3.org/TR/REC-xml/#sec-well-formed"&gt;</bpt>http://www.w3.org/TR/REC-xml/#sec-well-formed<ept id="1">&lt;/xref&gt;</ept>.</mrk></target>
</trans-unit>
<trans-unit id="tu18">
<source xml:lang="en">The SQL/XML standard dictates that the argument to the XMLPARSE operator can also be a binary string. However, <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> only supports character string input for the XMLPARSE operator.</source>
<seg-source><mrk mid="0" mtype="seg">The SQL/XML standard dictates that the argument to the XMLPARSE operator can also be a binary string.</mrk><mrk mid="1" mtype="seg"> However, <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> only supports character string input for the XMLPARSE operator.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">The SQL/XML standard dictates that the argument to the XMLPARSE operator can also be a binary string.</mrk><mrk mid="1" mtype="seg"> However, <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> only supports character string input for the XMLPARSE operator.</mrk></target>
</trans-unit>
<trans-unit id="tu19">
<source xml:lang="en">Examples</source>
<seg-source><mrk mid="0" mtype="seg">Examples</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Examples</mrk></target>
</trans-unit>
<trans-unit id="tu20">
<source xml:lang="en">To insert a simple XML document into the <bpt id="1" ctype="x-codeph">&lt;codeph&gt;</bpt>xcol<ept id="1">&lt;/codeph&gt;</ept> XML column in the <bpt id="2" ctype="x-codeph">&lt;codeph&gt;</bpt>x_table<ept id="2">&lt;/codeph&gt;</ept> table, use the following statement:</source>
<seg-source><mrk mid="0" mtype="seg">To insert a simple XML document into the <bpt id="1" ctype="x-codeph">&lt;codeph&gt;</bpt>xcol<ept id="1">&lt;/codeph&gt;</ept> XML column in the <bpt id="2" ctype="x-codeph">&lt;codeph&gt;</bpt>x_table<ept id="2">&lt;/codeph&gt;</ept> table, use the following statement:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">To insert a simple XML document into the <bpt id="1" ctype="x-codeph">&lt;codeph&gt;</bpt>xcol<ept id="1">&lt;/codeph&gt;</ept> XML column in the <bpt id="2" ctype="x-codeph">&lt;codeph&gt;</bpt>x_table<ept id="2">&lt;/codeph&gt;</ept> table, use the following statement:</mrk></target>
</trans-unit>
<trans-unit id="tu21">
<source xml:lang="en"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>INSERT INTO x_table VALUES (1, XMLPARSE(DOCUMENT ' &lt;roster&gt; &lt;student age="18"&gt;AB&lt;/student&gt; &lt;student age="23"&gt;BC&lt;/student&gt; &lt;student&gt;NOAGE&lt;/student&gt; &lt;/roster&gt;' PRESERVE WHITESPACE) )<ept id="1">&lt;/b&gt;</ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>INSERT INTO x_table VALUES (1, XMLPARSE(DOCUMENT ' &lt;roster&gt; &lt;student age="18"&gt;AB&lt;/student&gt; &lt;student age="23"&gt;BC&lt;/student&gt; &lt;student&gt;NOAGE&lt;/student&gt; &lt;/roster&gt;' PRESERVE WHITESPACE) )<ept id="1">&lt;/b&gt;</ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>INSERT INTO x_table VALUES (1, XMLPARSE(DOCUMENT ' &lt;roster&gt; &lt;student age="18"&gt;AB&lt;/student&gt; &lt;student age="23"&gt;BC&lt;/student&gt; &lt;student&gt;NOAGE&lt;/student&gt; &lt;/roster&gt;' PRESERVE WHITESPACE) )<ept id="1">&lt;/b&gt;</ept></mrk></target>
</trans-unit>
<trans-unit id="tu22">
<source xml:lang="en">To insert a large XML document into the <bpt id="1" ctype="x-codeph">&lt;codeph&gt;</bpt>xcol<ept id="1">&lt;/codeph&gt;</ept> XML column in the <bpt id="2" ctype="x-codeph">&lt;codeph&gt;</bpt>x_table<ept id="2">&lt;/codeph&gt;</ept> table, from JDBC use the following statement:</source>
<seg-source><mrk mid="0" mtype="seg">To insert a large XML document into the <bpt id="1" ctype="x-codeph">&lt;codeph&gt;</bpt>xcol<ept id="1">&lt;/codeph&gt;</ept> XML column in the <bpt id="2" ctype="x-codeph">&lt;codeph&gt;</bpt>x_table<ept id="2">&lt;/codeph&gt;</ept> table, from JDBC use the following statement:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">To insert a large XML document into the <bpt id="1" ctype="x-codeph">&lt;codeph&gt;</bpt>xcol<ept id="1">&lt;/codeph&gt;</ept> XML column in the <bpt id="2" ctype="x-codeph">&lt;codeph&gt;</bpt>x_table<ept id="2">&lt;/codeph&gt;</ept> table, from JDBC use the following statement:</mrk></target>
</trans-unit>
<trans-unit id="tu23">
<source xml:lang="en"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>INSERT INTO x_table VALUES(2, XMLPARSE (DOCUMENT CAST (? AS CLOB) PRESERVE WHITESPACE) )<ept id="1">&lt;/b&gt;</ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>INSERT INTO x_table VALUES(2, XMLPARSE (DOCUMENT CAST (? AS CLOB) PRESERVE WHITESPACE) )<ept id="1">&lt;/b&gt;</ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>INSERT INTO x_table VALUES(2, XMLPARSE (DOCUMENT CAST (? AS CLOB) PRESERVE WHITESPACE) )<ept id="1">&lt;/b&gt;</ept></mrk></target>
</trans-unit>
<trans-unit id="tu24">
<source xml:lang="en">You should bind into the statement using the <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>setCharacterStream()<ept id="1">&lt;/i&gt;</ept> method, or any other JDBC <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>setXXX<ept id="2">&lt;/i&gt;</ept> method that works for the CAST target type.</source>
<seg-source><mrk mid="0" mtype="seg">You should bind into the statement using the <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>setCharacterStream()<ept id="1">&lt;/i&gt;</ept> method, or any other JDBC <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>setXXX<ept id="2">&lt;/i&gt;</ept> method that works for the CAST target type.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">You should bind into the statement using the <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>setCharacterStream()<ept id="1">&lt;/i&gt;</ept> method, or any other JDBC <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>setXXX<ept id="2">&lt;/i&gt;</ept> method that works for the CAST target type.</mrk></target>
</trans-unit>
<trans-unit id="tu25">
<source xml:lang="en">Usage note</source>
<seg-source><mrk mid="0" mtype="seg">Usage note</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Usage note</mrk></target>
</trans-unit>
<trans-unit id="tu26">
<source xml:lang="en"><bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> requires that a JAXP parser (such as Apache Xerces) and Apache Xalan are listed in the Java classpath for the XML functions to work. If either the JAXP parser or Xalan is missing from the classpath, attempts to use the XMLPARSE operator will result in an error. In some situations, you may need to take steps to place the parser and Xalan in your classpath. See "XML data types and operators" in the <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#pub/citdevelop"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> for details.</source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> requires that a JAXP parser (such as Apache Xerces) and Apache Xalan are listed in the Java classpath for the XML functions to work.</mrk><mrk mid="1" mtype="seg"> If either the JAXP parser or Xalan is missing from the classpath, attempts to use the XMLPARSE operator will result in an error.</mrk><mrk mid="2" mtype="seg"> In some situations, you may need to take steps to place the parser and Xalan in your classpath.</mrk><mrk mid="3" mtype="seg"> See "XML data types and operators" in the <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#pub/citdevelop"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> for details.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> requires that a JAXP parser (such as Apache Xerces) and Apache Xalan are listed in the Java classpath for the XML functions to work.</mrk><mrk mid="1" mtype="seg"> If either the JAXP parser or Xalan is missing from the classpath, attempts to use the XMLPARSE operator will result in an error.</mrk><mrk mid="2" mtype="seg"> In some situations, you may need to take steps to place the parser and Xalan in your classpath.</mrk><mrk mid="3" mtype="seg"> See "XML data types and operators" in the <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#pub/citdevelop"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> for details.</mrk></target>
</trans-unit>
</body>
</file>
</xliff>
