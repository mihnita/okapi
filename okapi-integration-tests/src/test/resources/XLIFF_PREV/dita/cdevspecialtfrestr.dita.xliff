<?xml version="1.0" encoding="UTF-8"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:okp="okapi-framework:xliff-extensions" xmlns:its="http://www.w3.org/2005/11/its" xmlns:itsxlf="http://www.w3.org/ns/its-xliff/" its:version="2.0">
<file original="cdevspecialtfrestr.dita" source-language="en" target-language="fr" datatype="xml" okp:inputEncoding="utf-8" okp:configId="/home/jimh/Code/Okapi/okapi/okapi/filters/xmlstream/target/classes/net/sf/okapi/filters/xmlstream/dita.yml">
<header><tool tool-id="okapi" tool-name="okapi-tests" tool-version="M29" tool-company="okapi"></tool></header>
<body>
<trans-unit id="tu1">
<source xml:lang="en">Writing restricted table functions</source>
<seg-source><mrk mid="0" mtype="seg">Writing restricted table functions</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Writing restricted table functions</mrk></target>
</trans-unit>
<trans-unit id="tu2">
<source xml:lang="en">Restricted table functions are <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept>-style table functions which perform more efficiently because they can be told in advance which columns they will be asked to fetch along with simple limits on those columns. This feature exploits the expressiveness of the Java programming language and does not require any extensions to SQL.</source>
<seg-source><mrk mid="0" mtype="seg">Restricted table functions are <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept>-style table functions which perform more efficiently because they can be told in advance which columns they will be asked to fetch along with simple limits on those columns.</mrk><mrk mid="1" mtype="seg"> This feature exploits the expressiveness of the Java programming language and does not require any extensions to SQL.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Restricted table functions are <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept>-style table functions which perform more efficiently because they can be told in advance which columns they will be asked to fetch along with simple limits on those columns.</mrk><mrk mid="1" mtype="seg"> This feature exploits the expressiveness of the Java programming language and does not require any extensions to SQL.</mrk></target>
</trans-unit>
<trans-unit id="tu3">
<source xml:lang="en">Functions</source>
<seg-source><mrk mid="0" mtype="seg">Functions</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Functions</mrk></target>
</trans-unit>
<trans-unit id="tu4">
<source xml:lang="en">programming table functions</source>
<seg-source><mrk mid="0" mtype="seg">programming table functions</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">programming table functions</mrk></target>
</trans-unit>
<trans-unit id="tu5">
<source xml:lang="en">A table function returns a rectangular chunk of data. If you use a restricted table function, <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> can tell the table function to return a shorter and narrower rectangle.</source>
<seg-source><mrk mid="0" mtype="seg">A table function returns a rectangular chunk of data.</mrk><mrk mid="1" mtype="seg"> If you use a restricted table function, <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> can tell the table function to return a shorter and narrower rectangle.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">A table function returns a rectangular chunk of data.</mrk><mrk mid="1" mtype="seg"> If you use a restricted table function, <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> can tell the table function to return a shorter and narrower rectangle.</mrk></target>
</trans-unit>
<trans-unit id="tu6">
<source xml:lang="en">Consider the following scan of a table in a foreign database:</source>
<seg-source><mrk mid="0" mtype="seg">Consider the following scan of a table in a foreign database:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Consider the following scan of a table in a foreign database:</mrk></target>
</trans-unit>
<trans-unit id="tu7">
<source xml:lang="en">select id, firstName, lastName from table( foreignDatabaseEmployeeTable() ) s where lastName = 'Stone'</source>
<seg-source><mrk mid="0" mtype="seg">select id, firstName, lastName from table( foreignDatabaseEmployeeTable() ) s where lastName = 'Stone'</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">select id, firstName, lastName from table( foreignDatabaseEmployeeTable() ) s where lastName = 'Stone'</mrk></target>
</trans-unit>
<trans-unit id="tu8">
<source xml:lang="en">If <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>foreignDatabaseEmployeeTable<ept id="1">&lt;/i&gt;</ept> is a restricted table function, <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> can tell the table function to fetch only the <bpt id="3" ctype="x-i">&lt;i&gt;</bpt>id<ept id="3">&lt;/i&gt;</ept>, <bpt id="4" ctype="x-i">&lt;i&gt;</bpt>firstName<ept id="4">&lt;/i&gt;</ept>, and <bpt id="5" ctype="x-i">&lt;i&gt;</bpt>lastName<ept id="5">&lt;/i&gt;</ept> columns. In addition, <bpt id="6" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="6">&lt;/ph&gt;</ept> can tell the table function that it does not need to scan the entire foreign table; instead, the table function only needs to retrieve information for employees whose last name is "Stone".</source>
<seg-source><mrk mid="0" mtype="seg">If <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>foreignDatabaseEmployeeTable<ept id="1">&lt;/i&gt;</ept> is a restricted table function, <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> can tell the table function to fetch only the <bpt id="3" ctype="x-i">&lt;i&gt;</bpt>id<ept id="3">&lt;/i&gt;</ept>, <bpt id="4" ctype="x-i">&lt;i&gt;</bpt>firstName<ept id="4">&lt;/i&gt;</ept>, and <bpt id="5" ctype="x-i">&lt;i&gt;</bpt>lastName<ept id="5">&lt;/i&gt;</ept> columns.</mrk><mrk mid="1" mtype="seg"> In addition, <bpt id="6" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="6">&lt;/ph&gt;</ept> can tell the table function that it does not need to scan the entire foreign table; instead, the table function only needs to retrieve information for employees whose last name is "Stone".</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">If <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>foreignDatabaseEmployeeTable<ept id="1">&lt;/i&gt;</ept> is a restricted table function, <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> can tell the table function to fetch only the <bpt id="3" ctype="x-i">&lt;i&gt;</bpt>id<ept id="3">&lt;/i&gt;</ept>, <bpt id="4" ctype="x-i">&lt;i&gt;</bpt>firstName<ept id="4">&lt;/i&gt;</ept>, and <bpt id="5" ctype="x-i">&lt;i&gt;</bpt>lastName<ept id="5">&lt;/i&gt;</ept> columns.</mrk><mrk mid="1" mtype="seg"> In addition, <bpt id="6" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="6">&lt;/ph&gt;</ept> can tell the table function that it does not need to scan the entire foreign table; instead, the table function only needs to retrieve information for employees whose last name is "Stone".</mrk></target>
</trans-unit>
<trans-unit id="tu9">
<source xml:lang="en">Depending on the table function and query, this feature can support 1000X, 1000000X, or even greater performance improvements.</source>
<seg-source><mrk mid="0" mtype="seg">Depending on the table function and query, this feature can support 1000X, 1000000X, or even greater performance improvements.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Depending on the table function and query, this feature can support 1000X, 1000000X, or even greater performance improvements.</mrk></target>
</trans-unit>
<trans-unit id="tu10">
<source xml:lang="en">How to use restricted table functions</source>
<seg-source><mrk mid="0" mtype="seg">How to use restricted table functions</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">How to use restricted table functions</mrk></target>
</trans-unit>
<trans-unit id="tu11">
<source xml:lang="en">Creating and using a restricted table function involves the following steps:</source>
<seg-source><mrk mid="0" mtype="seg">Creating and using a restricted table function involves the following steps:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Creating and using a restricted table function involves the following steps:</mrk></target>
</trans-unit>
<trans-unit id="tu12">
<source xml:lang="en"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>Implement<ept id="1">&lt;/b&gt;</ept> - You must write a class which implements both <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>java.sql.ResultSet<ept id="2">&lt;/i&gt;</ept> and the <bpt id="3" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="3">&lt;/ph&gt;</ept>-specific interface <bpt id="4" ctype="x-i">&lt;i&gt;</bpt>org.apache.derby.vti.RestrictedVTI<ept id="4">&lt;/i&gt;</ept>. This interface defines an <bpt id="5" ctype="x-i">&lt;i&gt;</bpt>initScan()<ept id="5">&lt;/i&gt;</ept> method. When executing a query, <bpt id="6" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="6">&lt;/ph&gt;</ept> uses that method to tell the table function what columns it will have to fetch and what bounds should be applied to those columns in order to reduce the number of rows returned. For the rest of this discussion, this user-written class will be referred to as <bpt id="7" ctype="x-i">&lt;i&gt;</bpt>MyVTIClass<ept id="7">&lt;/i&gt;</ept>.</source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>Implement<ept id="1">&lt;/b&gt;</ept> - You must write a class which implements both <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>java.sql.ResultSet<ept id="2">&lt;/i&gt;</ept> and the <bpt id="3" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="3">&lt;/ph&gt;</ept>-specific interface <bpt id="4" ctype="x-i">&lt;i&gt;</bpt>org.apache.derby.vti.RestrictedVTI<ept id="4">&lt;/i&gt;</ept>.</mrk><mrk mid="1" mtype="seg"> This interface defines an <bpt id="5" ctype="x-i">&lt;i&gt;</bpt>initScan()<ept id="5">&lt;/i&gt;</ept> method.</mrk><mrk mid="2" mtype="seg"> When executing a query, <bpt id="6" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="6">&lt;/ph&gt;</ept> uses that method to tell the table function what columns it will have to fetch and what bounds should be applied to those columns in order to reduce the number of rows returned.</mrk><mrk mid="3" mtype="seg"> For the rest of this discussion, this user-written class will be referred to as <bpt id="7" ctype="x-i">&lt;i&gt;</bpt>MyVTIClass<ept id="7">&lt;/i&gt;</ept>.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>Implement<ept id="1">&lt;/b&gt;</ept> - You must write a class which implements both <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>java.sql.ResultSet<ept id="2">&lt;/i&gt;</ept> and the <bpt id="3" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="3">&lt;/ph&gt;</ept>-specific interface <bpt id="4" ctype="x-i">&lt;i&gt;</bpt>org.apache.derby.vti.RestrictedVTI<ept id="4">&lt;/i&gt;</ept>.</mrk><mrk mid="1" mtype="seg"> This interface defines an <bpt id="5" ctype="x-i">&lt;i&gt;</bpt>initScan()<ept id="5">&lt;/i&gt;</ept> method.</mrk><mrk mid="2" mtype="seg"> When executing a query, <bpt id="6" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="6">&lt;/ph&gt;</ept> uses that method to tell the table function what columns it will have to fetch and what bounds should be applied to those columns in order to reduce the number of rows returned.</mrk><mrk mid="3" mtype="seg"> For the rest of this discussion, this user-written class will be referred to as <bpt id="7" ctype="x-i">&lt;i&gt;</bpt>MyVTIClass<ept id="7">&lt;/i&gt;</ept>.</mrk></target>
</trans-unit>
<trans-unit id="tu13">
<source xml:lang="en"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>Publish<ept id="1">&lt;/b&gt;</ept> - You must publish the table function by creating a public static method which returns a <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>MyVTIClass<ept id="2">&lt;/i&gt;</ept>. This is important. The <bpt id="3" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="3">&lt;/ph&gt;</ept> compiler must be able to see that the table function returns an object which implements both <bpt id="4" ctype="x-i">&lt;i&gt;</bpt>java.sql.ResultSet<ept id="4">&lt;/i&gt;</ept> and <bpt id="5" ctype="x-i">&lt;i&gt;</bpt>org.apache.derby.vti.RestrictedVTI<ept id="5">&lt;/i&gt;</ept>.</source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>Publish<ept id="1">&lt;/b&gt;</ept> - You must publish the table function by creating a public static method which returns a <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>MyVTIClass<ept id="2">&lt;/i&gt;</ept>.</mrk><mrk mid="1" mtype="seg"> This is important.</mrk><mrk mid="2" mtype="seg"> The <bpt id="3" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="3">&lt;/ph&gt;</ept> compiler must be able to see that the table function returns an object which implements both <bpt id="4" ctype="x-i">&lt;i&gt;</bpt>java.sql.ResultSet<ept id="4">&lt;/i&gt;</ept> and <bpt id="5" ctype="x-i">&lt;i&gt;</bpt>org.apache.derby.vti.RestrictedVTI<ept id="5">&lt;/i&gt;</ept>.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>Publish<ept id="1">&lt;/b&gt;</ept> - You must publish the table function by creating a public static method which returns a <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>MyVTIClass<ept id="2">&lt;/i&gt;</ept>.</mrk><mrk mid="1" mtype="seg"> This is important.</mrk><mrk mid="2" mtype="seg"> The <bpt id="3" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="3">&lt;/ph&gt;</ept> compiler must be able to see that the table function returns an object which implements both <bpt id="4" ctype="x-i">&lt;i&gt;</bpt>java.sql.ResultSet<ept id="4">&lt;/i&gt;</ept> and <bpt id="5" ctype="x-i">&lt;i&gt;</bpt>org.apache.derby.vti.RestrictedVTI<ept id="5">&lt;/i&gt;</ept>.</mrk></target>
</trans-unit>
<trans-unit id="tu14">
<source xml:lang="en"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>Declare<ept id="1">&lt;/b&gt;</ept> - You declare the table function to <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> using the same CREATE FUNCTION syntax you are already familiar with. This syntax does not change.</source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>Declare<ept id="1">&lt;/b&gt;</ept> - You declare the table function to <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> using the same CREATE FUNCTION syntax you are already familiar with.</mrk><mrk mid="1" mtype="seg"> This syntax does not change.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>Declare<ept id="1">&lt;/b&gt;</ept> - You declare the table function to <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> using the same CREATE FUNCTION syntax you are already familiar with.</mrk><mrk mid="1" mtype="seg"> This syntax does not change.</mrk></target>
</trans-unit>
<trans-unit id="tu15">
<source xml:lang="en"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>Invoke<ept id="1">&lt;/b&gt;</ept> - You then use the table function in a query. When <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> compiles the query, it sees that the return type of the table function implements <bpt id="3" ctype="x-i">&lt;i&gt;</bpt>org.apache.derby.vti.RestrictedVTI<ept id="3">&lt;/i&gt;</ept>. Armed with this information, at runtime <bpt id="4" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="4">&lt;/ph&gt;</ept> calls the <bpt id="5" ctype="x-i">&lt;i&gt;</bpt>initScan()<ept id="5">&lt;/i&gt;</ept> method once before calling any of the <bpt id="6" ctype="x-i">&lt;i&gt;</bpt>ResultSet<ept id="6">&lt;/i&gt;</ept> methods.</source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>Invoke<ept id="1">&lt;/b&gt;</ept> - You then use the table function in a query.</mrk><mrk mid="1" mtype="seg"> When <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> compiles the query, it sees that the return type of the table function implements <bpt id="3" ctype="x-i">&lt;i&gt;</bpt>org.apache.derby.vti.RestrictedVTI<ept id="3">&lt;/i&gt;</ept>.</mrk><mrk mid="2" mtype="seg"> Armed with this information, at runtime <bpt id="4" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="4">&lt;/ph&gt;</ept> calls the <bpt id="5" ctype="x-i">&lt;i&gt;</bpt>initScan()<ept id="5">&lt;/i&gt;</ept> method once before calling any of the <bpt id="6" ctype="x-i">&lt;i&gt;</bpt>ResultSet<ept id="6">&lt;/i&gt;</ept> methods.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>Invoke<ept id="1">&lt;/b&gt;</ept> - You then use the table function in a query.</mrk><mrk mid="1" mtype="seg"> When <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> compiles the query, it sees that the return type of the table function implements <bpt id="3" ctype="x-i">&lt;i&gt;</bpt>org.apache.derby.vti.RestrictedVTI<ept id="3">&lt;/i&gt;</ept>.</mrk><mrk mid="2" mtype="seg"> Armed with this information, at runtime <bpt id="4" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="4">&lt;/ph&gt;</ept> calls the <bpt id="5" ctype="x-i">&lt;i&gt;</bpt>initScan()<ept id="5">&lt;/i&gt;</ept> method once before calling any of the <bpt id="6" ctype="x-i">&lt;i&gt;</bpt>ResultSet<ept id="6">&lt;/i&gt;</ept> methods.</mrk></target>
</trans-unit>
<trans-unit id="tu16">
<source xml:lang="en">For example, you would declare the function as follows:</source>
<seg-source><mrk mid="0" mtype="seg">For example, you would declare the function as follows:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">For example, you would declare the function as follows:</mrk></target>
</trans-unit>
<trans-unit id="tu17">
<source xml:lang="en">public class MyVTIClass implements ResultSet, RestrictedVTI { ... public void initScan(java.lang.String[] columnNames, org.apache.derby.vti.Restriction restriction ) throws SQLException { ... } }</source>
<seg-source><mrk mid="0" mtype="seg">public class MyVTIClass implements ResultSet, RestrictedVTI { ...</mrk><mrk mid="1" mtype="seg"> public void initScan(java.lang.String[] columnNames, org.apache.derby.vti.Restriction restriction ) throws SQLException { ...</mrk><mrk mid="2" mtype="seg"> } }</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">public class MyVTIClass implements ResultSet, RestrictedVTI { ...</mrk><mrk mid="1" mtype="seg"> public void initScan(java.lang.String[] columnNames, org.apache.derby.vti.Restriction restriction ) throws SQLException { ...</mrk><mrk mid="2" mtype="seg"> } }</mrk></target>
</trans-unit>
<trans-unit id="tu18">
<source xml:lang="en">Then you publish the table function method:</source>
<seg-source><mrk mid="0" mtype="seg">Then you publish the table function method:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Then you publish the table function method:</mrk></target>
</trans-unit>
<trans-unit id="tu19">
<source xml:lang="en">public static MyVTIClass foreignDatabaseEmployeeTable() throws SQLException { ... }</source>
<seg-source><mrk mid="0" mtype="seg">public static MyVTIClass foreignDatabaseEmployeeTable() throws SQLException { ...</mrk><mrk mid="1" mtype="seg"> }</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">public static MyVTIClass foreignDatabaseEmployeeTable() throws SQLException { ...</mrk><mrk mid="1" mtype="seg"> }</mrk></target>
</trans-unit>
<trans-unit id="tu20">
<source xml:lang="en">Then you declare the table function to <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept>:</source>
<seg-source><mrk mid="0" mtype="seg">Then you declare the table function to <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept>:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Then you declare the table function to <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept>:</mrk></target>
</trans-unit>
<trans-unit id="tu21">
<source xml:lang="en">create function foreignDatabaseEmployeeTable() returns table ( id int, birthday date, taxPayerID varchar( 50 ), firstName varchar( 50 ), lastName varchar( 50 ) ) language java parameter style DERBY_JDBC_RESULT_SET no sql external name 'com.example.portal.ForeignQueries.foreignDatabaseEmployeeTable'</source>
<seg-source><mrk mid="0" mtype="seg">create function foreignDatabaseEmployeeTable() returns table ( id int, birthday date, taxPayerID varchar( 50 ), firstName varchar( 50 ), lastName varchar( 50 ) ) language java parameter style DERBY_JDBC_RESULT_SET no sql external name 'com.example.portal.ForeignQueries.foreignDatabaseEmployeeTable'</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">create function foreignDatabaseEmployeeTable() returns table ( id int, birthday date, taxPayerID varchar( 50 ), firstName varchar( 50 ), lastName varchar( 50 ) ) language java parameter style DERBY_JDBC_RESULT_SET no sql external name 'com.example.portal.ForeignQueries.foreignDatabaseEmployeeTable'</mrk></target>
</trans-unit>
<trans-unit id="tu22">
<source xml:lang="en">Finally, you invoke the table function in a query:</source>
<seg-source><mrk mid="0" mtype="seg">Finally, you invoke the table function in a query:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Finally, you invoke the table function in a query:</mrk></target>
</trans-unit>
<trans-unit id="tu23">
<source xml:lang="en">select id, firstName, lastName from table( foreignDatabaseEmployeeTable() ) s where lastName = 'Stone'</source>
<seg-source><mrk mid="0" mtype="seg">select id, firstName, lastName from table( foreignDatabaseEmployeeTable() ) s where lastName = 'Stone'</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">select id, firstName, lastName from table( foreignDatabaseEmployeeTable() ) s where lastName = 'Stone'</mrk></target>
</trans-unit>
<trans-unit id="tu24">
<source xml:lang="en">When you invoke this query, <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> does the following:</source>
<seg-source><mrk mid="0" mtype="seg">When you invoke this query, <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> does the following:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">When you invoke this query, <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> does the following:</mrk></target>
</trans-unit>
<trans-unit id="tu25">
<source xml:lang="en"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>Prepare<ept id="1">&lt;/b&gt;</ept> - When <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> prepares the query, <bpt id="3" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="3">&lt;/ph&gt;</ept> sees that the <bpt id="4" ctype="x-i">&lt;i&gt;</bpt>foreignDatabaseEmployeeTable()<ept id="4">&lt;/i&gt;</ept> method returns an object which implements <bpt id="5" ctype="x-i">&lt;i&gt;</bpt>org.apache.derby.vti.RestrictedVTI<ept id="5">&lt;/i&gt;</ept>. This is all that <bpt id="6" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="6">&lt;/ph&gt;</ept> needs to know in order to compile a plan which takes advantage of this feature.</source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>Prepare<ept id="1">&lt;/b&gt;</ept> - When <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> prepares the query, <bpt id="3" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="3">&lt;/ph&gt;</ept> sees that the <bpt id="4" ctype="x-i">&lt;i&gt;</bpt>foreignDatabaseEmployeeTable()<ept id="4">&lt;/i&gt;</ept> method returns an object which implements <bpt id="5" ctype="x-i">&lt;i&gt;</bpt>org.apache.derby.vti.RestrictedVTI<ept id="5">&lt;/i&gt;</ept>.</mrk><mrk mid="1" mtype="seg"> This is all that <bpt id="6" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="6">&lt;/ph&gt;</ept> needs to know in order to compile a plan which takes advantage of this feature.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>Prepare<ept id="1">&lt;/b&gt;</ept> - When <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> prepares the query, <bpt id="3" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="3">&lt;/ph&gt;</ept> sees that the <bpt id="4" ctype="x-i">&lt;i&gt;</bpt>foreignDatabaseEmployeeTable()<ept id="4">&lt;/i&gt;</ept> method returns an object which implements <bpt id="5" ctype="x-i">&lt;i&gt;</bpt>org.apache.derby.vti.RestrictedVTI<ept id="5">&lt;/i&gt;</ept>.</mrk><mrk mid="1" mtype="seg"> This is all that <bpt id="6" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="6">&lt;/ph&gt;</ept> needs to know in order to compile a plan which takes advantage of this feature.</mrk></target>
</trans-unit>
<trans-unit id="tu26">
<source xml:lang="en"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>Execute<ept id="1">&lt;/b&gt;</ept> - When <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> executes the query, <bpt id="3" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="3">&lt;/ph&gt;</ept> calls <bpt id="4" ctype="x-i">&lt;i&gt;</bpt>initScan()<ept id="4">&lt;/i&gt;</ept>. In this example, <bpt id="5" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="5">&lt;/ph&gt;</ept> calls <bpt id="6" ctype="x-i">&lt;i&gt;</bpt>initScan()<ept id="6">&lt;/i&gt;</ept> with the following arguments:</source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>Execute<ept id="1">&lt;/b&gt;</ept> - When <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> executes the query, <bpt id="3" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="3">&lt;/ph&gt;</ept> calls <bpt id="4" ctype="x-i">&lt;i&gt;</bpt>initScan()<ept id="4">&lt;/i&gt;</ept>.</mrk><mrk mid="1" mtype="seg"> In this example, <bpt id="5" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="5">&lt;/ph&gt;</ept> calls <bpt id="6" ctype="x-i">&lt;i&gt;</bpt>initScan()<ept id="6">&lt;/i&gt;</ept> with the following arguments:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>Execute<ept id="1">&lt;/b&gt;</ept> - When <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> executes the query, <bpt id="3" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="3">&lt;/ph&gt;</ept> calls <bpt id="4" ctype="x-i">&lt;i&gt;</bpt>initScan()<ept id="4">&lt;/i&gt;</ept>.</mrk><mrk mid="1" mtype="seg"> In this example, <bpt id="5" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="5">&lt;/ph&gt;</ept> calls <bpt id="6" ctype="x-i">&lt;i&gt;</bpt>initScan()<ept id="6">&lt;/i&gt;</ept> with the following arguments:</mrk></target>
</trans-unit>
<trans-unit id="tu27">
<source xml:lang="en">initScan( new String[] { "ID", null, null, "FIRSTNAME", "LASTNAME" }, new Restriction.ColumnQualifier( "LASTNAME", ORDER_OP_EQUALS, "Stone" ) )</source>
<seg-source><mrk mid="0" mtype="seg">initScan( new String[] { "ID", null, null, "FIRSTNAME", "LASTNAME" }, new Restriction.ColumnQualifier( "LASTNAME", ORDER_OP_EQUALS, "Stone" ) )</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">initScan( new String[] { "ID", null, null, "FIRSTNAME", "LASTNAME" }, new Restriction.ColumnQualifier( "LASTNAME", ORDER_OP_EQUALS, "Stone" ) )</mrk></target>
</trans-unit>
<trans-unit id="tu28">
<source xml:lang="en">This, in turn, causes the following to happen:</source>
<seg-source><mrk mid="0" mtype="seg">This, in turn, causes the following to happen:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">This, in turn, causes the following to happen:</mrk></target>
</trans-unit>
<trans-unit id="tu29">
<source xml:lang="en"><bpt id="1" ctype="x-i">&lt;i&gt;</bpt>Width<ept id="1">&lt;/i&gt;</ept> - The call to <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>initScan()<ept id="2">&lt;/i&gt;</ept> told the table function what columns should be fetched.</source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-i">&lt;i&gt;</bpt>Width<ept id="1">&lt;/i&gt;</ept> - The call to <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>initScan()<ept id="2">&lt;/i&gt;</ept> told the table function what columns should be fetched.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-i">&lt;i&gt;</bpt>Width<ept id="1">&lt;/i&gt;</ept> - The call to <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>initScan()<ept id="2">&lt;/i&gt;</ept> told the table function what columns should be fetched.</mrk></target>
</trans-unit>
<trans-unit id="tu30">
<source xml:lang="en"><bpt id="1" ctype="x-i">&lt;i&gt;</bpt>Length<ept id="1">&lt;/i&gt;</ept> - The call to <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>initScan()<ept id="2">&lt;/i&gt;</ept> told the table function how to filter the rows it returns.</source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-i">&lt;i&gt;</bpt>Length<ept id="1">&lt;/i&gt;</ept> - The call to <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>initScan()<ept id="2">&lt;/i&gt;</ept> told the table function how to filter the rows it returns.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-i">&lt;i&gt;</bpt>Length<ept id="1">&lt;/i&gt;</ept> - The call to <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>initScan()<ept id="2">&lt;/i&gt;</ept> told the table function how to filter the rows it returns.</mrk></target>
</trans-unit>
<trans-unit id="tu31">
<source xml:lang="en"><bpt id="1" ctype="x-i">&lt;i&gt;</bpt>Loop<ept id="1">&lt;/i&gt;</ept> - <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> then calls <bpt id="3" ctype="x-i">&lt;i&gt;</bpt>MyVTIClass.next()<ept id="3">&lt;/i&gt;</ept> and retrieves rows until <bpt id="4" ctype="x-i">&lt;i&gt;</bpt>MyVTIClass.next()<ept id="4">&lt;/i&gt;</ept> returns false. For each row, <bpt id="5" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="5">&lt;/ph&gt;</ept> calls:</source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-i">&lt;i&gt;</bpt>Loop<ept id="1">&lt;/i&gt;</ept> - <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> then calls <bpt id="3" ctype="x-i">&lt;i&gt;</bpt>MyVTIClass.next()<ept id="3">&lt;/i&gt;</ept> and retrieves rows until <bpt id="4" ctype="x-i">&lt;i&gt;</bpt>MyVTIClass.next()<ept id="4">&lt;/i&gt;</ept> returns false.</mrk><mrk mid="1" mtype="seg"> For each row, <bpt id="5" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="5">&lt;/ph&gt;</ept> calls:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-i">&lt;i&gt;</bpt>Loop<ept id="1">&lt;/i&gt;</ept> - <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> then calls <bpt id="3" ctype="x-i">&lt;i&gt;</bpt>MyVTIClass.next()<ept id="3">&lt;/i&gt;</ept> and retrieves rows until <bpt id="4" ctype="x-i">&lt;i&gt;</bpt>MyVTIClass.next()<ept id="4">&lt;/i&gt;</ept> returns false.</mrk><mrk mid="1" mtype="seg"> For each row, <bpt id="5" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="5">&lt;/ph&gt;</ept> calls:</mrk></target>
</trans-unit>
<trans-unit id="tu32">
<source xml:lang="en"><bpt id="1" ctype="x-i">&lt;i&gt;</bpt>MyVTIClass.getInt( 1 )<ept id="1">&lt;/i&gt;</ept> to get the <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>id<ept id="2">&lt;/i&gt;</ept> column.</source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-i">&lt;i&gt;</bpt>MyVTIClass.getInt( 1 )<ept id="1">&lt;/i&gt;</ept> to get the <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>id<ept id="2">&lt;/i&gt;</ept> column.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-i">&lt;i&gt;</bpt>MyVTIClass.getInt( 1 )<ept id="1">&lt;/i&gt;</ept> to get the <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>id<ept id="2">&lt;/i&gt;</ept> column.</mrk></target>
</trans-unit>
<trans-unit id="tu33">
<source xml:lang="en"><bpt id="1" ctype="x-i">&lt;i&gt;</bpt>MyVTIClass.getString( 4 )<ept id="1">&lt;/i&gt;</ept> to get the <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>firstName<ept id="2">&lt;/i&gt;</ept> column.</source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-i">&lt;i&gt;</bpt>MyVTIClass.getString( 4 )<ept id="1">&lt;/i&gt;</ept> to get the <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>firstName<ept id="2">&lt;/i&gt;</ept> column.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-i">&lt;i&gt;</bpt>MyVTIClass.getString( 4 )<ept id="1">&lt;/i&gt;</ept> to get the <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>firstName<ept id="2">&lt;/i&gt;</ept> column.</mrk></target>
</trans-unit>
<trans-unit id="tu34">
<source xml:lang="en"><bpt id="1" ctype="x-i">&lt;i&gt;</bpt>MyVTIClass.getString( 5 )<ept id="1">&lt;/i&gt;</ept> to get the <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>lastName<ept id="2">&lt;/i&gt;</ept> column.</source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-i">&lt;i&gt;</bpt>MyVTIClass.getString( 5 )<ept id="1">&lt;/i&gt;</ept> to get the <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>lastName<ept id="2">&lt;/i&gt;</ept> column.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-i">&lt;i&gt;</bpt>MyVTIClass.getString( 5 )<ept id="1">&lt;/i&gt;</ept> to get the <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>lastName<ept id="2">&lt;/i&gt;</ept> column.</mrk></target>
</trans-unit>
<trans-unit id="tu35">
<source xml:lang="en">Contract</source>
<seg-source><mrk mid="0" mtype="seg">Contract</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Contract</mrk></target>
</trans-unit>
<trans-unit id="tu36">
<source xml:lang="en"><bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> calls <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>initScan()<ept id="2">&lt;/i&gt;</ept> before calling any other method on the <bpt id="3" ctype="x-i">&lt;i&gt;</bpt>ResultSet<ept id="3">&lt;/i&gt;</ept>. The call to <bpt id="4" ctype="x-i">&lt;i&gt;</bpt>initScan()<ept id="4">&lt;/i&gt;</ept> merely passes hints, which the restricted table function can exploit in order to perform better. <bpt id="5" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="5">&lt;/ph&gt;</ept> enforces the restriction outside the table function. Therefore, a restricted table function can still fetch extra columns and can ignore part or all of the restriction set by the call to <bpt id="6" ctype="x-i">&lt;i&gt;</bpt>initScan()<ept id="6">&lt;/i&gt;</ept>.</source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> calls <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>initScan()<ept id="2">&lt;/i&gt;</ept> before calling any other method on the <bpt id="3" ctype="x-i">&lt;i&gt;</bpt>ResultSet<ept id="3">&lt;/i&gt;</ept>.</mrk><mrk mid="1" mtype="seg"> The call to <bpt id="4" ctype="x-i">&lt;i&gt;</bpt>initScan()<ept id="4">&lt;/i&gt;</ept> merely passes hints, which the restricted table function can exploit in order to perform better.</mrk><mrk mid="2" mtype="seg"> <bpt id="5" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="5">&lt;/ph&gt;</ept> enforces the restriction outside the table function.</mrk><mrk mid="3" mtype="seg"> Therefore, a restricted table function can still fetch extra columns and can ignore part or all of the restriction set by the call to <bpt id="6" ctype="x-i">&lt;i&gt;</bpt>initScan()<ept id="6">&lt;/i&gt;</ept>.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> calls <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>initScan()<ept id="2">&lt;/i&gt;</ept> before calling any other method on the <bpt id="3" ctype="x-i">&lt;i&gt;</bpt>ResultSet<ept id="3">&lt;/i&gt;</ept>.</mrk><mrk mid="1" mtype="seg"> The call to <bpt id="4" ctype="x-i">&lt;i&gt;</bpt>initScan()<ept id="4">&lt;/i&gt;</ept> merely passes hints, which the restricted table function can exploit in order to perform better.</mrk><mrk mid="2" mtype="seg"> <bpt id="5" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="5">&lt;/ph&gt;</ept> enforces the restriction outside the table function.</mrk><mrk mid="3" mtype="seg"> Therefore, a restricted table function can still fetch extra columns and can ignore part or all of the restriction set by the call to <bpt id="6" ctype="x-i">&lt;i&gt;</bpt>initScan()<ept id="6">&lt;/i&gt;</ept>.</mrk></target>
</trans-unit>
<trans-unit id="tu37">
<source xml:lang="en">Affected Operations</source>
<seg-source><mrk mid="0" mtype="seg">Affected Operations</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Affected Operations</mrk></target>
</trans-unit>
<trans-unit id="tu38">
<source xml:lang="en">Compared to ordinary table functions, a restricted table function can perform better in queries involving the following comparisons of its columns to constants:</source>
<seg-source><mrk mid="0" mtype="seg">Compared to ordinary table functions, a restricted table function can perform better in queries involving the following comparisons of its columns to constants:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Compared to ordinary table functions, a restricted table function can perform better in queries involving the following comparisons of its columns to constants:</mrk></target>
</trans-unit>
<trans-unit id="tu39">
<source xml:lang="en">&lt; &lt;= = != &lt;&gt; &gt; &gt;= IS NULL IS NOT NULL</source>
<seg-source><mrk mid="0" mtype="seg">&lt; &lt;= = != &lt;&gt; &gt; &gt;= IS NULL IS NOT NULL</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">&lt; &lt;= = != &lt;&gt; &gt; &gt;= IS NULL IS NOT NULL</mrk></target>
</trans-unit>
<trans-unit id="tu40">
<source xml:lang="en">In addition, performance gains can be realized for queries involving the following operators on the columns of the restricted table function:</source>
<seg-source><mrk mid="0" mtype="seg">In addition, performance gains can be realized for queries involving the following operators on the columns of the restricted table function:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">In addition, performance gains can be realized for queries involving the following operators on the columns of the restricted table function:</mrk></target>
</trans-unit>
<trans-unit id="tu41">
<source xml:lang="en">LIKE BETWEEN</source>
<seg-source><mrk mid="0" mtype="seg">LIKE BETWEEN</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">LIKE BETWEEN</mrk></target>
</trans-unit>
<trans-unit id="tu42">
<source xml:lang="en">However, this feature does not boost performance either for the IN operator, or in situations where <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> transforms OR lists into IN lists. See "Or transformations" in <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#pub/cittuning"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> for more information.</source>
<seg-source><mrk mid="0" mtype="seg">However, this feature does not boost performance either for the IN operator, or in situations where <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> transforms OR lists into IN lists.</mrk><mrk mid="1" mtype="seg"> See "Or transformations" in <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#pub/cittuning"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> for more information.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">However, this feature does not boost performance either for the IN operator, or in situations where <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> transforms OR lists into IN lists.</mrk><mrk mid="1" mtype="seg"> See "Or transformations" in <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#pub/cittuning"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> for more information.</mrk></target>
</trans-unit>
</body>
</file>
</xliff>
