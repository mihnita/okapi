<?xml version="1.0" encoding="UTF-8"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:okp="okapi-framework:xliff-extensions" xmlns:its="http://www.w3.org/2005/11/its" xmlns:itsxlf="http://www.w3.org/ns/its-xliff/" its:version="2.0">
<file original="crefsqlj22771.dita" source-language="en" target-language="fr" datatype="xml" okp:inputEncoding="utf-8" okp:configId="/home/jimh/Code/Okapi/okapi/okapi/filters/xmlstream/target/classes/net/sf/okapi/filters/xmlstream/dita.yml">
<header><tool tool-id="okapi" tool-name="okapi-tests" tool-version="M29" tool-company="okapi"></tool></header>
<body>
<trans-unit id="tu1">
<source xml:lang="en">Interaction with the dependency system</source>
<seg-source><mrk mid="0" mtype="seg">Interaction with the dependency system</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Interaction with the dependency system</mrk></target>
</trans-unit>
<trans-unit id="tu2">
<source xml:lang="en">Dependencies</source>
<seg-source><mrk mid="0" mtype="seg">Dependencies</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Dependencies</mrk></target>
</trans-unit>
<trans-unit id="tu3">
<source xml:lang="en">internal tracking of</source>
<seg-source><mrk mid="0" mtype="seg">internal tracking of</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">internal tracking of</mrk></target>
</trans-unit>
<trans-unit id="tu4">
<source xml:lang="en">Prepared statements</source>
<seg-source><mrk mid="0" mtype="seg">Prepared statements</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Prepared statements</mrk></target>
</trans-unit>
<trans-unit id="tu5">
<source xml:lang="en">tracking of dependencies</source>
<seg-source><mrk mid="0" mtype="seg">tracking of dependencies</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">tracking of dependencies</mrk></target>
</trans-unit>
<trans-unit id="tu6">
<source xml:lang="en"><bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> internally tracks the dependencies of prepared statements, which are SQL statements that are precompiled before being executed. Typically they are prepared (precompiled) once and executed multiple times.</source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> internally tracks the dependencies of prepared statements, which are SQL statements that are precompiled before being executed.</mrk><mrk mid="1" mtype="seg"> Typically they are prepared (precompiled) once and executed multiple times.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> internally tracks the dependencies of prepared statements, which are SQL statements that are precompiled before being executed.</mrk><mrk mid="1" mtype="seg"> Typically they are prepared (precompiled) once and executed multiple times.</mrk></target>
</trans-unit>
<trans-unit id="tu7">
<source xml:lang="en">Prepared statements depend on the dictionary objects and statements they reference. (Dictionary objects include tables, columns, constraints, indexes, views, and triggers.) Removing or modifying the dictionary objects or statements on which they depend invalidates them internally, which means that <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> will automatically try to recompile the statement when you execute it. If the statement fails to recompile, the execution request fails. However, if you take some action to restore the broken dependency (such as restoring the missing table), you can execute the same prepared statement, because <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> will recompile it automatically at the next execute request.</source>
<seg-source><mrk mid="0" mtype="seg">Prepared statements depend on the dictionary objects and statements they reference.</mrk><mrk mid="1" mtype="seg"> (Dictionary objects include tables, columns, constraints, indexes, views, and triggers.) Removing or modifying the dictionary objects or statements on which they depend invalidates them internally, which means that <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> will automatically try to recompile the statement when you execute it.</mrk><mrk mid="2" mtype="seg"> If the statement fails to recompile, the execution request fails.</mrk><mrk mid="3" mtype="seg"> However, if you take some action to restore the broken dependency (such as restoring the missing table), you can execute the same prepared statement, because <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> will recompile it automatically at the next execute request.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Prepared statements depend on the dictionary objects and statements they reference.</mrk><mrk mid="1" mtype="seg"> (Dictionary objects include tables, columns, constraints, indexes, views, and triggers.) Removing or modifying the dictionary objects or statements on which they depend invalidates them internally, which means that <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> will automatically try to recompile the statement when you execute it.</mrk><mrk mid="2" mtype="seg"> If the statement fails to recompile, the execution request fails.</mrk><mrk mid="3" mtype="seg"> However, if you take some action to restore the broken dependency (such as restoring the missing table), you can execute the same prepared statement, because <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> will recompile it automatically at the next execute request.</mrk></target>
</trans-unit>
<trans-unit id="tu8">
<source xml:lang="en">Statements depend on one another-an UPDATE WHERE CURRENT statement depends on the statement it references. Removing the statement on which it depends invalidates the UPDATE WHERE CURRENT statement.</source>
<seg-source><mrk mid="0" mtype="seg">Statements depend on one another-an UPDATE WHERE CURRENT statement depends on the statement it references.</mrk><mrk mid="1" mtype="seg"> Removing the statement on which it depends invalidates the UPDATE WHERE CURRENT statement.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Statements depend on one another-an UPDATE WHERE CURRENT statement depends on the statement it references.</mrk><mrk mid="1" mtype="seg"> Removing the statement on which it depends invalidates the UPDATE WHERE CURRENT statement.</mrk></target>
</trans-unit>
<trans-unit id="tu9">
<source xml:lang="en">In addition, prepared statements prevent execution of certain DDL statements if there are open results sets on them.</source>
<seg-source><mrk mid="0" mtype="seg">In addition, prepared statements prevent execution of certain DDL statements if there are open results sets on them.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">In addition, prepared statements prevent execution of certain DDL statements if there are open results sets on them.</mrk></target>
</trans-unit>
<trans-unit id="tu10">
<source xml:lang="en">Manual pages for each statement detail what actions would invalidate that statement, if prepared.</source>
<seg-source><mrk mid="0" mtype="seg">Manual pages for each statement detail what actions would invalidate that statement, if prepared.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Manual pages for each statement detail what actions would invalidate that statement, if prepared.</mrk></target>
</trans-unit>
<trans-unit id="tu11">
<source xml:lang="en">Here is an example using the <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> tool ij:</source>
<seg-source><mrk mid="0" mtype="seg">Here is an example using the <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> tool ij:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Here is an example using the <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> tool ij:</mrk></target>
</trans-unit>
<trans-unit id="tu12">
<source xml:lang="en">ij&gt; <bpt id="1" ctype="x-b">&lt;b&gt;</bpt>CREATE TABLE mytable (mycol INT);<ept id="1">&lt;/b&gt;</ept> 0 rows inserted/updated/deleted ij&gt; <bpt id="2" ctype="x-b">&lt;b&gt;</bpt>INSERT INTO mytable VALUES (1), (2), (3);<ept id="2">&lt;/b&gt;</ept> 3 rows inserted/updated/deleted -- this example uses the ij command prepare, -- which prepares a statement ij&gt; <bpt id="3" ctype="x-b">&lt;b&gt;</bpt>prepare p1 AS 'INSERT INTO MyTable VALUES (4)';<ept id="3">&lt;/b&gt;</ept> -- p1 depends on mytable; ij&gt; <bpt id="4" ctype="x-b">&lt;b&gt;</bpt>execute p1;<ept id="4">&lt;/b&gt;</ept> 1 row inserted/updated/deleted -- <bpt id="5" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="5">&lt;/ph&gt;</ept> executes it without recompiling ij&gt; <bpt id="6" ctype="x-b">&lt;b&gt;</bpt>CREATE INDEX i1 ON mytable(mycol);<ept id="6">&lt;/b&gt;</ept> 0 rows inserted/updated/deleted -- p1 is temporarily invalidated because of new index ij&gt; <bpt id="7" ctype="x-b">&lt;b&gt;</bpt>execute p1;<ept id="7">&lt;/b&gt;</ept> 1 row inserted/updated/deleted -- <bpt id="8" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="8">&lt;/ph&gt;</ept> automatically recompiles p1 and executes it ij&gt; <bpt id="9" ctype="x-b">&lt;b&gt;</bpt>DROP TABLE mytable;<ept id="9">&lt;/b&gt;</ept> 0 rows inserted/updated/deleted -- <bpt id="10" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="10">&lt;/ph&gt;</ept> permits you to drop table -- because result set of p1 is closed -- however, the statement p1 is temporarily invalidated ij&gt; <bpt id="11" ctype="x-b">&lt;b&gt;</bpt>CREATE TABLE mytable (mycol INT);<ept id="11">&lt;/b&gt;</ept> 0 rows inserted/updated/deleted ij&gt; <bpt id="12" ctype="x-b">&lt;b&gt;</bpt>INSERT INTO mytable VALUES (1), (2), (3);<ept id="12">&lt;/b&gt;</ept> 3 rows inserted/updated/deleted ij&gt; <bpt id="13" ctype="x-b">&lt;b&gt;</bpt>execute p1;<ept id="13">&lt;/b&gt;</ept> 1 row inserted/updated/deleted -- Because p1 is invalid, <bpt id="14" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="14">&lt;/ph&gt;</ept> tries to recompile it -- before executing. -- It is successful and executes. ij&gt; <bpt id="15" ctype="x-b">&lt;b&gt;</bpt>DROP TABLE mytable;<ept id="15">&lt;/b&gt;</ept> 0 rows inserted/updated/deleted -- statement p1 is now invalid, -- and this time the attempt to recompile it -- upon execution will fail ij&gt; <bpt id="16" ctype="x-b">&lt;b&gt;</bpt>execute p1;<ept id="16">&lt;/b&gt;</ept> ERROR 42X05: Table/View 'MYTABLE' does not exist.</source>
<seg-source><mrk mid="0" mtype="seg">ij&gt; <bpt id="1" ctype="x-b">&lt;b&gt;</bpt>CREATE TABLE mytable (mycol INT);<ept id="1">&lt;/b&gt;</ept> 0 rows inserted/updated/deleted ij&gt; <bpt id="2" ctype="x-b">&lt;b&gt;</bpt>INSERT INTO mytable VALUES (1), (2), (3);<ept id="2">&lt;/b&gt;</ept> 3 rows inserted/updated/deleted -- this example uses the ij command prepare, -- which prepares a statement ij&gt; <bpt id="3" ctype="x-b">&lt;b&gt;</bpt>prepare p1 AS 'INSERT INTO MyTable VALUES (4)';<ept id="3">&lt;/b&gt;</ept> -- p1 depends on mytable; ij&gt; <bpt id="4" ctype="x-b">&lt;b&gt;</bpt>execute p1;<ept id="4">&lt;/b&gt;</ept> 1 row inserted/updated/deleted -- <bpt id="5" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="5">&lt;/ph&gt;</ept> executes it without recompiling ij&gt; <bpt id="6" ctype="x-b">&lt;b&gt;</bpt>CREATE INDEX i1 ON mytable(mycol);<ept id="6">&lt;/b&gt;</ept> 0 rows inserted/updated/deleted -- p1 is temporarily invalidated because of new index ij&gt; <bpt id="7" ctype="x-b">&lt;b&gt;</bpt>execute p1;<ept id="7">&lt;/b&gt;</ept> 1 row inserted/updated/deleted -- <bpt id="8" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="8">&lt;/ph&gt;</ept> automatically recompiles p1 and executes it ij&gt; <bpt id="9" ctype="x-b">&lt;b&gt;</bpt>DROP TABLE mytable;<ept id="9">&lt;/b&gt;</ept> 0 rows inserted/updated/deleted -- <bpt id="10" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="10">&lt;/ph&gt;</ept> permits you to drop table -- because result set of p1 is closed -- however, the statement p1 is temporarily invalidated ij&gt; <bpt id="11" ctype="x-b">&lt;b&gt;</bpt>CREATE TABLE mytable (mycol INT);<ept id="11">&lt;/b&gt;</ept> 0 rows inserted/updated/deleted ij&gt; <bpt id="12" ctype="x-b">&lt;b&gt;</bpt>INSERT INTO mytable VALUES (1), (2), (3);<ept id="12">&lt;/b&gt;</ept> 3 rows inserted/updated/deleted ij&gt; <bpt id="13" ctype="x-b">&lt;b&gt;</bpt>execute p1;<ept id="13">&lt;/b&gt;</ept> 1 row inserted/updated/deleted -- Because p1 is invalid, <bpt id="14" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="14">&lt;/ph&gt;</ept> tries to recompile it -- before executing.</mrk><mrk mid="1" mtype="seg"> -- It is successful and executes.</mrk><mrk mid="2" mtype="seg"> ij&gt; <bpt id="15" ctype="x-b">&lt;b&gt;</bpt>DROP TABLE mytable;<ept id="15">&lt;/b&gt;</ept> 0 rows inserted/updated/deleted -- statement p1 is now invalid, -- and this time the attempt to recompile it -- upon execution will fail ij&gt; <bpt id="16" ctype="x-b">&lt;b&gt;</bpt>execute p1;<ept id="16">&lt;/b&gt;</ept> ERROR 42X05: Table/View 'MYTABLE' does not exist.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">ij&gt; <bpt id="1" ctype="x-b">&lt;b&gt;</bpt>CREATE TABLE mytable (mycol INT);<ept id="1">&lt;/b&gt;</ept> 0 rows inserted/updated/deleted ij&gt; <bpt id="2" ctype="x-b">&lt;b&gt;</bpt>INSERT INTO mytable VALUES (1), (2), (3);<ept id="2">&lt;/b&gt;</ept> 3 rows inserted/updated/deleted -- this example uses the ij command prepare, -- which prepares a statement ij&gt; <bpt id="3" ctype="x-b">&lt;b&gt;</bpt>prepare p1 AS 'INSERT INTO MyTable VALUES (4)';<ept id="3">&lt;/b&gt;</ept> -- p1 depends on mytable; ij&gt; <bpt id="4" ctype="x-b">&lt;b&gt;</bpt>execute p1;<ept id="4">&lt;/b&gt;</ept> 1 row inserted/updated/deleted -- <bpt id="5" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="5">&lt;/ph&gt;</ept> executes it without recompiling ij&gt; <bpt id="6" ctype="x-b">&lt;b&gt;</bpt>CREATE INDEX i1 ON mytable(mycol);<ept id="6">&lt;/b&gt;</ept> 0 rows inserted/updated/deleted -- p1 is temporarily invalidated because of new index ij&gt; <bpt id="7" ctype="x-b">&lt;b&gt;</bpt>execute p1;<ept id="7">&lt;/b&gt;</ept> 1 row inserted/updated/deleted -- <bpt id="8" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="8">&lt;/ph&gt;</ept> automatically recompiles p1 and executes it ij&gt; <bpt id="9" ctype="x-b">&lt;b&gt;</bpt>DROP TABLE mytable;<ept id="9">&lt;/b&gt;</ept> 0 rows inserted/updated/deleted -- <bpt id="10" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="10">&lt;/ph&gt;</ept> permits you to drop table -- because result set of p1 is closed -- however, the statement p1 is temporarily invalidated ij&gt; <bpt id="11" ctype="x-b">&lt;b&gt;</bpt>CREATE TABLE mytable (mycol INT);<ept id="11">&lt;/b&gt;</ept> 0 rows inserted/updated/deleted ij&gt; <bpt id="12" ctype="x-b">&lt;b&gt;</bpt>INSERT INTO mytable VALUES (1), (2), (3);<ept id="12">&lt;/b&gt;</ept> 3 rows inserted/updated/deleted ij&gt; <bpt id="13" ctype="x-b">&lt;b&gt;</bpt>execute p1;<ept id="13">&lt;/b&gt;</ept> 1 row inserted/updated/deleted -- Because p1 is invalid, <bpt id="14" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="14">&lt;/ph&gt;</ept> tries to recompile it -- before executing.</mrk><mrk mid="1" mtype="seg"> -- It is successful and executes.</mrk><mrk mid="2" mtype="seg"> ij&gt; <bpt id="15" ctype="x-b">&lt;b&gt;</bpt>DROP TABLE mytable;<ept id="15">&lt;/b&gt;</ept> 0 rows inserted/updated/deleted -- statement p1 is now invalid, -- and this time the attempt to recompile it -- upon execution will fail ij&gt; <bpt id="16" ctype="x-b">&lt;b&gt;</bpt>execute p1;<ept id="16">&lt;/b&gt;</ept> ERROR 42X05: Table/View 'MYTABLE' does not exist.</mrk></target>
</trans-unit>
</body>
</file>
</xliff>
