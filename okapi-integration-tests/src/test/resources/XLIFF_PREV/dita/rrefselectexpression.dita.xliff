<?xml version="1.0" encoding="UTF-8"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:okp="okapi-framework:xliff-extensions" xmlns:its="http://www.w3.org/2005/11/its" xmlns:itsxlf="http://www.w3.org/ns/its-xliff/" its:version="2.0">
<file original="rrefselectexpression.dita" source-language="en" target-language="fr" datatype="xml" okp:inputEncoding="utf-8" okp:configId="/home/jimh/Code/Okapi/okapi/okapi/filters/xmlstream/target/classes/net/sf/okapi/filters/xmlstream/dita.yml">
<header><tool tool-id="okapi" tool-name="okapi-tests" tool-version="M29" tool-company="okapi"></tool></header>
<body>
<trans-unit id="tu1">
<source xml:lang="en">selectExpression</source>
<seg-source><mrk mid="0" mtype="seg">selectExpression</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">selectExpression</mrk></target>
</trans-unit>
<trans-unit id="tu2">
<source xml:lang="en">Select expression</source>
<seg-source><mrk mid="0" mtype="seg">Select expression</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Select expression</mrk></target>
</trans-unit>
<trans-unit id="tu3">
<source xml:lang="en">DISTINCT clause</source>
<seg-source><mrk mid="0" mtype="seg">DISTINCT clause</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">DISTINCT clause</mrk></target>
</trans-unit>
<trans-unit id="tu4">
<source xml:lang="en">part of selectExpression</source>
<seg-source><mrk mid="0" mtype="seg">part of selectExpression</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">part of selectExpression</mrk></target>
</trans-unit>
<trans-unit id="tu5">
<source xml:lang="en">* as wildcard in SQL SELECT</source>
<seg-source><mrk mid="0" mtype="seg">* as wildcard in SQL SELECT</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">* as wildcard in SQL SELECT</mrk></target>
</trans-unit>
<trans-unit id="tu6">
<source xml:lang="en">A <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>selectExpression<ept id="1">&lt;/i&gt;</ept> is the basic SELECT-FROM-WHERE construct used to build a table value based on filtering and projecting values from other tables.</source>
<seg-source><mrk mid="0" mtype="seg">A <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>selectExpression<ept id="1">&lt;/i&gt;</ept> is the basic SELECT-FROM-WHERE construct used to build a table value based on filtering and projecting values from other tables.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">A <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>selectExpression<ept id="1">&lt;/i&gt;</ept> is the basic SELECT-FROM-WHERE construct used to build a table value based on filtering and projecting values from other tables.</mrk></target>
</trans-unit>
<trans-unit id="tu7">
<source xml:lang="en">Syntax</source>
<seg-source><mrk mid="0" mtype="seg">Syntax</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Syntax</mrk></target>
</trans-unit>
<trans-unit id="tu8">
<source xml:lang="en"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>SELECT [ DISTINCT | ALL ] <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>selectItem<ept id="2">&lt;/i&gt;</ept> [ , <bpt id="3" ctype="x-i">&lt;i&gt;</bpt>selectItem <ept id="3">&lt;/i&gt;</ept>]* <bpt id="4" ctype="x-i">&lt;i&gt;</bpt><bpt id="5" ctype="x-xref">&lt;xref href="rrefsqlj21583.dita#rrefsqlj21583"&gt;</bpt>FROM clause<ept id="5">&lt;/xref&gt;</ept><ept id="4">&lt;/i&gt;</ept> [ <bpt id="6" ctype="x-i">&lt;i&gt;</bpt><bpt id="7" ctype="x-xref">&lt;xref href="rrefsqlj33602.dita#rrefsqlj33602"&gt;</bpt>WHERE clause<ept id="7">&lt;/xref&gt;</ept> <ept id="6">&lt;/i&gt;</ept>] [ <bpt id="8" ctype="x-i">&lt;i&gt;</bpt><bpt id="9" ctype="x-xref">&lt;xref href="rrefsqlj32654.dita#rrefsqlj32654"&gt;</bpt>GROUP BY clause<ept id="9">&lt;/xref&gt;</ept><ept id="8">&lt;/i&gt;</ept> ] [ <bpt id="10" ctype="x-i">&lt;i&gt;</bpt><bpt id="11" ctype="x-xref">&lt;xref href="rrefsqlj14854.dita#rrefsqlj14854"&gt;</bpt>HAVING clause<ept id="11">&lt;/xref&gt;</ept><ept id="10">&lt;/i&gt;</ept> ] [ <bpt id="12" ctype="x-i">&lt;i&gt;</bpt><bpt id="13" ctype="x-xref">&lt;xref href="rrefsqljwindow.dita#rrefsqljwindow"&gt;</bpt>WINDOW clause<ept id="13">&lt;/xref&gt;</ept><ept id="12">&lt;/i&gt;</ept> ] [ <bpt id="14" ctype="x-i">&lt;i&gt;</bpt><bpt id="15" ctype="x-xref">&lt;xref href="rrefsqlj13658.dita#rrefsqlj13658"&gt;</bpt>ORDER BY clause<ept id="15">&lt;/xref&gt;</ept><ept id="14">&lt;/i&gt;</ept> ] [ <bpt id="16" ctype="x-i">&lt;i&gt;</bpt><bpt id="17" ctype="x-xref">&lt;xref href="rrefsqljoffsetfetch.dita#rrefsqljoffsetfetch"&gt;</bpt>result offset clause<ept id="17">&lt;/xref&gt;</ept><ept id="16">&lt;/i&gt;</ept> ] [ <bpt id="18" ctype="x-i">&lt;i&gt;</bpt><bpt id="19" ctype="x-xref">&lt;xref href="rrefsqljoffsetfetch.dita#rrefsqljoffsetfetch"&gt;</bpt>fetch first clause<ept id="19">&lt;/xref&gt;</ept><ept id="18">&lt;/i&gt;</ept> ] <ept id="1">&lt;/b&gt;</ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>SELECT [ DISTINCT | ALL ] <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>selectItem<ept id="2">&lt;/i&gt;</ept> [ , <bpt id="3" ctype="x-i">&lt;i&gt;</bpt>selectItem <ept id="3">&lt;/i&gt;</ept>]* <bpt id="4" ctype="x-i">&lt;i&gt;</bpt><bpt id="5" ctype="x-xref">&lt;xref href="rrefsqlj21583.dita#rrefsqlj21583"&gt;</bpt>FROM clause<ept id="5">&lt;/xref&gt;</ept><ept id="4">&lt;/i&gt;</ept> [ <bpt id="6" ctype="x-i">&lt;i&gt;</bpt><bpt id="7" ctype="x-xref">&lt;xref href="rrefsqlj33602.dita#rrefsqlj33602"&gt;</bpt>WHERE clause<ept id="7">&lt;/xref&gt;</ept> <ept id="6">&lt;/i&gt;</ept>] [ <bpt id="8" ctype="x-i">&lt;i&gt;</bpt><bpt id="9" ctype="x-xref">&lt;xref href="rrefsqlj32654.dita#rrefsqlj32654"&gt;</bpt>GROUP BY clause<ept id="9">&lt;/xref&gt;</ept><ept id="8">&lt;/i&gt;</ept> ] [ <bpt id="10" ctype="x-i">&lt;i&gt;</bpt><bpt id="11" ctype="x-xref">&lt;xref href="rrefsqlj14854.dita#rrefsqlj14854"&gt;</bpt>HAVING clause<ept id="11">&lt;/xref&gt;</ept><ept id="10">&lt;/i&gt;</ept> ] [ <bpt id="12" ctype="x-i">&lt;i&gt;</bpt><bpt id="13" ctype="x-xref">&lt;xref href="rrefsqljwindow.dita#rrefsqljwindow"&gt;</bpt>WINDOW clause<ept id="13">&lt;/xref&gt;</ept><ept id="12">&lt;/i&gt;</ept> ] [ <bpt id="14" ctype="x-i">&lt;i&gt;</bpt><bpt id="15" ctype="x-xref">&lt;xref href="rrefsqlj13658.dita#rrefsqlj13658"&gt;</bpt>ORDER BY clause<ept id="15">&lt;/xref&gt;</ept><ept id="14">&lt;/i&gt;</ept> ] [ <bpt id="16" ctype="x-i">&lt;i&gt;</bpt><bpt id="17" ctype="x-xref">&lt;xref href="rrefsqljoffsetfetch.dita#rrefsqljoffsetfetch"&gt;</bpt>result offset clause<ept id="17">&lt;/xref&gt;</ept><ept id="16">&lt;/i&gt;</ept> ] [ <bpt id="18" ctype="x-i">&lt;i&gt;</bpt><bpt id="19" ctype="x-xref">&lt;xref href="rrefsqljoffsetfetch.dita#rrefsqljoffsetfetch"&gt;</bpt>fetch first clause<ept id="19">&lt;/xref&gt;</ept><ept id="18">&lt;/i&gt;</ept> ] <ept id="1">&lt;/b&gt;</ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>SELECT [ DISTINCT | ALL ] <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>selectItem<ept id="2">&lt;/i&gt;</ept> [ , <bpt id="3" ctype="x-i">&lt;i&gt;</bpt>selectItem <ept id="3">&lt;/i&gt;</ept>]* <bpt id="4" ctype="x-i">&lt;i&gt;</bpt><bpt id="5" ctype="x-xref">&lt;xref href="rrefsqlj21583.dita#rrefsqlj21583"&gt;</bpt>FROM clause<ept id="5">&lt;/xref&gt;</ept><ept id="4">&lt;/i&gt;</ept> [ <bpt id="6" ctype="x-i">&lt;i&gt;</bpt><bpt id="7" ctype="x-xref">&lt;xref href="rrefsqlj33602.dita#rrefsqlj33602"&gt;</bpt>WHERE clause<ept id="7">&lt;/xref&gt;</ept> <ept id="6">&lt;/i&gt;</ept>] [ <bpt id="8" ctype="x-i">&lt;i&gt;</bpt><bpt id="9" ctype="x-xref">&lt;xref href="rrefsqlj32654.dita#rrefsqlj32654"&gt;</bpt>GROUP BY clause<ept id="9">&lt;/xref&gt;</ept><ept id="8">&lt;/i&gt;</ept> ] [ <bpt id="10" ctype="x-i">&lt;i&gt;</bpt><bpt id="11" ctype="x-xref">&lt;xref href="rrefsqlj14854.dita#rrefsqlj14854"&gt;</bpt>HAVING clause<ept id="11">&lt;/xref&gt;</ept><ept id="10">&lt;/i&gt;</ept> ] [ <bpt id="12" ctype="x-i">&lt;i&gt;</bpt><bpt id="13" ctype="x-xref">&lt;xref href="rrefsqljwindow.dita#rrefsqljwindow"&gt;</bpt>WINDOW clause<ept id="13">&lt;/xref&gt;</ept><ept id="12">&lt;/i&gt;</ept> ] [ <bpt id="14" ctype="x-i">&lt;i&gt;</bpt><bpt id="15" ctype="x-xref">&lt;xref href="rrefsqlj13658.dita#rrefsqlj13658"&gt;</bpt>ORDER BY clause<ept id="15">&lt;/xref&gt;</ept><ept id="14">&lt;/i&gt;</ept> ] [ <bpt id="16" ctype="x-i">&lt;i&gt;</bpt><bpt id="17" ctype="x-xref">&lt;xref href="rrefsqljoffsetfetch.dita#rrefsqljoffsetfetch"&gt;</bpt>result offset clause<ept id="17">&lt;/xref&gt;</ept><ept id="16">&lt;/i&gt;</ept> ] [ <bpt id="18" ctype="x-i">&lt;i&gt;</bpt><bpt id="19" ctype="x-xref">&lt;xref href="rrefsqljoffsetfetch.dita#rrefsqljoffsetfetch"&gt;</bpt>fetch first clause<ept id="19">&lt;/xref&gt;</ept><ept id="18">&lt;/i&gt;</ept> ] <ept id="1">&lt;/b&gt;</ept></mrk></target>
</trans-unit>
<trans-unit id="tu9">
<source xml:lang="en"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>selectItem:<ept id="1">&lt;/b&gt;</ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>selectItem:<ept id="1">&lt;/b&gt;</ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>selectItem:<ept id="1">&lt;/b&gt;</ept></mrk></target>
</trans-unit>
<trans-unit id="tu10">
<source xml:lang="en"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>{ * | { <bpt id="2" ctype="x-i">&lt;i&gt;</bpt><bpt id="3" ctype="x-xref">&lt;xref href="rreftablename.dita#rreftablename"&gt;</bpt>tableName<ept id="3">&lt;/xref&gt;</ept><ept id="2">&lt;/i&gt;</ept> | <bpt id="4" ctype="x-i">&lt;i&gt;</bpt><bpt id="5" ctype="x-xref">&lt;xref
href="rrefcorrelationname.dita#rrefcorrelationname"&gt;</bpt>correlationName<ept id="5">&lt;/xref&gt;</ept><ept id="4">&lt;/i&gt;</ept> } .* | <bpt id="6" ctype="x-i">&lt;i&gt;</bpt>expression<ept id="6">&lt;/i&gt;</ept> [AS <bpt id="7" ctype="x-i">&lt;i&gt;</bpt><bpt id="8" ctype="x-xref">&lt;xref href="rrefsimplecolumnname.dita#rrefsimplecolumnname"&gt;</bpt>simpleColumnName<ept id="8">&lt;/xref&gt;</ept> <ept id="7">&lt;/i&gt;</ept>] }<ept id="1">&lt;/b&gt;</ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>{ * | { <bpt id="2" ctype="x-i">&lt;i&gt;</bpt><bpt id="3" ctype="x-xref">&lt;xref href="rreftablename.dita#rreftablename"&gt;</bpt>tableName<ept id="3">&lt;/xref&gt;</ept><ept id="2">&lt;/i&gt;</ept> | <bpt id="4" ctype="x-i">&lt;i&gt;</bpt><bpt id="5" ctype="x-xref">&lt;xref
href="rrefcorrelationname.dita#rrefcorrelationname"&gt;</bpt>correlationName<ept id="5">&lt;/xref&gt;</ept><ept id="4">&lt;/i&gt;</ept> } .* | <bpt id="6" ctype="x-i">&lt;i&gt;</bpt>expression<ept id="6">&lt;/i&gt;</ept> [AS <bpt id="7" ctype="x-i">&lt;i&gt;</bpt><bpt id="8" ctype="x-xref">&lt;xref href="rrefsimplecolumnname.dita#rrefsimplecolumnname"&gt;</bpt>simpleColumnName<ept id="8">&lt;/xref&gt;</ept> <ept id="7">&lt;/i&gt;</ept>] }<ept id="1">&lt;/b&gt;</ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>{ * | { <bpt id="2" ctype="x-i">&lt;i&gt;</bpt><bpt id="3" ctype="x-xref">&lt;xref href="rreftablename.dita#rreftablename"&gt;</bpt>tableName<ept id="3">&lt;/xref&gt;</ept><ept id="2">&lt;/i&gt;</ept> | <bpt id="4" ctype="x-i">&lt;i&gt;</bpt><bpt id="5" ctype="x-xref">&lt;xref
href="rrefcorrelationname.dita#rrefcorrelationname"&gt;</bpt>correlationName<ept id="5">&lt;/xref&gt;</ept><ept id="4">&lt;/i&gt;</ept> } .* | <bpt id="6" ctype="x-i">&lt;i&gt;</bpt>expression<ept id="6">&lt;/i&gt;</ept> [AS <bpt id="7" ctype="x-i">&lt;i&gt;</bpt><bpt id="8" ctype="x-xref">&lt;xref href="rrefsimplecolumnname.dita#rrefsimplecolumnname"&gt;</bpt>simpleColumnName<ept id="8">&lt;/xref&gt;</ept> <ept id="7">&lt;/i&gt;</ept>] }<ept id="1">&lt;/b&gt;</ept></mrk></target>
</trans-unit>
<trans-unit id="tu11">
<source xml:lang="en">The SELECT clause contains a list of expressions and an optional quantifier that is applied to the results of the <bpt id="1" ctype="x-xref">&lt;xref href="rrefsqlj21583.dita#rrefsqlj21583"&gt;</bpt>FROM clause<ept id="1">&lt;/xref&gt;</ept> and the <bpt id="2" ctype="x-xref">&lt;xref href="rrefsqlj33602.dita#rrefsqlj33602"&gt;</bpt>WHERE clause<ept id="2">&lt;/xref&gt;</ept>. If DISTINCT is specified, only one copy of any row value is included in the result. Nulls are considered duplicates of one another for the purposes of DISTINCT. If no quantifier, or ALL, is specified, no rows are removed from the result in applying the SELECT clause (ALL is the default).</source>
<seg-source><mrk mid="0" mtype="seg">The SELECT clause contains a list of expressions and an optional quantifier that is applied to the results of the <bpt id="1" ctype="x-xref">&lt;xref href="rrefsqlj21583.dita#rrefsqlj21583"&gt;</bpt>FROM clause<ept id="1">&lt;/xref&gt;</ept> and the <bpt id="2" ctype="x-xref">&lt;xref href="rrefsqlj33602.dita#rrefsqlj33602"&gt;</bpt>WHERE clause<ept id="2">&lt;/xref&gt;</ept>.</mrk><mrk mid="1" mtype="seg"> If DISTINCT is specified, only one copy of any row value is included in the result.</mrk><mrk mid="2" mtype="seg"> Nulls are considered duplicates of one another for the purposes of DISTINCT.</mrk><mrk mid="3" mtype="seg"> If no quantifier, or ALL, is specified, no rows are removed from the result in applying the SELECT clause (ALL is the default).</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">The SELECT clause contains a list of expressions and an optional quantifier that is applied to the results of the <bpt id="1" ctype="x-xref">&lt;xref href="rrefsqlj21583.dita#rrefsqlj21583"&gt;</bpt>FROM clause<ept id="1">&lt;/xref&gt;</ept> and the <bpt id="2" ctype="x-xref">&lt;xref href="rrefsqlj33602.dita#rrefsqlj33602"&gt;</bpt>WHERE clause<ept id="2">&lt;/xref&gt;</ept>.</mrk><mrk mid="1" mtype="seg"> If DISTINCT is specified, only one copy of any row value is included in the result.</mrk><mrk mid="2" mtype="seg"> Nulls are considered duplicates of one another for the purposes of DISTINCT.</mrk><mrk mid="3" mtype="seg"> If no quantifier, or ALL, is specified, no rows are removed from the result in applying the SELECT clause (ALL is the default).</mrk></target>
</trans-unit>
<trans-unit id="tu12">
<source xml:lang="en">A <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>selectItem<ept id="1">&lt;/i&gt;</ept> projects one or more result column values for a table result being constructed in a <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>selectExpression<ept id="2">&lt;/i&gt;</ept>.</source>
<seg-source><mrk mid="0" mtype="seg">A <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>selectItem<ept id="1">&lt;/i&gt;</ept> projects one or more result column values for a table result being constructed in a <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>selectExpression<ept id="2">&lt;/i&gt;</ept>.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">A <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>selectItem<ept id="1">&lt;/i&gt;</ept> projects one or more result column values for a table result being constructed in a <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>selectExpression<ept id="2">&lt;/i&gt;</ept>.</mrk></target>
</trans-unit>
<trans-unit id="tu13">
<source xml:lang="en">For queries that do not select a specific column from the tables involved in the <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>selectExpression<ept id="1">&lt;/i&gt;</ept> (for example, queries that use <bpt id="2" ctype="x-codeph">&lt;codeph&gt;</bpt>COUNT(*)<ept id="2">&lt;/codeph&gt;</ept>), the user must have at least one column-level SELECT privilege or table-level SELECT privilege. See <bpt id="3" ctype="x-xref">&lt;xref href="rrefsqljgrant.dita#rrefsqljgrant"&gt;</bpt><ept id="3">&lt;/xref&gt;</ept> for more information.</source>
<seg-source><mrk mid="0" mtype="seg">For queries that do not select a specific column from the tables involved in the <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>selectExpression<ept id="1">&lt;/i&gt;</ept> (for example, queries that use <bpt id="2" ctype="x-codeph">&lt;codeph&gt;</bpt>COUNT(*)<ept id="2">&lt;/codeph&gt;</ept>), the user must have at least one column-level SELECT privilege or table-level SELECT privilege.</mrk><mrk mid="1" mtype="seg"> See <bpt id="3" ctype="x-xref">&lt;xref href="rrefsqljgrant.dita#rrefsqljgrant"&gt;</bpt><ept id="3">&lt;/xref&gt;</ept> for more information.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">For queries that do not select a specific column from the tables involved in the <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>selectExpression<ept id="1">&lt;/i&gt;</ept> (for example, queries that use <bpt id="2" ctype="x-codeph">&lt;codeph&gt;</bpt>COUNT(*)<ept id="2">&lt;/codeph&gt;</ept>), the user must have at least one column-level SELECT privilege or table-level SELECT privilege.</mrk><mrk mid="1" mtype="seg"> See <bpt id="3" ctype="x-xref">&lt;xref href="rrefsqljgrant.dita#rrefsqljgrant"&gt;</bpt><ept id="3">&lt;/xref&gt;</ept> for more information.</mrk></target>
</trans-unit>
<trans-unit id="tu14">
<source xml:lang="en">The result of the <bpt id="1" ctype="x-xref">&lt;xref href="rrefsqlj21583.dita#rrefsqlj21583"&gt;</bpt>FROM clause<ept id="1">&lt;/xref&gt;</ept> is the cross product of the FROM items. The <bpt id="2" ctype="x-xref">&lt;xref href="rrefsqlj33602.dita#rrefsqlj33602"&gt;</bpt>WHERE clause<ept id="2">&lt;/xref&gt;</ept> can further qualify this result.</source>
<seg-source><mrk mid="0" mtype="seg">The result of the <bpt id="1" ctype="x-xref">&lt;xref href="rrefsqlj21583.dita#rrefsqlj21583"&gt;</bpt>FROM clause<ept id="1">&lt;/xref&gt;</ept> is the cross product of the FROM items.</mrk><mrk mid="1" mtype="seg"> The <bpt id="2" ctype="x-xref">&lt;xref href="rrefsqlj33602.dita#rrefsqlj33602"&gt;</bpt>WHERE clause<ept id="2">&lt;/xref&gt;</ept> can further qualify this result.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">The result of the <bpt id="1" ctype="x-xref">&lt;xref href="rrefsqlj21583.dita#rrefsqlj21583"&gt;</bpt>FROM clause<ept id="1">&lt;/xref&gt;</ept> is the cross product of the FROM items.</mrk><mrk mid="1" mtype="seg"> The <bpt id="2" ctype="x-xref">&lt;xref href="rrefsqlj33602.dita#rrefsqlj33602"&gt;</bpt>WHERE clause<ept id="2">&lt;/xref&gt;</ept> can further qualify this result.</mrk></target>
</trans-unit>
<trans-unit id="tu15">
<source xml:lang="en">The WHERE clause causes rows to be filtered from the result based on a boolean expression. Only rows for which the expression evaluates to TRUE are returned in the result.</source>
<seg-source><mrk mid="0" mtype="seg">The WHERE clause causes rows to be filtered from the result based on a boolean expression.</mrk><mrk mid="1" mtype="seg"> Only rows for which the expression evaluates to TRUE are returned in the result.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">The WHERE clause causes rows to be filtered from the result based on a boolean expression.</mrk><mrk mid="1" mtype="seg"> Only rows for which the expression evaluates to TRUE are returned in the result.</mrk></target>
</trans-unit>
<trans-unit id="tu16">
<source xml:lang="en">The GROUP BY clause groups rows in the result into subsets that have matching values for one or more columns. GROUP BY clauses are typically used with aggregates.</source>
<seg-source><mrk mid="0" mtype="seg">The GROUP BY clause groups rows in the result into subsets that have matching values for one or more columns.</mrk><mrk mid="1" mtype="seg"> GROUP BY clauses are typically used with aggregates.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">The GROUP BY clause groups rows in the result into subsets that have matching values for one or more columns.</mrk><mrk mid="1" mtype="seg"> GROUP BY clauses are typically used with aggregates.</mrk></target>
</trans-unit>
<trans-unit id="tu17">
<source xml:lang="en">If there is a GROUP BY clause, the SELECT clause must contain <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>only<ept id="1">&lt;/i&gt;</ept> aggregates or grouping columns. If you want to include a non-grouped column in the SELECT clause, include the column in an aggregate expression. For example:</source>
<seg-source><mrk mid="0" mtype="seg">If there is a GROUP BY clause, the SELECT clause must contain <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>only<ept id="1">&lt;/i&gt;</ept> aggregates or grouping columns.</mrk><mrk mid="1" mtype="seg"> If you want to include a non-grouped column in the SELECT clause, include the column in an aggregate expression.</mrk><mrk mid="2" mtype="seg"> For example:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">If there is a GROUP BY clause, the SELECT clause must contain <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>only<ept id="1">&lt;/i&gt;</ept> aggregates or grouping columns.</mrk><mrk mid="1" mtype="seg"> If you want to include a non-grouped column in the SELECT clause, include the column in an aggregate expression.</mrk><mrk mid="2" mtype="seg"> For example:</mrk></target>
</trans-unit>
<trans-unit id="tu18">
<source xml:lang="en"><it id="1" ctype="x-b" pos="open">&lt;b&gt;</it>-- List head count of each department, -- the department number (WORKDEPT), and the average departmental salary -- (SALARY) for all departments in the EMPLOYEE table. -- Arrange the result table in ascending order by average departmental -- salary. SELECT COUNT(*),WORK_DEPT,AVG(SALARY) FROM EMPLOYEE GROUP BY WORK_DEPT ORDER BY 3<it id="1" ctype="x-b" pos="close">&lt;/b&gt;</it></source>
<seg-source><mrk mid="0" mtype="seg"><it id="1" ctype="x-b" pos="open">&lt;b&gt;</it>-- List head count of each department, -- the department number (WORKDEPT), and the average departmental salary -- (SALARY) for all departments in the EMPLOYEE table.</mrk><mrk mid="1" mtype="seg"> -- Arrange the result table in ascending order by average departmental -- salary.</mrk><mrk mid="2" mtype="seg"> SELECT COUNT(*),WORK_DEPT,AVG(SALARY) FROM EMPLOYEE GROUP BY WORK_DEPT ORDER BY 3<it id="1" ctype="x-b" pos="close">&lt;/b&gt;</it></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><it id="1" ctype="x-b" pos="open">&lt;b&gt;</it>-- List head count of each department, -- the department number (WORKDEPT), and the average departmental salary -- (SALARY) for all departments in the EMPLOYEE table.</mrk><mrk mid="1" mtype="seg"> -- Arrange the result table in ascending order by average departmental -- salary.</mrk><mrk mid="2" mtype="seg"> SELECT COUNT(*),WORK_DEPT,AVG(SALARY) FROM EMPLOYEE GROUP BY WORK_DEPT ORDER BY 3<it id="1" ctype="x-b" pos="close">&lt;/b&gt;</it></mrk></target>
</trans-unit>
<trans-unit id="tu19">
<source xml:lang="en">If there is no GROUP BY clause, but a <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>selectItem<ept id="1">&lt;/i&gt;</ept> contains an aggregate not in a subquery, the query is implicitly grouped. The entire table is the single group.</source>
<seg-source><mrk mid="0" mtype="seg">If there is no GROUP BY clause, but a <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>selectItem<ept id="1">&lt;/i&gt;</ept> contains an aggregate not in a subquery, the query is implicitly grouped.</mrk><mrk mid="1" mtype="seg"> The entire table is the single group.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">If there is no GROUP BY clause, but a <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>selectItem<ept id="1">&lt;/i&gt;</ept> contains an aggregate not in a subquery, the query is implicitly grouped.</mrk><mrk mid="1" mtype="seg"> The entire table is the single group.</mrk></target>
</trans-unit>
<trans-unit id="tu20">
<source xml:lang="en">The HAVING clause restricts a grouped table, specifying a search condition (much like a WHERE clause) that can refer only to grouping columns or aggregates from the current scope. The HAVING clause is applied to each group of the grouped table. If the HAVING clause evaluates to TRUE, the row is retained for further processing. If the HAVING clause evaluates to FALSE or NULL, the row is discarded. If there is a HAVING clause but no GROUP BY, the table is implicitly grouped into one group for the entire table.</source>
<seg-source><mrk mid="0" mtype="seg">The HAVING clause restricts a grouped table, specifying a search condition (much like a WHERE clause) that can refer only to grouping columns or aggregates from the current scope.</mrk><mrk mid="1" mtype="seg"> The HAVING clause is applied to each group of the grouped table.</mrk><mrk mid="2" mtype="seg"> If the HAVING clause evaluates to TRUE, the row is retained for further processing.</mrk><mrk mid="3" mtype="seg"> If the HAVING clause evaluates to FALSE or NULL, the row is discarded.</mrk><mrk mid="4" mtype="seg"> If there is a HAVING clause but no GROUP BY, the table is implicitly grouped into one group for the entire table.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">The HAVING clause restricts a grouped table, specifying a search condition (much like a WHERE clause) that can refer only to grouping columns or aggregates from the current scope.</mrk><mrk mid="1" mtype="seg"> The HAVING clause is applied to each group of the grouped table.</mrk><mrk mid="2" mtype="seg"> If the HAVING clause evaluates to TRUE, the row is retained for further processing.</mrk><mrk mid="3" mtype="seg"> If the HAVING clause evaluates to FALSE or NULL, the row is discarded.</mrk><mrk mid="4" mtype="seg"> If there is a HAVING clause but no GROUP BY, the table is implicitly grouped into one group for the entire table.</mrk></target>
</trans-unit>
<trans-unit id="tu21">
<source xml:lang="en">The WINDOW clause allows you to refer to a window by name when you use a <bpt id="1" ctype="x-xref">&lt;xref href="rreffuncrownumber.dita#rreffuncrownumber"&gt;</bpt><ept id="1">&lt;/xref&gt;</ept> in a <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>selectExpression<ept id="2">&lt;/i&gt;</ept>.</source>
<seg-source><mrk mid="0" mtype="seg">The WINDOW clause allows you to refer to a window by name when you use a <bpt id="1" ctype="x-xref">&lt;xref href="rreffuncrownumber.dita#rreffuncrownumber"&gt;</bpt><ept id="1">&lt;/xref&gt;</ept> in a <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>selectExpression<ept id="2">&lt;/i&gt;</ept>.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">The WINDOW clause allows you to refer to a window by name when you use a <bpt id="1" ctype="x-xref">&lt;xref href="rreffuncrownumber.dita#rreffuncrownumber"&gt;</bpt><ept id="1">&lt;/xref&gt;</ept> in a <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>selectExpression<ept id="2">&lt;/i&gt;</ept>.</mrk></target>
</trans-unit>
<trans-unit id="tu22">
<source xml:lang="en">The ORDER BY clause allows you to specify the order in which rows appear in the result set. In subqueries, the ORDER BY clause is meaningless unless it is accompanied by one or both of the result offset and fetch first clauses or in conjunction with the ROW_NUMBER function.</source>
<seg-source><mrk mid="0" mtype="seg">The ORDER BY clause allows you to specify the order in which rows appear in the result set.</mrk><mrk mid="1" mtype="seg"> In subqueries, the ORDER BY clause is meaningless unless it is accompanied by one or both of the result offset and fetch first clauses or in conjunction with the ROW_NUMBER function.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">The ORDER BY clause allows you to specify the order in which rows appear in the result set.</mrk><mrk mid="1" mtype="seg"> In subqueries, the ORDER BY clause is meaningless unless it is accompanied by one or both of the result offset and fetch first clauses or in conjunction with the ROW_NUMBER function.</mrk></target>
</trans-unit>
<trans-unit id="tu23">
<source xml:lang="en">The result offset clause provides a way to skip the N first rows in a result set before starting to return any rows. The fetch first clause, which can be combined with the result offset clause if desired, limits the number of rows returned in the result set.</source>
<seg-source><mrk mid="0" mtype="seg">The result offset clause provides a way to skip the N first rows in a result set before starting to return any rows.</mrk><mrk mid="1" mtype="seg"> The fetch first clause, which can be combined with the result offset clause if desired, limits the number of rows returned in the result set.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">The result offset clause provides a way to skip the N first rows in a result set before starting to return any rows.</mrk><mrk mid="1" mtype="seg"> The fetch first clause, which can be combined with the result offset clause if desired, limits the number of rows returned in the result set.</mrk></target>
</trans-unit>
<trans-unit id="tu24">
<source xml:lang="en"><bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> processes a <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>selectExpression<ept id="2">&lt;/i&gt;</ept> in the following order:</source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> processes a <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>selectExpression<ept id="2">&lt;/i&gt;</ept> in the following order:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> processes a <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>selectExpression<ept id="2">&lt;/i&gt;</ept> in the following order:</mrk></target>
</trans-unit>
<trans-unit id="tu25">
<source xml:lang="en">FROM clause</source>
<seg-source><mrk mid="0" mtype="seg">FROM clause</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">FROM clause</mrk></target>
</trans-unit>
<trans-unit id="tu26">
<source xml:lang="en">WHERE clause</source>
<seg-source><mrk mid="0" mtype="seg">WHERE clause</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">WHERE clause</mrk></target>
</trans-unit>
<trans-unit id="tu27">
<source xml:lang="en">GROUP BY (or implicit GROUP BY)</source>
<seg-source><mrk mid="0" mtype="seg">GROUP BY (or implicit GROUP BY)</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">GROUP BY (or implicit GROUP BY)</mrk></target>
</trans-unit>
<trans-unit id="tu28">
<source xml:lang="en">HAVING clause</source>
<seg-source><mrk mid="0" mtype="seg">HAVING clause</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">HAVING clause</mrk></target>
</trans-unit>
<trans-unit id="tu29">
<source xml:lang="en">WINDOW clause</source>
<seg-source><mrk mid="0" mtype="seg">WINDOW clause</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">WINDOW clause</mrk></target>
</trans-unit>
<trans-unit id="tu30">
<source xml:lang="en">ORDER BY clause</source>
<seg-source><mrk mid="0" mtype="seg">ORDER BY clause</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">ORDER BY clause</mrk></target>
</trans-unit>
<trans-unit id="tu31">
<source xml:lang="en">Result offset clause</source>
<seg-source><mrk mid="0" mtype="seg">Result offset clause</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Result offset clause</mrk></target>
</trans-unit>
<trans-unit id="tu32">
<source xml:lang="en">Fetch first clause</source>
<seg-source><mrk mid="0" mtype="seg">Fetch first clause</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Fetch first clause</mrk></target>
</trans-unit>
<trans-unit id="tu33">
<source xml:lang="en">SELECT clause</source>
<seg-source><mrk mid="0" mtype="seg">SELECT clause</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">SELECT clause</mrk></target>
</trans-unit>
<trans-unit id="tu34">
<source xml:lang="en">The result of a <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>selectExpression<ept id="1">&lt;/i&gt;</ept> is always a table.</source>
<seg-source><mrk mid="0" mtype="seg">The result of a <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>selectExpression<ept id="1">&lt;/i&gt;</ept> is always a table.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">The result of a <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>selectExpression<ept id="1">&lt;/i&gt;</ept> is always a table.</mrk></target>
</trans-unit>
<trans-unit id="tu35">
<source xml:lang="en">When a query does not have a FROM clause (when you are constructing a value, not getting data out of a table), you use a VALUES expression, not a <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>selectExpression<ept id="1">&lt;/i&gt;</ept>. For example:</source>
<seg-source><mrk mid="0" mtype="seg">When a query does not have a FROM clause (when you are constructing a value, not getting data out of a table), you use a VALUES expression, not a <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>selectExpression<ept id="1">&lt;/i&gt;</ept>.</mrk><mrk mid="1" mtype="seg"> For example:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">When a query does not have a FROM clause (when you are constructing a value, not getting data out of a table), you use a VALUES expression, not a <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>selectExpression<ept id="1">&lt;/i&gt;</ept>.</mrk><mrk mid="1" mtype="seg"> For example:</mrk></target>
</trans-unit>
<trans-unit id="tu36">
<source xml:lang="en"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>VALUES CURRENT_TIMESTAMP<ept id="1">&lt;/b&gt;</ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>VALUES CURRENT_TIMESTAMP<ept id="1">&lt;/b&gt;</ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>VALUES CURRENT_TIMESTAMP<ept id="1">&lt;/b&gt;</ept></mrk></target>
</trans-unit>
<trans-unit id="tu37">
<source xml:lang="en">See <bpt id="1" ctype="x-xref">&lt;xref
href="rrefsqlj11277.dita#rrefsqlj11277"&gt;</bpt><ept id="1">&lt;/xref&gt;</ept>.</source>
<seg-source><mrk mid="0" mtype="seg">See <bpt id="1" ctype="x-xref">&lt;xref
href="rrefsqlj11277.dita#rrefsqlj11277"&gt;</bpt><ept id="1">&lt;/xref&gt;</ept>.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">See <bpt id="1" ctype="x-xref">&lt;xref
href="rrefsqlj11277.dita#rrefsqlj11277"&gt;</bpt><ept id="1">&lt;/xref&gt;</ept>.</mrk></target>
</trans-unit>
<trans-unit id="tu38">
<source xml:lang="en">The * wildcard</source>
<seg-source><mrk mid="0" mtype="seg">The * wildcard</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">The * wildcard</mrk></target>
</trans-unit>
<trans-unit id="tu39">
<source xml:lang="en">* expands to all columns in the tables in the associated FROM clause.</source>
<seg-source><mrk mid="0" mtype="seg">* expands to all columns in the tables in the associated FROM clause.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">* expands to all columns in the tables in the associated FROM clause.</mrk></target>
</trans-unit>
<trans-unit id="tu40">
<source xml:lang="en"><bpt id="1" ctype="x-i">&lt;i&gt;</bpt><bpt id="2" ctype="x-xref">&lt;xref href="rreftablename.dita#rreftablename"&gt;</bpt>table-Name<ept id="2">&lt;/xref&gt;</ept>.*<ept id="1">&lt;/i&gt;</ept> and <bpt id="3" ctype="x-i">&lt;i&gt;</bpt><bpt id="4" ctype="x-xref">&lt;xref
href="rrefcorrelationname.dita#rrefcorrelationname"&gt;</bpt>correlation-Name<ept id="4">&lt;/xref&gt;</ept>.*<ept id="3">&lt;/i&gt;</ept> expand to all columns in the identified table. That table must be listed in the associated FROM clause.</source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-i">&lt;i&gt;</bpt><bpt id="2" ctype="x-xref">&lt;xref href="rreftablename.dita#rreftablename"&gt;</bpt>table-Name<ept id="2">&lt;/xref&gt;</ept>.*<ept id="1">&lt;/i&gt;</ept> and <bpt id="3" ctype="x-i">&lt;i&gt;</bpt><bpt id="4" ctype="x-xref">&lt;xref
href="rrefcorrelationname.dita#rrefcorrelationname"&gt;</bpt>correlation-Name<ept id="4">&lt;/xref&gt;</ept>.*<ept id="3">&lt;/i&gt;</ept> expand to all columns in the identified table.</mrk><mrk mid="1" mtype="seg"> That table must be listed in the associated FROM clause.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-i">&lt;i&gt;</bpt><bpt id="2" ctype="x-xref">&lt;xref href="rreftablename.dita#rreftablename"&gt;</bpt>table-Name<ept id="2">&lt;/xref&gt;</ept>.*<ept id="1">&lt;/i&gt;</ept> and <bpt id="3" ctype="x-i">&lt;i&gt;</bpt><bpt id="4" ctype="x-xref">&lt;xref
href="rrefcorrelationname.dita#rrefcorrelationname"&gt;</bpt>correlation-Name<ept id="4">&lt;/xref&gt;</ept>.*<ept id="3">&lt;/i&gt;</ept> expand to all columns in the identified table.</mrk><mrk mid="1" mtype="seg"> That table must be listed in the associated FROM clause.</mrk></target>
</trans-unit>
<trans-unit id="tu41">
<source xml:lang="en">Naming columns</source>
<seg-source><mrk mid="0" mtype="seg">Naming columns</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Naming columns</mrk></target>
</trans-unit>
<trans-unit id="tu42">
<source xml:lang="en">You can name a <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>selectItem<ept id="1">&lt;/i&gt;</ept> column using the AS clause. If a column of a <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>selectItem<ept id="2">&lt;/i&gt;</ept> is not a simple <bpt id="3" ctype="x-i">&lt;i&gt;</bpt>columnReference<ept id="3">&lt;/i&gt;</ept> expression or named with an AS clause, it is given a generated unique name.</source>
<seg-source><mrk mid="0" mtype="seg">You can name a <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>selectItem<ept id="1">&lt;/i&gt;</ept> column using the AS clause.</mrk><mrk mid="1" mtype="seg"> If a column of a <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>selectItem<ept id="2">&lt;/i&gt;</ept> is not a simple <bpt id="3" ctype="x-i">&lt;i&gt;</bpt>columnReference<ept id="3">&lt;/i&gt;</ept> expression or named with an AS clause, it is given a generated unique name.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">You can name a <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>selectItem<ept id="1">&lt;/i&gt;</ept> column using the AS clause.</mrk><mrk mid="1" mtype="seg"> If a column of a <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>selectItem<ept id="2">&lt;/i&gt;</ept> is not a simple <bpt id="3" ctype="x-i">&lt;i&gt;</bpt>columnReference<ept id="3">&lt;/i&gt;</ept> expression or named with an AS clause, it is given a generated unique name.</mrk></target>
</trans-unit>
<trans-unit id="tu43">
<source xml:lang="en">These column names are useful in several cases:</source>
<seg-source><mrk mid="0" mtype="seg">These column names are useful in several cases:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">These column names are useful in several cases:</mrk></target>
</trans-unit>
<trans-unit id="tu44">
<source xml:lang="en">They are made available on the JDBC <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>ResultSetMetaData<ept id="1">&lt;/i&gt;</ept>.</source>
<seg-source><mrk mid="0" mtype="seg">They are made available on the JDBC <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>ResultSetMetaData<ept id="1">&lt;/i&gt;</ept>.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">They are made available on the JDBC <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>ResultSetMetaData<ept id="1">&lt;/i&gt;</ept>.</mrk></target>
</trans-unit>
<trans-unit id="tu45">
<source xml:lang="en">They are used as the names of the columns in the resulting table when the <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>selectExpression<ept id="1">&lt;/i&gt;</ept> is used as a table subquery in a FROM clause.</source>
<seg-source><mrk mid="0" mtype="seg">They are used as the names of the columns in the resulting table when the <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>selectExpression<ept id="1">&lt;/i&gt;</ept> is used as a table subquery in a FROM clause.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">They are used as the names of the columns in the resulting table when the <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>selectExpression<ept id="1">&lt;/i&gt;</ept> is used as a table subquery in a FROM clause.</mrk></target>
</trans-unit>
<trans-unit id="tu46">
<source xml:lang="en">They are used in the ORDER BY clause as the column names available for sorting.</source>
<seg-source><mrk mid="0" mtype="seg">They are used in the ORDER BY clause as the column names available for sorting.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">They are used in the ORDER BY clause as the column names available for sorting.</mrk></target>
</trans-unit>
<trans-unit id="tu47">
<source xml:lang="en">Examples</source>
<seg-source><mrk mid="0" mtype="seg">Examples</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Examples</mrk></target>
</trans-unit>
<trans-unit id="tu48">
<source xml:lang="en"><it id="1" ctype="x-b" pos="open">&lt;b&gt;</it><bpt id="2" ctype="x-ph">&lt;ph&gt;</bpt>-- This example shows SELECT-FROM-WHERE -- with an ORDER BY clause -- and correlation-Names for the tables.<ept id="2">&lt;/ph&gt;</ept> SELECT CONSTRAINTNAME, COLUMNNAME FROM SYS.SYSTABLES t, SYS.SYSCOLUMNS col, SYS.SYSCONSTRAINTS cons, SYS.SYSCHECKS checks WHERE t.TABLENAME = 'FLIGHTS' AND t.TABLEID = col.REFERENCEID AND t.TABLEID = cons.TABLEID AND cons.CONSTRAINTID = checks.CONSTRAINTID ORDER BY CONSTRAINTNAME <bpt id="3" ctype="x-ph">&lt;ph&gt;</bpt>-- This example shows the use of the DISTINCT clause<ept id="3">&lt;/ph&gt;</ept> SELECT DISTINCT ACTNO FROM EMP_ACT <bpt id="4" ctype="x-ph">&lt;ph&gt;</bpt>-- This example shows how to rename an expression -- Using the EMPLOYEE table, list the department number (WORKDEPT) and -- maximum departmental salary (SALARY) renamed as BOSS -- for all departments whose maximum salary is less than the -- average salary in all other departments.<ept id="4">&lt;/ph&gt;</ept> SELECT WORKDEPT AS DPT, MAX(SALARY) AS BOSS FROM EMPLOYEE EMP_COR GROUP BY WORKDEPT HAVING MAX(SALARY) &lt; (SELECT AVG(SALARY) FROM EMPLOYEE WHERE NOT WORKDEPT = EMP_COR.WORKDEPT) ORDER BY BOSS<it id="1" ctype="x-b" pos="close">&lt;/b&gt;</it></source>
<seg-source><mrk mid="0" mtype="seg"><it id="1" ctype="x-b" pos="open">&lt;b&gt;</it><bpt id="2" ctype="x-ph">&lt;ph&gt;</bpt>-- This example shows SELECT-FROM-WHERE -- with an ORDER BY clause -- and correlation-Names for the tables.<ept id="2">&lt;/ph&gt;</ept></mrk><mrk mid="1" mtype="seg"> SELECT CONSTRAINTNAME, COLUMNNAME FROM SYS.SYSTABLES t, SYS.SYSCOLUMNS col, SYS.SYSCONSTRAINTS cons, SYS.SYSCHECKS checks WHERE t.TABLENAME = 'FLIGHTS' AND t.TABLEID = col.REFERENCEID AND t.TABLEID = cons.TABLEID AND cons.CONSTRAINTID = checks.CONSTRAINTID ORDER BY CONSTRAINTNAME <bpt id="3" ctype="x-ph">&lt;ph&gt;</bpt>-- This example shows the use of the DISTINCT clause<ept id="3">&lt;/ph&gt;</ept> SELECT DISTINCT ACTNO FROM EMP_ACT <bpt id="4" ctype="x-ph">&lt;ph&gt;</bpt>-- This example shows how to rename an expression -- Using the EMPLOYEE table, list the department number (WORKDEPT) and -- maximum departmental salary (SALARY) renamed as BOSS -- for all departments whose maximum salary is less than the -- average salary in all other departments.<ept id="4">&lt;/ph&gt;</ept></mrk><mrk mid="2" mtype="seg"> SELECT WORKDEPT AS DPT, MAX(SALARY) AS BOSS FROM EMPLOYEE EMP_COR GROUP BY WORKDEPT HAVING MAX(SALARY) &lt; (SELECT AVG(SALARY) FROM EMPLOYEE WHERE NOT WORKDEPT = EMP_COR.WORKDEPT) ORDER BY BOSS<it id="1" ctype="x-b" pos="close">&lt;/b&gt;</it></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><it id="1" ctype="x-b" pos="open">&lt;b&gt;</it><bpt id="2" ctype="x-ph">&lt;ph&gt;</bpt>-- This example shows SELECT-FROM-WHERE -- with an ORDER BY clause -- and correlation-Names for the tables.<ept id="2">&lt;/ph&gt;</ept></mrk><mrk mid="1" mtype="seg"> SELECT CONSTRAINTNAME, COLUMNNAME FROM SYS.SYSTABLES t, SYS.SYSCOLUMNS col, SYS.SYSCONSTRAINTS cons, SYS.SYSCHECKS checks WHERE t.TABLENAME = 'FLIGHTS' AND t.TABLEID = col.REFERENCEID AND t.TABLEID = cons.TABLEID AND cons.CONSTRAINTID = checks.CONSTRAINTID ORDER BY CONSTRAINTNAME <bpt id="3" ctype="x-ph">&lt;ph&gt;</bpt>-- This example shows the use of the DISTINCT clause<ept id="3">&lt;/ph&gt;</ept> SELECT DISTINCT ACTNO FROM EMP_ACT <bpt id="4" ctype="x-ph">&lt;ph&gt;</bpt>-- This example shows how to rename an expression -- Using the EMPLOYEE table, list the department number (WORKDEPT) and -- maximum departmental salary (SALARY) renamed as BOSS -- for all departments whose maximum salary is less than the -- average salary in all other departments.<ept id="4">&lt;/ph&gt;</ept></mrk><mrk mid="2" mtype="seg"> SELECT WORKDEPT AS DPT, MAX(SALARY) AS BOSS FROM EMPLOYEE EMP_COR GROUP BY WORKDEPT HAVING MAX(SALARY) &lt; (SELECT AVG(SALARY) FROM EMPLOYEE WHERE NOT WORKDEPT = EMP_COR.WORKDEPT) ORDER BY BOSS<it id="1" ctype="x-b" pos="close">&lt;/b&gt;</it></mrk></target>
</trans-unit>
</body>
</file>
</xliff>
