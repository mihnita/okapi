<?xml version="1.0" encoding="UTF-8"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:okp="okapi-framework:xliff-extensions" xmlns:its="http://www.w3.org/2005/11/its" xmlns:itsxlf="http://www.w3.org/ns/its-xliff/" its:version="2.0">
<file original="rrefsqlj21571.dita" source-language="en" target-language="fr" datatype="xml" okp:inputEncoding="utf-8" okp:configId="/home/jimh/Code/Okapi/okapi/okapi/filters/xmlstream/target/classes/net/sf/okapi/filters/xmlstream/dita.yml">
<header><tool tool-id="okapi" tool-name="okapi-tests" tool-version="M29" tool-company="okapi"></tool></header>
<body>
<trans-unit id="tu1">
<source xml:lang="en">query</source>
<seg-source><mrk mid="0" mtype="seg">query</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">query</mrk></target>
</trans-unit>
<trans-unit id="tu2">
<source xml:lang="en">UNION</source>
<seg-source><mrk mid="0" mtype="seg">UNION</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">UNION</mrk></target>
</trans-unit>
<trans-unit id="tu3">
<source xml:lang="en">UNION ALL</source>
<seg-source><mrk mid="0" mtype="seg">UNION ALL</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">UNION ALL</mrk></target>
</trans-unit>
<trans-unit id="tu4">
<source xml:lang="en">A query creates a virtual table based on existing tables or constants built into tables.</source>
<seg-source><mrk mid="0" mtype="seg">A query creates a virtual table based on existing tables or constants built into tables.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">A query creates a virtual table based on existing tables or constants built into tables.</mrk></target>
</trans-unit>
<trans-unit id="tu5">
<source xml:lang="en">Syntax</source>
<seg-source><mrk mid="0" mtype="seg">Syntax</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Syntax</mrk></target>
</trans-unit>
<trans-unit id="tu6">
<source xml:lang="en"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>{ ( <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>query<ept id="2">&lt;/i&gt;</ept> [ <bpt id="3" ctype="x-i">&lt;i&gt;</bpt><bpt id="4" ctype="x-xref">&lt;xref href="rrefsqlj13658.dita#rrefsqlj13658"&gt;</bpt>ORDER BY clause<ept id="4">&lt;/xref&gt;</ept><ept id="3">&lt;/i&gt;</ept> ] [ <bpt id="5" ctype="x-i">&lt;i&gt;</bpt><bpt id="6" ctype="x-xref">&lt;xref href="rrefsqljoffsetfetch.dita#rrefsqljoffsetfetch"&gt;</bpt>result offset clause<ept id="6">&lt;/xref&gt;</ept><ept id="5">&lt;/i&gt;</ept> ] [ <bpt id="7" ctype="x-i">&lt;i&gt;</bpt><bpt id="8" ctype="x-xref">&lt;xref href="rrefsqljoffsetfetch.dita#rrefsqljoffsetfetch"&gt;</bpt>fetch first clause<ept id="8">&lt;/xref&gt;</ept><ept id="7">&lt;/i&gt;</ept> ] ) | <bpt id="9" ctype="x-i">&lt;i&gt;</bpt>query<ept id="9">&lt;/i&gt;</ept> INTERSECT [ ALL | DISTINCT ] <bpt id="10" ctype="x-i">&lt;i&gt;</bpt>query<ept id="10">&lt;/i&gt;</ept> | <bpt id="11" ctype="x-i">&lt;i&gt;</bpt>query<ept id="11">&lt;/i&gt;</ept> EXCEPT [ ALL | DISTINCT ] <bpt id="12" ctype="x-i">&lt;i&gt;</bpt>query<ept id="12">&lt;/i&gt;</ept> | <bpt id="13" ctype="x-i">&lt;i&gt;</bpt>query<ept id="13">&lt;/i&gt;</ept> UNION [ ALL | DISTINCT ] <bpt id="14" ctype="x-i">&lt;i&gt;</bpt>query<ept id="14">&lt;/i&gt;</ept> | <bpt id="15" ctype="x-i">&lt;i&gt;</bpt><bpt id="16" ctype="x-xref">&lt;xref href="rrefselectexpression.dita#rrefselectexpression"&gt;</bpt>selectExpression<ept id="16">&lt;/xref&gt;</ept><ept id="15">&lt;/i&gt;</ept> | <bpt id="17" ctype="x-i">&lt;i&gt;</bpt><bpt id="18" ctype="x-xref">&lt;xref
href="rrefsqlj11277.dita#rrefsqlj11277"&gt;</bpt>VALUES expression<ept id="18">&lt;/xref&gt;</ept><ept id="17">&lt;/i&gt;</ept> }<ept id="1">&lt;/b&gt;</ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>{ ( <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>query<ept id="2">&lt;/i&gt;</ept> [ <bpt id="3" ctype="x-i">&lt;i&gt;</bpt><bpt id="4" ctype="x-xref">&lt;xref href="rrefsqlj13658.dita#rrefsqlj13658"&gt;</bpt>ORDER BY clause<ept id="4">&lt;/xref&gt;</ept><ept id="3">&lt;/i&gt;</ept> ] [ <bpt id="5" ctype="x-i">&lt;i&gt;</bpt><bpt id="6" ctype="x-xref">&lt;xref href="rrefsqljoffsetfetch.dita#rrefsqljoffsetfetch"&gt;</bpt>result offset clause<ept id="6">&lt;/xref&gt;</ept><ept id="5">&lt;/i&gt;</ept> ] [ <bpt id="7" ctype="x-i">&lt;i&gt;</bpt><bpt id="8" ctype="x-xref">&lt;xref href="rrefsqljoffsetfetch.dita#rrefsqljoffsetfetch"&gt;</bpt>fetch first clause<ept id="8">&lt;/xref&gt;</ept><ept id="7">&lt;/i&gt;</ept> ] ) | <bpt id="9" ctype="x-i">&lt;i&gt;</bpt>query<ept id="9">&lt;/i&gt;</ept> INTERSECT [ ALL | DISTINCT ] <bpt id="10" ctype="x-i">&lt;i&gt;</bpt>query<ept id="10">&lt;/i&gt;</ept> | <bpt id="11" ctype="x-i">&lt;i&gt;</bpt>query<ept id="11">&lt;/i&gt;</ept> EXCEPT [ ALL | DISTINCT ] <bpt id="12" ctype="x-i">&lt;i&gt;</bpt>query<ept id="12">&lt;/i&gt;</ept> | <bpt id="13" ctype="x-i">&lt;i&gt;</bpt>query<ept id="13">&lt;/i&gt;</ept> UNION [ ALL | DISTINCT ] <bpt id="14" ctype="x-i">&lt;i&gt;</bpt>query<ept id="14">&lt;/i&gt;</ept> | <bpt id="15" ctype="x-i">&lt;i&gt;</bpt><bpt id="16" ctype="x-xref">&lt;xref href="rrefselectexpression.dita#rrefselectexpression"&gt;</bpt>selectExpression<ept id="16">&lt;/xref&gt;</ept><ept id="15">&lt;/i&gt;</ept> | <bpt id="17" ctype="x-i">&lt;i&gt;</bpt><bpt id="18" ctype="x-xref">&lt;xref
href="rrefsqlj11277.dita#rrefsqlj11277"&gt;</bpt>VALUES expression<ept id="18">&lt;/xref&gt;</ept><ept id="17">&lt;/i&gt;</ept> }<ept id="1">&lt;/b&gt;</ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>{ ( <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>query<ept id="2">&lt;/i&gt;</ept> [ <bpt id="3" ctype="x-i">&lt;i&gt;</bpt><bpt id="4" ctype="x-xref">&lt;xref href="rrefsqlj13658.dita#rrefsqlj13658"&gt;</bpt>ORDER BY clause<ept id="4">&lt;/xref&gt;</ept><ept id="3">&lt;/i&gt;</ept> ] [ <bpt id="5" ctype="x-i">&lt;i&gt;</bpt><bpt id="6" ctype="x-xref">&lt;xref href="rrefsqljoffsetfetch.dita#rrefsqljoffsetfetch"&gt;</bpt>result offset clause<ept id="6">&lt;/xref&gt;</ept><ept id="5">&lt;/i&gt;</ept> ] [ <bpt id="7" ctype="x-i">&lt;i&gt;</bpt><bpt id="8" ctype="x-xref">&lt;xref href="rrefsqljoffsetfetch.dita#rrefsqljoffsetfetch"&gt;</bpt>fetch first clause<ept id="8">&lt;/xref&gt;</ept><ept id="7">&lt;/i&gt;</ept> ] ) | <bpt id="9" ctype="x-i">&lt;i&gt;</bpt>query<ept id="9">&lt;/i&gt;</ept> INTERSECT [ ALL | DISTINCT ] <bpt id="10" ctype="x-i">&lt;i&gt;</bpt>query<ept id="10">&lt;/i&gt;</ept> | <bpt id="11" ctype="x-i">&lt;i&gt;</bpt>query<ept id="11">&lt;/i&gt;</ept> EXCEPT [ ALL | DISTINCT ] <bpt id="12" ctype="x-i">&lt;i&gt;</bpt>query<ept id="12">&lt;/i&gt;</ept> | <bpt id="13" ctype="x-i">&lt;i&gt;</bpt>query<ept id="13">&lt;/i&gt;</ept> UNION [ ALL | DISTINCT ] <bpt id="14" ctype="x-i">&lt;i&gt;</bpt>query<ept id="14">&lt;/i&gt;</ept> | <bpt id="15" ctype="x-i">&lt;i&gt;</bpt><bpt id="16" ctype="x-xref">&lt;xref href="rrefselectexpression.dita#rrefselectexpression"&gt;</bpt>selectExpression<ept id="16">&lt;/xref&gt;</ept><ept id="15">&lt;/i&gt;</ept> | <bpt id="17" ctype="x-i">&lt;i&gt;</bpt><bpt id="18" ctype="x-xref">&lt;xref
href="rrefsqlj11277.dita#rrefsqlj11277"&gt;</bpt>VALUES expression<ept id="18">&lt;/xref&gt;</ept><ept id="17">&lt;/i&gt;</ept> }<ept id="1">&lt;/b&gt;</ept></mrk></target>
</trans-unit>
<trans-unit id="tu7">
<source xml:lang="en">You can arbitrarily put parentheses around queries, or use the parentheses to control the order of evaluation of the INTERSECT, EXCEPT, or UNION operations. These operations are evaluated from left to right when no parentheses are present, with the exception of INTERSECT operations, which would be evaluated before any UNION or EXCEPT operations.</source>
<seg-source><mrk mid="0" mtype="seg">You can arbitrarily put parentheses around queries, or use the parentheses to control the order of evaluation of the INTERSECT, EXCEPT, or UNION operations.</mrk><mrk mid="1" mtype="seg"> These operations are evaluated from left to right when no parentheses are present, with the exception of INTERSECT operations, which would be evaluated before any UNION or EXCEPT operations.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">You can arbitrarily put parentheses around queries, or use the parentheses to control the order of evaluation of the INTERSECT, EXCEPT, or UNION operations.</mrk><mrk mid="1" mtype="seg"> These operations are evaluated from left to right when no parentheses are present, with the exception of INTERSECT operations, which would be evaluated before any UNION or EXCEPT operations.</mrk></target>
</trans-unit>
<trans-unit id="tu8">
<source xml:lang="en">Duplicates in UNION, INTERSECT, and EXCEPT ALL results</source>
<seg-source><mrk mid="0" mtype="seg">Duplicates in UNION, INTERSECT, and EXCEPT ALL results</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Duplicates in UNION, INTERSECT, and EXCEPT ALL results</mrk></target>
</trans-unit>
<trans-unit id="tu9">
<source xml:lang="en">The ALL and DISTINCT keywords determine whether duplicates are eliminated from the result of the operation. If you specify the DISTINCT keyword, then the result will have no duplicate rows. If you specify the ALL keyword, then there may be duplicates in the result, depending on whether there were duplicates in the input. DISTINCT is the default, so if you don't specify ALL or DISTINCT, the duplicates will be eliminated. For example, UNION builds an intermediate <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>ResultSet<ept id="1">&lt;/i&gt;</ept> with all of the rows from both queries and eliminates the duplicate rows before returning the remaining rows. UNION ALL returns all rows from both queries as the result.</source>
<seg-source><mrk mid="0" mtype="seg">The ALL and DISTINCT keywords determine whether duplicates are eliminated from the result of the operation.</mrk><mrk mid="1" mtype="seg"> If you specify the DISTINCT keyword, then the result will have no duplicate rows.</mrk><mrk mid="2" mtype="seg"> If you specify the ALL keyword, then there may be duplicates in the result, depending on whether there were duplicates in the input.</mrk><mrk mid="3" mtype="seg"> DISTINCT is the default, so if you don't specify ALL or DISTINCT, the duplicates will be eliminated.</mrk><mrk mid="4" mtype="seg"> For example, UNION builds an intermediate <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>ResultSet<ept id="1">&lt;/i&gt;</ept> with all of the rows from both queries and eliminates the duplicate rows before returning the remaining rows.</mrk><mrk mid="5" mtype="seg"> UNION ALL returns all rows from both queries as the result.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">The ALL and DISTINCT keywords determine whether duplicates are eliminated from the result of the operation.</mrk><mrk mid="1" mtype="seg"> If you specify the DISTINCT keyword, then the result will have no duplicate rows.</mrk><mrk mid="2" mtype="seg"> If you specify the ALL keyword, then there may be duplicates in the result, depending on whether there were duplicates in the input.</mrk><mrk mid="3" mtype="seg"> DISTINCT is the default, so if you don't specify ALL or DISTINCT, the duplicates will be eliminated.</mrk><mrk mid="4" mtype="seg"> For example, UNION builds an intermediate <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>ResultSet<ept id="1">&lt;/i&gt;</ept> with all of the rows from both queries and eliminates the duplicate rows before returning the remaining rows.</mrk><mrk mid="5" mtype="seg"> UNION ALL returns all rows from both queries as the result.</mrk></target>
</trans-unit>
<trans-unit id="tu10">
<source xml:lang="en">Depending on which operation is specified, if the number of copies of a row in the left table is L and the number of copies of that row in the right table is R, then the number of duplicates of that particular row that the output table contains (assuming the ALL keyword is specified) is:</source>
<seg-source><mrk mid="0" mtype="seg">Depending on which operation is specified, if the number of copies of a row in the left table is L and the number of copies of that row in the right table is R, then the number of duplicates of that particular row that the output table contains (assuming the ALL keyword is specified) is:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Depending on which operation is specified, if the number of copies of a row in the left table is L and the number of copies of that row in the right table is R, then the number of duplicates of that particular row that the output table contains (assuming the ALL keyword is specified) is:</mrk></target>
</trans-unit>
<trans-unit id="tu11">
<source xml:lang="en">UNION: ( L + R ).</source>
<seg-source><mrk mid="0" mtype="seg">UNION: ( L + R ).</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">UNION: ( L + R ).</mrk></target>
</trans-unit>
<trans-unit id="tu12">
<source xml:lang="en">EXCEPT: the maximum of ( L - R ) and 0 (zero).</source>
<seg-source><mrk mid="0" mtype="seg">EXCEPT: the maximum of ( L - R ) and 0 (zero).</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">EXCEPT: the maximum of ( L - R ) and 0 (zero).</mrk></target>
</trans-unit>
<trans-unit id="tu13">
<source xml:lang="en">INTERSECT: the minimum of L and R.</source>
<seg-source><mrk mid="0" mtype="seg">INTERSECT: the minimum of L and R.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">INTERSECT: the minimum of L and R.</mrk></target>
</trans-unit>
<trans-unit id="tu14">
<source xml:lang="en">Examples</source>
<seg-source><mrk mid="0" mtype="seg">Examples</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Examples</mrk></target>
</trans-unit>
<trans-unit id="tu15">
<source xml:lang="en"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt><bpt id="2" ctype="x-ph">&lt;ph&gt;</bpt>-- a Select expression <ept id="2">&lt;/ph&gt;</ept> SELECT * FROM ORG <bpt id="3" ctype="x-ph">&lt;ph&gt;</bpt>-- a subquery <ept id="3">&lt;/ph&gt;</ept> SELECT * FROM (SELECT CLASS_CODE FROM CL_SCHED) AS CS -- a subquery SELECT * FROM (SELECT CLASS_CODE FROM CL_SCHED) AS CS (CLASS_CODE) <bpt id="4" ctype="x-ph">&lt;ph&gt;</bpt>-- a UNION -- returns all rows from columns DEPTNUMB and MANAGER -- in table ORG -- and (1,2) and (3,4) -- DEPTNUMB and MANAGER are smallint columns<ept id="4">&lt;/ph&gt;</ept> SELECT DEPTNUMB, MANAGER FROM ORG UNION ALL VALUES (1,2), (3,4) <bpt id="5" ctype="x-ph">&lt;ph&gt;</bpt>-- a values expression<ept id="5">&lt;/ph&gt;</ept> VALUES (1,2,3) <bpt id="6" ctype="x-ph">&lt;ph&gt;</bpt>-- Use of ORDER BY and FETCH FIRST in a subquery<ept id="6">&lt;/ph&gt;</ept> SELECT DISTINCT A.ORIG_AIRPORT, B.FLIGHT_ID FROM (SELECT FLIGHT_ID, ORIG_AIRPORT FROM FLIGHTS ORDER BY ORIG_AIRPORT DESC FETCH FIRST 40 ROWS ONLY) AS A, FLIGHTAVAILABILITY AS B WHERE A.FLIGHT_ID = B.FLIGHT_ID<ept id="1">&lt;/b&gt;</ept> <bpt id="7" ctype="x-b">&lt;b&gt;</bpt>-- List the employee numbers (EMPNO) of all employees in the EMPLOYEE -- table whose department number (WORKDEPT) either begins with 'E' or -- who are assigned to projects in the EMP_ACT table -- whose project number (PROJNO) equals 'MA2100', 'MA2110', or 'MA2112' SELECT EMPNO FROM EMPLOYEE WHERE WORKDEPT LIKE 'E%' UNION SELECT EMPNO FROM EMP_ACT WHERE PROJNO IN('MA2100', 'MA2110', 'MA2112')<ept id="7">&lt;/b&gt;</ept> <it id="8" ctype="x-b" pos="open">&lt;b&gt;</it>-- Make the same query as in the previous example -- and "tag" the rows from the EMPLOYEE table with 'emp' and -- the rows from the EMP_ACT table with 'emp_act'. -- Unlike the result from the previous example, -- this query may return the same EMPNO more than once, -- identifying which table it came from by the associated "tag" SELECT EMPNO, 'emp' FROM EMPLOYEE WHERE WORKDEPT LIKE 'E%' UNION SELECT EMPNO, 'emp_act' FROM EMP_ACT WHERE PROJNO IN('MA2100', 'MA2110', 'MA2112')<it id="8" ctype="x-b" pos="close">&lt;/b&gt;</it> <bpt id="9" ctype="x-b">&lt;b&gt;</bpt>-- Make the same query as in the previous example, -- only use UNION ALL so that no duplicate rows are eliminated SELECT EMPNO FROM EMPLOYEE WHERE WORKDEPT LIKE 'E%' UNION ALL SELECT EMPNO FROM EMP_ACT WHERE PROJNO IN('MA2100', 'MA2110', 'MA2112')<ept id="9">&lt;/b&gt;</ept> <bpt id="10" ctype="x-b">&lt;b&gt;</bpt>-- Make the same query as in the previous example, -- only include an additional two employees currently not in any table -- and tag these rows as "new" SELECT EMPNO, 'emp' FROM EMPLOYEE WHERE WORKDEPT LIKE 'E%' UNION SELECT EMPNO, 'emp_act' FROM EMP_ACT WHERE PROJNO IN('MA2100', 'MA2110', 'MA2112') UNION VALUES ('NEWAAA', 'new'), ('NEWBBB', 'new')<ept id="10">&lt;/b&gt;</ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt><bpt id="2" ctype="x-ph">&lt;ph&gt;</bpt>-- a Select expression <ept id="2">&lt;/ph&gt;</ept> SELECT * FROM ORG <bpt id="3" ctype="x-ph">&lt;ph&gt;</bpt>-- a subquery <ept id="3">&lt;/ph&gt;</ept> SELECT * FROM (SELECT CLASS_CODE FROM CL_SCHED) AS CS -- a subquery SELECT * FROM (SELECT CLASS_CODE FROM CL_SCHED) AS CS (CLASS_CODE) <bpt id="4" ctype="x-ph">&lt;ph&gt;</bpt>-- a UNION -- returns all rows from columns DEPTNUMB and MANAGER -- in table ORG -- and (1,2) and (3,4) -- DEPTNUMB and MANAGER are smallint columns<ept id="4">&lt;/ph&gt;</ept> SELECT DEPTNUMB, MANAGER FROM ORG UNION ALL VALUES (1,2), (3,4) <bpt id="5" ctype="x-ph">&lt;ph&gt;</bpt>-- a values expression<ept id="5">&lt;/ph&gt;</ept> VALUES (1,2,3) <bpt id="6" ctype="x-ph">&lt;ph&gt;</bpt>-- Use of ORDER BY and FETCH FIRST in a subquery<ept id="6">&lt;/ph&gt;</ept> SELECT DISTINCT A.ORIG_AIRPORT, B.FLIGHT_ID FROM (SELECT FLIGHT_ID, ORIG_AIRPORT FROM FLIGHTS ORDER BY ORIG_AIRPORT DESC FETCH FIRST 40 ROWS ONLY) AS A, FLIGHTAVAILABILITY AS B WHERE A.FLIGHT_ID = B.FLIGHT_ID<ept id="1">&lt;/b&gt;</ept> <bpt id="7" ctype="x-b">&lt;b&gt;</bpt>-- List the employee numbers (EMPNO) of all employees in the EMPLOYEE -- table whose department number (WORKDEPT) either begins with 'E' or -- who are assigned to projects in the EMP_ACT table -- whose project number (PROJNO) equals 'MA2100', 'MA2110', or 'MA2112' SELECT EMPNO FROM EMPLOYEE WHERE WORKDEPT LIKE 'E%' UNION SELECT EMPNO FROM EMP_ACT WHERE PROJNO IN('MA2100', 'MA2110', 'MA2112')<ept id="7">&lt;/b&gt;</ept> <it id="8" ctype="x-b" pos="open">&lt;b&gt;</it>-- Make the same query as in the previous example -- and "tag" the rows from the EMPLOYEE table with 'emp' and -- the rows from the EMP_ACT table with 'emp_act'.</mrk><mrk mid="1" mtype="seg"> -- Unlike the result from the previous example, -- this query may return the same EMPNO more than once, -- identifying which table it came from by the associated "tag" SELECT EMPNO, 'emp' FROM EMPLOYEE WHERE WORKDEPT LIKE 'E%' UNION SELECT EMPNO, 'emp_act' FROM EMP_ACT WHERE PROJNO IN('MA2100', 'MA2110', 'MA2112')<it id="8" ctype="x-b" pos="close">&lt;/b&gt;</it> <bpt id="9" ctype="x-b">&lt;b&gt;</bpt>-- Make the same query as in the previous example, -- only use UNION ALL so that no duplicate rows are eliminated SELECT EMPNO FROM EMPLOYEE WHERE WORKDEPT LIKE 'E%' UNION ALL SELECT EMPNO FROM EMP_ACT WHERE PROJNO IN('MA2100', 'MA2110', 'MA2112')<ept id="9">&lt;/b&gt;</ept> <bpt id="10" ctype="x-b">&lt;b&gt;</bpt>-- Make the same query as in the previous example, -- only include an additional two employees currently not in any table -- and tag these rows as "new" SELECT EMPNO, 'emp' FROM EMPLOYEE WHERE WORKDEPT LIKE 'E%' UNION SELECT EMPNO, 'emp_act' FROM EMP_ACT WHERE PROJNO IN('MA2100', 'MA2110', 'MA2112') UNION VALUES ('NEWAAA', 'new'), ('NEWBBB', 'new')<ept id="10">&lt;/b&gt;</ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt><bpt id="2" ctype="x-ph">&lt;ph&gt;</bpt>-- a Select expression <ept id="2">&lt;/ph&gt;</ept> SELECT * FROM ORG <bpt id="3" ctype="x-ph">&lt;ph&gt;</bpt>-- a subquery <ept id="3">&lt;/ph&gt;</ept> SELECT * FROM (SELECT CLASS_CODE FROM CL_SCHED) AS CS -- a subquery SELECT * FROM (SELECT CLASS_CODE FROM CL_SCHED) AS CS (CLASS_CODE) <bpt id="4" ctype="x-ph">&lt;ph&gt;</bpt>-- a UNION -- returns all rows from columns DEPTNUMB and MANAGER -- in table ORG -- and (1,2) and (3,4) -- DEPTNUMB and MANAGER are smallint columns<ept id="4">&lt;/ph&gt;</ept> SELECT DEPTNUMB, MANAGER FROM ORG UNION ALL VALUES (1,2), (3,4) <bpt id="5" ctype="x-ph">&lt;ph&gt;</bpt>-- a values expression<ept id="5">&lt;/ph&gt;</ept> VALUES (1,2,3) <bpt id="6" ctype="x-ph">&lt;ph&gt;</bpt>-- Use of ORDER BY and FETCH FIRST in a subquery<ept id="6">&lt;/ph&gt;</ept> SELECT DISTINCT A.ORIG_AIRPORT, B.FLIGHT_ID FROM (SELECT FLIGHT_ID, ORIG_AIRPORT FROM FLIGHTS ORDER BY ORIG_AIRPORT DESC FETCH FIRST 40 ROWS ONLY) AS A, FLIGHTAVAILABILITY AS B WHERE A.FLIGHT_ID = B.FLIGHT_ID<ept id="1">&lt;/b&gt;</ept> <bpt id="7" ctype="x-b">&lt;b&gt;</bpt>-- List the employee numbers (EMPNO) of all employees in the EMPLOYEE -- table whose department number (WORKDEPT) either begins with 'E' or -- who are assigned to projects in the EMP_ACT table -- whose project number (PROJNO) equals 'MA2100', 'MA2110', or 'MA2112' SELECT EMPNO FROM EMPLOYEE WHERE WORKDEPT LIKE 'E%' UNION SELECT EMPNO FROM EMP_ACT WHERE PROJNO IN('MA2100', 'MA2110', 'MA2112')<ept id="7">&lt;/b&gt;</ept> <it id="8" ctype="x-b" pos="open">&lt;b&gt;</it>-- Make the same query as in the previous example -- and "tag" the rows from the EMPLOYEE table with 'emp' and -- the rows from the EMP_ACT table with 'emp_act'.</mrk><mrk mid="1" mtype="seg"> -- Unlike the result from the previous example, -- this query may return the same EMPNO more than once, -- identifying which table it came from by the associated "tag" SELECT EMPNO, 'emp' FROM EMPLOYEE WHERE WORKDEPT LIKE 'E%' UNION SELECT EMPNO, 'emp_act' FROM EMP_ACT WHERE PROJNO IN('MA2100', 'MA2110', 'MA2112')<it id="8" ctype="x-b" pos="close">&lt;/b&gt;</it> <bpt id="9" ctype="x-b">&lt;b&gt;</bpt>-- Make the same query as in the previous example, -- only use UNION ALL so that no duplicate rows are eliminated SELECT EMPNO FROM EMPLOYEE WHERE WORKDEPT LIKE 'E%' UNION ALL SELECT EMPNO FROM EMP_ACT WHERE PROJNO IN('MA2100', 'MA2110', 'MA2112')<ept id="9">&lt;/b&gt;</ept> <bpt id="10" ctype="x-b">&lt;b&gt;</bpt>-- Make the same query as in the previous example, -- only include an additional two employees currently not in any table -- and tag these rows as "new" SELECT EMPNO, 'emp' FROM EMPLOYEE WHERE WORKDEPT LIKE 'E%' UNION SELECT EMPNO, 'emp_act' FROM EMP_ACT WHERE PROJNO IN('MA2100', 'MA2110', 'MA2112') UNION VALUES ('NEWAAA', 'new'), ('NEWBBB', 'new')<ept id="10">&lt;/b&gt;</ept></mrk></target>
</trans-unit>
</body>
</file>
</xliff>
