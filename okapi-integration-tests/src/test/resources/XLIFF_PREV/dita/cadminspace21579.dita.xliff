<?xml version="1.0" encoding="UTF-8"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:okp="okapi-framework:xliff-extensions" xmlns:its="http://www.w3.org/2005/11/its" xmlns:itsxlf="http://www.w3.org/ns/its-xliff/" its:version="2.0">
<file original="cadminspace21579.dita" source-language="en" target-language="fr" datatype="xml" okp:inputEncoding="utf-8" okp:configId="/home/jimh/Code/Okapi/okapi/okapi/filters/xmlstream/target/classes/net/sf/okapi/filters/xmlstream/dita.yml">
<header><tool tool-id="okapi" tool-name="okapi-tests" tool-version="M29" tool-company="okapi"></tool></header>
<body>
<trans-unit id="tu1">
<source xml:lang="en">Reclaiming unused space</source>
<seg-source><mrk mid="0" mtype="seg">Reclaiming unused space</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Reclaiming unused space</mrk></target>
</trans-unit>
<trans-unit id="tu2">
<source xml:lang="en">A <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> table or index (sometimes called a <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>conglomerate<ept id="2">&lt;/i&gt;</ept>) can contain unused space after large amounts of data have been deleted or updated.</source>
<seg-source><mrk mid="0" mtype="seg">A <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> table or index (sometimes called a <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>conglomerate<ept id="2">&lt;/i&gt;</ept>) can contain unused space after large amounts of data have been deleted or updated.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">A <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> table or index (sometimes called a <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>conglomerate<ept id="2">&lt;/i&gt;</ept>) can contain unused space after large amounts of data have been deleted or updated.</mrk></target>
</trans-unit>
<trans-unit id="tu3">
<source xml:lang="en">Compressing tables and indexes</source>
<seg-source><mrk mid="0" mtype="seg">Compressing tables and indexes</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Compressing tables and indexes</mrk></target>
</trans-unit>
<trans-unit id="tu4">
<source xml:lang="en">conglomerate</source>
<seg-source><mrk mid="0" mtype="seg">conglomerate</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">conglomerate</mrk></target>
</trans-unit>
<trans-unit id="tu5">
<source xml:lang="en">description</source>
<seg-source><mrk mid="0" mtype="seg">description</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">description</mrk></target>
</trans-unit>
<trans-unit id="tu6">
<source xml:lang="en">This happens because, by default, <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> does not return unused space to the operating system. After a page has been allocated to a table or index, <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> does not automatically return the page to the operating system until the table or index is dropped, even if the space is no longer needed. However, <bpt id="3" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="3">&lt;/ph&gt;</ept> does provide a way to reclaim unused space in tables and associated indexes.</source>
<seg-source><mrk mid="0" mtype="seg">This happens because, by default, <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> does not return unused space to the operating system.</mrk><mrk mid="1" mtype="seg"> After a page has been allocated to a table or index, <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> does not automatically return the page to the operating system until the table or index is dropped, even if the space is no longer needed.</mrk><mrk mid="2" mtype="seg"> However, <bpt id="3" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="3">&lt;/ph&gt;</ept> does provide a way to reclaim unused space in tables and associated indexes.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">This happens because, by default, <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> does not return unused space to the operating system.</mrk><mrk mid="1" mtype="seg"> After a page has been allocated to a table or index, <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> does not automatically return the page to the operating system until the table or index is dropped, even if the space is no longer needed.</mrk><mrk mid="2" mtype="seg"> However, <bpt id="3" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="3">&lt;/ph&gt;</ept> does provide a way to reclaim unused space in tables and associated indexes.</mrk></target>
</trans-unit>
<trans-unit id="tu7">
<source xml:lang="en">If you determine that a table and its indexes have a significant amount of unused space, use either the <bpt id="1" ctype="x-codeph">&lt;codeph&gt;</bpt>SYSCS_UTIL.SYSCS_COMPRESS_TABLE<ept id="1">&lt;/codeph&gt;</ept> or <bpt id="2" ctype="x-codeph">&lt;codeph&gt;</bpt>SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE<ept id="2">&lt;/codeph&gt;</ept> procedure to reclaim that space. <bpt id="3" ctype="x-codeph">&lt;codeph&gt;</bpt>SYSCS_UTIL.SYSCS_COMPRESS_TABLE<ept id="3">&lt;/codeph&gt;</ept> is guaranteed to recover the maximum amount of free space, at the cost of temporarily creating new tables and indexes before the statement is committed. <bpt id="4" ctype="x-codeph">&lt;codeph&gt;</bpt>SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE<ept id="4">&lt;/codeph&gt;</ept> attempts to reclaim space within the same table, but cannot guarantee it will recover all available space. The difference between the two procedures is that unlike <bpt id="5" ctype="x-codeph">&lt;codeph&gt;</bpt>SYSCS_UTIL.SYSCS_COMPRESS_TABLE<ept id="5">&lt;/codeph&gt;</ept>, the <bpt id="6" ctype="x-codeph">&lt;codeph&gt;</bpt>SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE<ept id="6">&lt;/codeph&gt;</ept> procedure uses no temporary files and moves rows around within the same conglomerate.</source>
<seg-source><mrk mid="0" mtype="seg">If you determine that a table and its indexes have a significant amount of unused space, use either the <bpt id="1" ctype="x-codeph">&lt;codeph&gt;</bpt>SYSCS_UTIL.SYSCS_COMPRESS_TABLE<ept id="1">&lt;/codeph&gt;</ept> or <bpt id="2" ctype="x-codeph">&lt;codeph&gt;</bpt>SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE<ept id="2">&lt;/codeph&gt;</ept> procedure to reclaim that space.</mrk><mrk mid="1" mtype="seg"> <bpt id="3" ctype="x-codeph">&lt;codeph&gt;</bpt>SYSCS_UTIL.SYSCS_COMPRESS_TABLE<ept id="3">&lt;/codeph&gt;</ept> is guaranteed to recover the maximum amount of free space, at the cost of temporarily creating new tables and indexes before the statement is committed.</mrk><mrk mid="2" mtype="seg"> <bpt id="4" ctype="x-codeph">&lt;codeph&gt;</bpt>SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE<ept id="4">&lt;/codeph&gt;</ept> attempts to reclaim space within the same table, but cannot guarantee it will recover all available space.</mrk><mrk mid="3" mtype="seg"> The difference between the two procedures is that unlike <bpt id="5" ctype="x-codeph">&lt;codeph&gt;</bpt>SYSCS_UTIL.SYSCS_COMPRESS_TABLE<ept id="5">&lt;/codeph&gt;</ept>, the <bpt id="6" ctype="x-codeph">&lt;codeph&gt;</bpt>SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE<ept id="6">&lt;/codeph&gt;</ept> procedure uses no temporary files and moves rows around within the same conglomerate.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">If you determine that a table and its indexes have a significant amount of unused space, use either the <bpt id="1" ctype="x-codeph">&lt;codeph&gt;</bpt>SYSCS_UTIL.SYSCS_COMPRESS_TABLE<ept id="1">&lt;/codeph&gt;</ept> or <bpt id="2" ctype="x-codeph">&lt;codeph&gt;</bpt>SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE<ept id="2">&lt;/codeph&gt;</ept> procedure to reclaim that space.</mrk><mrk mid="1" mtype="seg"> <bpt id="3" ctype="x-codeph">&lt;codeph&gt;</bpt>SYSCS_UTIL.SYSCS_COMPRESS_TABLE<ept id="3">&lt;/codeph&gt;</ept> is guaranteed to recover the maximum amount of free space, at the cost of temporarily creating new tables and indexes before the statement is committed.</mrk><mrk mid="2" mtype="seg"> <bpt id="4" ctype="x-codeph">&lt;codeph&gt;</bpt>SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE<ept id="4">&lt;/codeph&gt;</ept> attempts to reclaim space within the same table, but cannot guarantee it will recover all available space.</mrk><mrk mid="3" mtype="seg"> The difference between the two procedures is that unlike <bpt id="5" ctype="x-codeph">&lt;codeph&gt;</bpt>SYSCS_UTIL.SYSCS_COMPRESS_TABLE<ept id="5">&lt;/codeph&gt;</ept>, the <bpt id="6" ctype="x-codeph">&lt;codeph&gt;</bpt>SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE<ept id="6">&lt;/codeph&gt;</ept> procedure uses no temporary files and moves rows around within the same conglomerate.</mrk></target>
</trans-unit>
<trans-unit id="tu8">
<source xml:lang="en">You can use the <bpt id="1" ctype="x-codeph">&lt;codeph&gt;</bpt>SYSCS_DIAG.SPACE_TABLE<ept id="1">&lt;/codeph&gt;</ept> diagnostic table to estimate the amount of unused space in a table or index by examining, in particular, the values of the NUMFREEPAGES and ESTIMSPACESAVING columns. For example:</source>
<seg-source><mrk mid="0" mtype="seg">You can use the <bpt id="1" ctype="x-codeph">&lt;codeph&gt;</bpt>SYSCS_DIAG.SPACE_TABLE<ept id="1">&lt;/codeph&gt;</ept> diagnostic table to estimate the amount of unused space in a table or index by examining, in particular, the values of the NUMFREEPAGES and ESTIMSPACESAVING columns.</mrk><mrk mid="1" mtype="seg"> For example:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">You can use the <bpt id="1" ctype="x-codeph">&lt;codeph&gt;</bpt>SYSCS_DIAG.SPACE_TABLE<ept id="1">&lt;/codeph&gt;</ept> diagnostic table to estimate the amount of unused space in a table or index by examining, in particular, the values of the NUMFREEPAGES and ESTIMSPACESAVING columns.</mrk><mrk mid="1" mtype="seg"> For example:</mrk></target>
</trans-unit>
<trans-unit id="tu9">
<source xml:lang="en"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>SELECT * FROM TABLE(SYSCS_DIAG.SPACE_TABLE('APP', 'FLIGHTAVAILABILITY')) AS T<ept id="1">&lt;/b&gt;</ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>SELECT * FROM TABLE(SYSCS_DIAG.SPACE_TABLE('APP', 'FLIGHTAVAILABILITY')) AS T<ept id="1">&lt;/b&gt;</ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>SELECT * FROM TABLE(SYSCS_DIAG.SPACE_TABLE('APP', 'FLIGHTAVAILABILITY')) AS T<ept id="1">&lt;/b&gt;</ept></mrk></target>
</trans-unit>
<trans-unit id="tu10">
<source xml:lang="en">For more information about <bpt id="1" ctype="x-codeph">&lt;codeph&gt;</bpt>SYSCS_DIAG.SPACE_TABLE<ept id="1">&lt;/codeph&gt;</ept> see "SYSCS_DIAG diagnostic tables and functions" in the <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#pub/citref"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept>.</source>
<seg-source><mrk mid="0" mtype="seg">For more information about <bpt id="1" ctype="x-codeph">&lt;codeph&gt;</bpt>SYSCS_DIAG.SPACE_TABLE<ept id="1">&lt;/codeph&gt;</ept> see "SYSCS_DIAG diagnostic tables and functions" in the <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#pub/citref"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept>.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">For more information about <bpt id="1" ctype="x-codeph">&lt;codeph&gt;</bpt>SYSCS_DIAG.SPACE_TABLE<ept id="1">&lt;/codeph&gt;</ept> see "SYSCS_DIAG diagnostic tables and functions" in the <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#pub/citref"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept>.</mrk></target>
</trans-unit>
<trans-unit id="tu11">
<source xml:lang="en">As an example, after you have determined that the <bpt id="1" ctype="x-codeph">&lt;codeph&gt;</bpt>FlightAvailability<ept id="1">&lt;/codeph&gt;</ept> table and its related indexes have too much unused space, you could reclaim that space with the following command:</source>
<seg-source><mrk mid="0" mtype="seg">As an example, after you have determined that the <bpt id="1" ctype="x-codeph">&lt;codeph&gt;</bpt>FlightAvailability<ept id="1">&lt;/codeph&gt;</ept> table and its related indexes have too much unused space, you could reclaim that space with the following command:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">As an example, after you have determined that the <bpt id="1" ctype="x-codeph">&lt;codeph&gt;</bpt>FlightAvailability<ept id="1">&lt;/codeph&gt;</ept> table and its related indexes have too much unused space, you could reclaim that space with the following command:</mrk></target>
</trans-unit>
<trans-unit id="tu12">
<source xml:lang="en"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>call SYSCS_UTIL.SYSCS_COMPRESS_TABLE('APP', 'FLIGHTAVAILABILITY', 0);<ept id="1">&lt;/b&gt;</ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>call SYSCS_UTIL.SYSCS_COMPRESS_TABLE('APP', 'FLIGHTAVAILABILITY', 0);<ept id="1">&lt;/b&gt;</ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>call SYSCS_UTIL.SYSCS_COMPRESS_TABLE('APP', 'FLIGHTAVAILABILITY', 0);<ept id="1">&lt;/b&gt;</ept></mrk></target>
</trans-unit>
<trans-unit id="tu13">
<source xml:lang="en">The third parameter in the <bpt id="1" ctype="x-codeph">&lt;codeph&gt;</bpt>SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE<ept id="1">&lt;/codeph&gt;</ept> procedure determines whether the operation will run in sequential or non-sequential mode. If you specify <bpt id="2" ctype="x-codeph">&lt;codeph&gt;</bpt>0<ept id="2">&lt;/codeph&gt;</ept> for the third argument in the procedure, the operation will run in non-sequential mode. In sequential mode, <bpt id="3" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="3">&lt;/ph&gt;</ept> compresses the table and indexes sequentially, one at a time. Sequential compression uses less memory and disk space but is slower. To force the operation to run in sequential mode, substitute a non-zero SMALLINT value for the third argument. The following example shows how to force the procedure to run in sequential mode:</source>
<seg-source><mrk mid="0" mtype="seg">The third parameter in the <bpt id="1" ctype="x-codeph">&lt;codeph&gt;</bpt>SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE<ept id="1">&lt;/codeph&gt;</ept> procedure determines whether the operation will run in sequential or non-sequential mode.</mrk><mrk mid="1" mtype="seg"> If you specify <bpt id="2" ctype="x-codeph">&lt;codeph&gt;</bpt>0<ept id="2">&lt;/codeph&gt;</ept> for the third argument in the procedure, the operation will run in non-sequential mode.</mrk><mrk mid="2" mtype="seg"> In sequential mode, <bpt id="3" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="3">&lt;/ph&gt;</ept> compresses the table and indexes sequentially, one at a time.</mrk><mrk mid="3" mtype="seg"> Sequential compression uses less memory and disk space but is slower.</mrk><mrk mid="4" mtype="seg"> To force the operation to run in sequential mode, substitute a non-zero SMALLINT value for the third argument.</mrk><mrk mid="5" mtype="seg"> The following example shows how to force the procedure to run in sequential mode:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">The third parameter in the <bpt id="1" ctype="x-codeph">&lt;codeph&gt;</bpt>SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE<ept id="1">&lt;/codeph&gt;</ept> procedure determines whether the operation will run in sequential or non-sequential mode.</mrk><mrk mid="1" mtype="seg"> If you specify <bpt id="2" ctype="x-codeph">&lt;codeph&gt;</bpt>0<ept id="2">&lt;/codeph&gt;</ept> for the third argument in the procedure, the operation will run in non-sequential mode.</mrk><mrk mid="2" mtype="seg"> In sequential mode, <bpt id="3" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="3">&lt;/ph&gt;</ept> compresses the table and indexes sequentially, one at a time.</mrk><mrk mid="3" mtype="seg"> Sequential compression uses less memory and disk space but is slower.</mrk><mrk mid="4" mtype="seg"> To force the operation to run in sequential mode, substitute a non-zero SMALLINT value for the third argument.</mrk><mrk mid="5" mtype="seg"> The following example shows how to force the procedure to run in sequential mode:</mrk></target>
</trans-unit>
<trans-unit id="tu14">
<source xml:lang="en"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>call SYSCS_UTIL.SYSCS_COMPRESS_TABLE('APP', 'FLIGHTAVAILABILITY', 1);<ept id="1">&lt;/b&gt;</ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>call SYSCS_UTIL.SYSCS_COMPRESS_TABLE('APP', 'FLIGHTAVAILABILITY', 1);<ept id="1">&lt;/b&gt;</ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>call SYSCS_UTIL.SYSCS_COMPRESS_TABLE('APP', 'FLIGHTAVAILABILITY', 1);<ept id="1">&lt;/b&gt;</ept></mrk></target>
</trans-unit>
<trans-unit id="tu15">
<source xml:lang="en">For more information about this command, see the <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#pub/citref"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept>.</source>
<seg-source><mrk mid="0" mtype="seg">For more information about this command, see the <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#pub/citref"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept>.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">For more information about this command, see the <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#pub/citref"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept>.</mrk></target>
</trans-unit>
</body>
</file>
</xliff>
