<?xml version="1.0" encoding="UTF-8"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:okp="okapi-framework:xliff-extensions" xmlns:its="http://www.w3.org/2005/11/its" xmlns:itsxlf="http://www.w3.org/ns/its-xliff/" its:version="2.0">
<file original="cdevconcepts53677.dita" source-language="en" target-language="fr" datatype="xml" okp:inputEncoding="utf-8" okp:configId="/home/jimh/Code/Okapi/okapi/okapi/filters/xmlstream/target/classes/net/sf/okapi/filters/xmlstream/dita.yml">
<header><tool tool-id="okapi" tool-name="okapi-tests" tool-version="M29" tool-company="okapi"></tool></header>
<body>
<trans-unit id="tu1">
<source xml:lang="en">Avoiding deadlocks</source>
<seg-source><mrk mid="0" mtype="seg">Avoiding deadlocks</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Avoiding deadlocks</mrk></target>
</trans-unit>
<trans-unit id="tu2">
<source xml:lang="en">Using both row-level locking and the TRANSACTION_READ_COMMITTED isolation level makes it likely that you will avoid deadlocks (both settings are <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> defaults). However, deadlocks are still possible.</source>
<seg-source><mrk mid="0" mtype="seg">Using both row-level locking and the TRANSACTION_READ_COMMITTED isolation level makes it likely that you will avoid deadlocks (both settings are <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> defaults).</mrk><mrk mid="1" mtype="seg"> However, deadlocks are still possible.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Using both row-level locking and the TRANSACTION_READ_COMMITTED isolation level makes it likely that you will avoid deadlocks (both settings are <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> defaults).</mrk><mrk mid="1" mtype="seg"> However, deadlocks are still possible.</mrk></target>
</trans-unit>
<trans-unit id="tu3">
<source xml:lang="en"><bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> application developers can avoid deadlocks by using consistent application logic; for example, transactions that access <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>Accounts<ept id="2">&lt;/i&gt;</ept> and <bpt id="3" ctype="x-i">&lt;i&gt;</bpt>Orders<ept id="3">&lt;/i&gt;</ept> should always access the tables in the same order. That way, in the scenario described above, Transaction B simply waits for transaction A to release the lock on <bpt id="4" ctype="x-i">&lt;i&gt;</bpt>Orders<ept id="4">&lt;/i&gt;</ept> before it begins. When transaction A releases the lock on <bpt id="5" ctype="x-i">&lt;i&gt;</bpt>Orders<ept id="5">&lt;/i&gt;</ept>, Transaction B can proceed freely.</source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> application developers can avoid deadlocks by using consistent application logic; for example, transactions that access <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>Accounts<ept id="2">&lt;/i&gt;</ept> and <bpt id="3" ctype="x-i">&lt;i&gt;</bpt>Orders<ept id="3">&lt;/i&gt;</ept> should always access the tables in the same order.</mrk><mrk mid="1" mtype="seg"> That way, in the scenario described above, Transaction B simply waits for transaction A to release the lock on <bpt id="4" ctype="x-i">&lt;i&gt;</bpt>Orders<ept id="4">&lt;/i&gt;</ept> before it begins.</mrk><mrk mid="2" mtype="seg"> When transaction A releases the lock on <bpt id="5" ctype="x-i">&lt;i&gt;</bpt>Orders<ept id="5">&lt;/i&gt;</ept>, Transaction B can proceed freely.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> application developers can avoid deadlocks by using consistent application logic; for example, transactions that access <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>Accounts<ept id="2">&lt;/i&gt;</ept> and <bpt id="3" ctype="x-i">&lt;i&gt;</bpt>Orders<ept id="3">&lt;/i&gt;</ept> should always access the tables in the same order.</mrk><mrk mid="1" mtype="seg"> That way, in the scenario described above, Transaction B simply waits for transaction A to release the lock on <bpt id="4" ctype="x-i">&lt;i&gt;</bpt>Orders<ept id="4">&lt;/i&gt;</ept> before it begins.</mrk><mrk mid="2" mtype="seg"> When transaction A releases the lock on <bpt id="5" ctype="x-i">&lt;i&gt;</bpt>Orders<ept id="5">&lt;/i&gt;</ept>, Transaction B can proceed freely.</mrk></target>
</trans-unit>
<trans-unit id="tu4">
<source xml:lang="en">The appropriate use of indexes can also help you to avoid deadlocks, since indexes make table scans less likely and reduce the number of locks obtained. For more information, see "CREATE INDEX statement" in the <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#pub/citref"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> and the topics under "Avoiding table scans of large tables" in <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#pub/cittuning"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept>.</source>
<seg-source><mrk mid="0" mtype="seg">The appropriate use of indexes can also help you to avoid deadlocks, since indexes make table scans less likely and reduce the number of locks obtained.</mrk><mrk mid="1" mtype="seg"> For more information, see "CREATE INDEX statement" in the <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#pub/citref"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> and the topics under "Avoiding table scans of large tables" in <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#pub/cittuning"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept>.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">The appropriate use of indexes can also help you to avoid deadlocks, since indexes make table scans less likely and reduce the number of locks obtained.</mrk><mrk mid="1" mtype="seg"> For more information, see "CREATE INDEX statement" in the <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#pub/citref"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> and the topics under "Avoiding table scans of large tables" in <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#pub/cittuning"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept>.</mrk></target>
</trans-unit>
<trans-unit id="tu5">
<source xml:lang="en">Another tool available to you is the LOCK TABLE statement. A transaction can attempt to lock a table in exclusive mode when it starts to prevent other transactions from getting shared locks on a table. For more information, see "LOCK TABLE statement" in the <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#pub/citref"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept>.</source>
<seg-source><mrk mid="0" mtype="seg">Another tool available to you is the LOCK TABLE statement.</mrk><mrk mid="1" mtype="seg"> A transaction can attempt to lock a table in exclusive mode when it starts to prevent other transactions from getting shared locks on a table.</mrk><mrk mid="2" mtype="seg"> For more information, see "LOCK TABLE statement" in the <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#pub/citref"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept>.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Another tool available to you is the LOCK TABLE statement.</mrk><mrk mid="1" mtype="seg"> A transaction can attempt to lock a table in exclusive mode when it starts to prevent other transactions from getting shared locks on a table.</mrk><mrk mid="2" mtype="seg"> For more information, see "LOCK TABLE statement" in the <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#pub/citref"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept>.</mrk></target>
</trans-unit>
</body>
</file>
</xliff>
