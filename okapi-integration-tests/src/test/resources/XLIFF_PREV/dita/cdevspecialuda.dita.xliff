<?xml version="1.0" encoding="UTF-8"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:okp="okapi-framework:xliff-extensions" xmlns:its="http://www.w3.org/2005/11/its" xmlns:itsxlf="http://www.w3.org/ns/its-xliff/" its:version="2.0">
<file original="cdevspecialuda.dita" source-language="en" target-language="fr" datatype="xml" okp:inputEncoding="utf-8" okp:configId="/home/jimh/Code/Okapi/okapi/okapi/filters/xmlstream/target/classes/net/sf/okapi/filters/xmlstream/dita.yml">
<header><tool tool-id="okapi" tool-name="okapi-tests" tool-version="M29" tool-company="okapi"></tool></header>
<body>
<trans-unit id="tu1">
<source xml:lang="en">Programming user-defined aggregates</source>
<seg-source><mrk mid="0" mtype="seg">Programming user-defined aggregates</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Programming user-defined aggregates</mrk></target>
</trans-unit>
<trans-unit id="tu2">
<source xml:lang="en"><bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> allows you to create custom aggregate operators, called user-defined aggregates (UDAs).</source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> allows you to create custom aggregate operators, called user-defined aggregates (UDAs).</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> allows you to create custom aggregate operators, called user-defined aggregates (UDAs).</mrk></target>
</trans-unit>
<trans-unit id="tu3">
<source xml:lang="en">aggregates</source>
<seg-source><mrk mid="0" mtype="seg">aggregates</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">aggregates</mrk></target>
</trans-unit>
<trans-unit id="tu4">
<source xml:lang="en">user-defined</source>
<seg-source><mrk mid="0" mtype="seg">user-defined</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">user-defined</mrk></target>
</trans-unit>
<trans-unit id="tu5">
<source xml:lang="en">user-defined aggregates</source>
<seg-source><mrk mid="0" mtype="seg">user-defined aggregates</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">user-defined aggregates</mrk></target>
</trans-unit>
<trans-unit id="tu6">
<source xml:lang="en">programming</source>
<seg-source><mrk mid="0" mtype="seg">programming</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">programming</mrk></target>
</trans-unit>
<trans-unit id="tu7">
<source xml:lang="en">A UDA is a Java class that implements the <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>org.apache.derby.agg.Aggregator<ept id="1">&lt;/i&gt;</ept> interface.</source>
<seg-source><mrk mid="0" mtype="seg">A UDA is a Java class that implements the <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>org.apache.derby.agg.Aggregator<ept id="1">&lt;/i&gt;</ept> interface.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">A UDA is a Java class that implements the <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>org.apache.derby.agg.Aggregator<ept id="1">&lt;/i&gt;</ept> interface.</mrk></target>
</trans-unit>
<trans-unit id="tu8">
<source xml:lang="en">The <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>org.apache.derby.agg.Aggregator<ept id="1">&lt;/i&gt;</ept> interface extends <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>java.io.Serializable<ept id="2">&lt;/i&gt;</ept>, so you must make sure that all of the state of your UDA is serializable. A UDA may be serialized to disk when it performs grouped aggregation over a large number of groups. That is, intermediate results may be serialized to disk for a query like the following:</source>
<seg-source><mrk mid="0" mtype="seg">The <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>org.apache.derby.agg.Aggregator<ept id="1">&lt;/i&gt;</ept> interface extends <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>java.io.Serializable<ept id="2">&lt;/i&gt;</ept>, so you must make sure that all of the state of your UDA is serializable.</mrk><mrk mid="1" mtype="seg"> A UDA may be serialized to disk when it performs grouped aggregation over a large number of groups.</mrk><mrk mid="2" mtype="seg"> That is, intermediate results may be serialized to disk for a query like the following:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">The <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>org.apache.derby.agg.Aggregator<ept id="1">&lt;/i&gt;</ept> interface extends <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>java.io.Serializable<ept id="2">&lt;/i&gt;</ept>, so you must make sure that all of the state of your UDA is serializable.</mrk><mrk mid="1" mtype="seg"> A UDA may be serialized to disk when it performs grouped aggregation over a large number of groups.</mrk><mrk mid="2" mtype="seg"> That is, intermediate results may be serialized to disk for a query like the following:</mrk></target>
</trans-unit>
<trans-unit id="tu9">
<source xml:lang="en">SELECT a, myAggregate( b ) FROM myTable GROUP BY a</source>
<seg-source><mrk mid="0" mtype="seg">SELECT a, myAggregate( b ) FROM myTable GROUP BY a</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">SELECT a, myAggregate( b ) FROM myTable GROUP BY a</mrk></target>
</trans-unit>
<trans-unit id="tu10">
<source xml:lang="en">The serialization will fail if the UDA contains non-serializable fields.</source>
<seg-source><mrk mid="0" mtype="seg">The serialization will fail if the UDA contains non-serializable fields.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">The serialization will fail if the UDA contains non-serializable fields.</mrk></target>
</trans-unit>
<trans-unit id="tu11">
<source xml:lang="en">The following class provides an aggregate that computes the median value from a list of objects. This is a generic class. Its parameter must be a linear (<bpt id="1" ctype="x-i">&lt;i&gt;</bpt>Comparable<ept id="1">&lt;/i&gt;</ept>) type.</source>
<seg-source><mrk mid="0" mtype="seg">The following class provides an aggregate that computes the median value from a list of objects.</mrk><mrk mid="1" mtype="seg"> This is a generic class.</mrk><mrk mid="2" mtype="seg"> Its parameter must be a linear (<bpt id="1" ctype="x-i">&lt;i&gt;</bpt>Comparable<ept id="1">&lt;/i&gt;</ept>) type.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">The following class provides an aggregate that computes the median value from a list of objects.</mrk><mrk mid="1" mtype="seg"> This is a generic class.</mrk><mrk mid="2" mtype="seg"> Its parameter must be a linear (<bpt id="1" ctype="x-i">&lt;i&gt;</bpt>Comparable<ept id="1">&lt;/i&gt;</ept>) type.</mrk></target>
</trans-unit>
<trans-unit id="tu12">
<source xml:lang="en">import java.util.ArrayList; import java.util.Collections; import org.apache.derby.agg.Aggregator; public class Median&lt;V extends Comparable&lt;V&gt;&gt; implements Aggregator&lt;V,V,Median&lt;V&gt;&gt; { private ArrayList&lt;V&gt; _values; public Median() {} public void init() { _values = new ArrayList&lt;V&gt;(); } public void accumulate( V value ) { _values.add( value ); } public void merge( Median&lt;V&gt; other ) { _values.addAll( other._values ); } public V terminate() { Collections.sort( _values ); int count = _values.size(); if ( count == 0 ) { return null; } else { return _values.get( count/2 ); } } }</source>
<seg-source><mrk mid="0" mtype="seg">import java.util.ArrayList; import java.util.Collections; import org.apache.derby.agg.Aggregator; public class Median&lt;V extends Comparable&lt;V&gt;&gt; implements Aggregator&lt;V,V,Median&lt;V&gt;&gt; { private ArrayList&lt;V&gt; _values; public Median() {} public void init() { _values = new ArrayList&lt;V&gt;(); } public void accumulate( V value ) { _values.add( value ); } public void merge( Median&lt;V&gt; other ) { _values.addAll( other._values ); } public V terminate() { Collections.sort( _values ); int count = _values.size(); if ( count == 0 ) { return null; } else { return _values.get( count/2 ); } } }</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">import java.util.ArrayList; import java.util.Collections; import org.apache.derby.agg.Aggregator; public class Median&lt;V extends Comparable&lt;V&gt;&gt; implements Aggregator&lt;V,V,Median&lt;V&gt;&gt; { private ArrayList&lt;V&gt; _values; public Median() {} public void init() { _values = new ArrayList&lt;V&gt;(); } public void accumulate( V value ) { _values.add( value ); } public void merge( Median&lt;V&gt; other ) { _values.addAll( other._values ); } public V terminate() { Collections.sort( _values ); int count = _values.size(); if ( count == 0 ) { return null; } else { return _values.get( count/2 ); } } }</mrk></target>
</trans-unit>
<trans-unit id="tu13">
<source xml:lang="en">Using this generic class, we can declare UDAs for all of the sortable <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> data types. For example:</source>
<seg-source><mrk mid="0" mtype="seg">Using this generic class, we can declare UDAs for all of the sortable <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> data types.</mrk><mrk mid="1" mtype="seg"> For example:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Using this generic class, we can declare UDAs for all of the sortable <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> data types.</mrk><mrk mid="1" mtype="seg"> For example:</mrk></target>
</trans-unit>
<trans-unit id="tu14">
<source xml:lang="en"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>create derby aggregate intMedian for int external name 'Median'; create derby aggregate varcharMedian for varchar( 32672 ) external name 'Median';<ept id="1">&lt;/b&gt;</ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>create derby aggregate intMedian for int external name 'Median'; create derby aggregate varcharMedian for varchar( 32672 ) external name 'Median';<ept id="1">&lt;/b&gt;</ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>create derby aggregate intMedian for int external name 'Median'; create derby aggregate varcharMedian for varchar( 32672 ) external name 'Median';<ept id="1">&lt;/b&gt;</ept></mrk></target>
</trans-unit>
<trans-unit id="tu15">
<source xml:lang="en">We can then use these UDAs just like built-in <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> aggregates:</source>
<seg-source><mrk mid="0" mtype="seg">We can then use these UDAs just like built-in <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> aggregates:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">We can then use these UDAs just like built-in <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> aggregates:</mrk></target>
</trans-unit>
<trans-unit id="tu16">
<source xml:lang="en"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>create table intValues( a int, b int ); create table varcharValues( a int, b varchar( 32672 ) ); insert into intValues values ( 1, 1 ), ( 1, 10 ), ( 1, 100 ), ( 1, 1000 ), ( 2, 5 ), ( 2, 50 ), ( 2, 500 ), ( 2, 5000 ); insert into varcharValues values ( 1, 'a' ), ( 1, 'ab' ), ( 1, 'abc' ), ( 2, 'a' ), ( 2, 'aa' ), ( 2, 'aaa' ); select a, intMedian( b ) from intValues group by a;<ept id="1">&lt;/b&gt;</ept> <bpt id="2" ctype="x-systemoutput">&lt;systemoutput&gt;</bpt>A |2 ----------------------- 1 |100 2 |500 <ept id="2">&lt;/systemoutput&gt;</ept> <bpt id="3" ctype="x-b">&lt;b&gt;</bpt>select varcharMedian( b ) from varcharValues;<ept id="3">&lt;/b&gt;</ept> <bpt id="4" ctype="x-systemoutput">&lt;systemoutput&gt;</bpt>1 --- aaa<ept id="4">&lt;/systemoutput&gt;</ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>create table intValues( a int, b int ); create table varcharValues( a int, b varchar( 32672 ) ); insert into intValues values ( 1, 1 ), ( 1, 10 ), ( 1, 100 ), ( 1, 1000 ), ( 2, 5 ), ( 2, 50 ), ( 2, 500 ), ( 2, 5000 ); insert into varcharValues values ( 1, 'a' ), ( 1, 'ab' ), ( 1, 'abc' ), ( 2, 'a' ), ( 2, 'aa' ), ( 2, 'aaa' ); select a, intMedian( b ) from intValues group by a;<ept id="1">&lt;/b&gt;</ept> <bpt id="2" ctype="x-systemoutput">&lt;systemoutput&gt;</bpt>A |2 ----------------------- 1 |100 2 |500 <ept id="2">&lt;/systemoutput&gt;</ept> <bpt id="3" ctype="x-b">&lt;b&gt;</bpt>select varcharMedian( b ) from varcharValues;<ept id="3">&lt;/b&gt;</ept> <bpt id="4" ctype="x-systemoutput">&lt;systemoutput&gt;</bpt>1 --- aaa<ept id="4">&lt;/systemoutput&gt;</ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>create table intValues( a int, b int ); create table varcharValues( a int, b varchar( 32672 ) ); insert into intValues values ( 1, 1 ), ( 1, 10 ), ( 1, 100 ), ( 1, 1000 ), ( 2, 5 ), ( 2, 50 ), ( 2, 500 ), ( 2, 5000 ); insert into varcharValues values ( 1, 'a' ), ( 1, 'ab' ), ( 1, 'abc' ), ( 2, 'a' ), ( 2, 'aa' ), ( 2, 'aaa' ); select a, intMedian( b ) from intValues group by a;<ept id="1">&lt;/b&gt;</ept> <bpt id="2" ctype="x-systemoutput">&lt;systemoutput&gt;</bpt>A |2 ----------------------- 1 |100 2 |500 <ept id="2">&lt;/systemoutput&gt;</ept> <bpt id="3" ctype="x-b">&lt;b&gt;</bpt>select varcharMedian( b ) from varcharValues;<ept id="3">&lt;/b&gt;</ept> <bpt id="4" ctype="x-systemoutput">&lt;systemoutput&gt;</bpt>1 --- aaa<ept id="4">&lt;/systemoutput&gt;</ept></mrk></target>
</trans-unit>
<trans-unit id="tu17">
<source xml:lang="en">See "CREATE DERBY AGGREGATE statement" in the <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#pub/citref"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> for more information.</source>
<seg-source><mrk mid="0" mtype="seg">See "CREATE DERBY AGGREGATE statement" in the <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#pub/citref"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> for more information.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">See "CREATE DERBY AGGREGATE statement" in the <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#pub/citref"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> for more information.</mrk></target>
</trans-unit>
</body>
</file>
</xliff>
