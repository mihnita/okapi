<?xml version="1.0" encoding="UTF-8"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:okp="okapi-framework:xliff-extensions" xmlns:its="http://www.w3.org/2005/11/its" xmlns:itsxlf="http://www.w3.org/ns/its-xliff/" its:version="2.0">
<file original="crefjavstateautogen.dita" source-language="en" target-language="fr" datatype="xml" okp:inputEncoding="utf-8" okp:configId="/home/jimh/Code/Okapi/okapi/okapi/filters/xmlstream/target/classes/net/sf/okapi/filters/xmlstream/dita.yml">
<header><tool tool-id="okapi" tool-name="okapi-tests" tool-version="M29" tool-company="okapi"></tool></header>
<body>
<trans-unit id="tu1">
<source xml:lang="en">Autogenerated keys</source>
<seg-source><mrk mid="0" mtype="seg">Autogenerated keys</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Autogenerated keys</mrk></target>
</trans-unit>
<trans-unit id="tu2">
<source xml:lang="en">autogenerated keys</source>
<seg-source><mrk mid="0" mtype="seg">autogenerated keys</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">autogenerated keys</mrk></target>
</trans-unit>
<trans-unit id="tu3">
<source xml:lang="en">JDBC's auto-generated keys feature provides a way to retrieve values from columns that are part of an index or have a default value assigned. <bpt id="1" ctype="x-ph">&lt;ph
conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> supports the auto-increment feature, which allows users to create columns in tables for which the database system automatically assigns increasing integer values. Users can call the method <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>Statement.getGeneratedKeys<ept id="2">&lt;/i&gt;</ept> to retrieve the value of such a column. This method returns a <bpt id="3" ctype="x-i">&lt;i&gt;</bpt>ResultSet<ept id="3">&lt;/i&gt;</ept> object with a column for the automatically generated key. The <bpt id="4" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="4">&lt;/ph&gt;</ept> implementation of <bpt id="5" ctype="x-i">&lt;i&gt;</bpt>Statement.getGeneratedKeys<ept id="5">&lt;/i&gt;</ept> returns meaningful results only if the last statement was a single-row insert statement. If it was a multi-row insert, <bpt id="6" ctype="x-i">&lt;i&gt;</bpt>Statement.getGeneratedKeys<ept id="6">&lt;/i&gt;</ept> will return a result set with only a single row, even though it should return one row for each inserted row.</source>
<seg-source><mrk mid="0" mtype="seg">JDBC's auto-generated keys feature provides a way to retrieve values from columns that are part of an index or have a default value assigned.</mrk><mrk mid="1" mtype="seg"> <bpt id="1" ctype="x-ph">&lt;ph
conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> supports the auto-increment feature, which allows users to create columns in tables for which the database system automatically assigns increasing integer values.</mrk><mrk mid="2" mtype="seg"> Users can call the method <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>Statement.getGeneratedKeys<ept id="2">&lt;/i&gt;</ept> to retrieve the value of such a column.</mrk><mrk mid="3" mtype="seg"> This method returns a <bpt id="3" ctype="x-i">&lt;i&gt;</bpt>ResultSet<ept id="3">&lt;/i&gt;</ept> object with a column for the automatically generated key.</mrk><mrk mid="4" mtype="seg"> The <bpt id="4" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="4">&lt;/ph&gt;</ept> implementation of <bpt id="5" ctype="x-i">&lt;i&gt;</bpt>Statement.getGeneratedKeys<ept id="5">&lt;/i&gt;</ept> returns meaningful results only if the last statement was a single-row insert statement.</mrk><mrk mid="5" mtype="seg"> If it was a multi-row insert, <bpt id="6" ctype="x-i">&lt;i&gt;</bpt>Statement.getGeneratedKeys<ept id="6">&lt;/i&gt;</ept> will return a result set with only a single row, even though it should return one row for each inserted row.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">JDBC's auto-generated keys feature provides a way to retrieve values from columns that are part of an index or have a default value assigned.</mrk><mrk mid="1" mtype="seg"> <bpt id="1" ctype="x-ph">&lt;ph
conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> supports the auto-increment feature, which allows users to create columns in tables for which the database system automatically assigns increasing integer values.</mrk><mrk mid="2" mtype="seg"> Users can call the method <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>Statement.getGeneratedKeys<ept id="2">&lt;/i&gt;</ept> to retrieve the value of such a column.</mrk><mrk mid="3" mtype="seg"> This method returns a <bpt id="3" ctype="x-i">&lt;i&gt;</bpt>ResultSet<ept id="3">&lt;/i&gt;</ept> object with a column for the automatically generated key.</mrk><mrk mid="4" mtype="seg"> The <bpt id="4" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="4">&lt;/ph&gt;</ept> implementation of <bpt id="5" ctype="x-i">&lt;i&gt;</bpt>Statement.getGeneratedKeys<ept id="5">&lt;/i&gt;</ept> returns meaningful results only if the last statement was a single-row insert statement.</mrk><mrk mid="5" mtype="seg"> If it was a multi-row insert, <bpt id="6" ctype="x-i">&lt;i&gt;</bpt>Statement.getGeneratedKeys<ept id="6">&lt;/i&gt;</ept> will return a result set with only a single row, even though it should return one row for each inserted row.</mrk></target>
</trans-unit>
<trans-unit id="tu4">
<source xml:lang="en">Calling <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>ResultSet.getMetaData<ept id="1">&lt;/i&gt;</ept> on the <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>ResultSet<ept id="2">&lt;/i&gt;</ept> object returned by <bpt id="3" ctype="x-i">&lt;i&gt;</bpt>getGeneratedKeys<ept id="3">&lt;/i&gt;</ept> produces a <bpt id="4" ctype="x-i">&lt;i&gt;</bpt>ResultSetMetaData<ept id="4">&lt;/i&gt;</ept> object that is similar to that returned by <bpt id="5" ctype="x-xref">&lt;xref href="rrefidentityvallocal.dita#rrefidentityvallocal"&gt;</bpt>IDENTITY_VAL_LOCAL<ept id="5">&lt;/xref&gt;</ept>.</source>
<seg-source><mrk mid="0" mtype="seg">Calling <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>ResultSet.getMetaData<ept id="1">&lt;/i&gt;</ept> on the <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>ResultSet<ept id="2">&lt;/i&gt;</ept> object returned by <bpt id="3" ctype="x-i">&lt;i&gt;</bpt>getGeneratedKeys<ept id="3">&lt;/i&gt;</ept> produces a <bpt id="4" ctype="x-i">&lt;i&gt;</bpt>ResultSetMetaData<ept id="4">&lt;/i&gt;</ept> object that is similar to that returned by <bpt id="5" ctype="x-xref">&lt;xref href="rrefidentityvallocal.dita#rrefidentityvallocal"&gt;</bpt>IDENTITY_VAL_LOCAL<ept id="5">&lt;/xref&gt;</ept>.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Calling <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>ResultSet.getMetaData<ept id="1">&lt;/i&gt;</ept> on the <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>ResultSet<ept id="2">&lt;/i&gt;</ept> object returned by <bpt id="3" ctype="x-i">&lt;i&gt;</bpt>getGeneratedKeys<ept id="3">&lt;/i&gt;</ept> produces a <bpt id="4" ctype="x-i">&lt;i&gt;</bpt>ResultSetMetaData<ept id="4">&lt;/i&gt;</ept> object that is similar to that returned by <bpt id="5" ctype="x-xref">&lt;xref href="rrefidentityvallocal.dita#rrefidentityvallocal"&gt;</bpt>IDENTITY_VAL_LOCAL<ept id="5">&lt;/xref&gt;</ept>.</mrk></target>
</trans-unit>
<trans-unit id="tu5">
<source xml:lang="en">Users can indicate that auto-generated columns should be made available for retrieval by passing one of the following values as a second argument to the <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>Connection.prepareStatement<ept id="1">&lt;/i&gt;</ept>, <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>Statement.execute<ept id="2">&lt;/i&gt;</ept>, or <bpt id="3" ctype="x-i">&lt;i&gt;</bpt>Statement.executeUpdate<ept id="3">&lt;/i&gt;</ept> methods:</source>
<seg-source><mrk mid="0" mtype="seg">Users can indicate that auto-generated columns should be made available for retrieval by passing one of the following values as a second argument to the <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>Connection.prepareStatement<ept id="1">&lt;/i&gt;</ept>, <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>Statement.execute<ept id="2">&lt;/i&gt;</ept>, or <bpt id="3" ctype="x-i">&lt;i&gt;</bpt>Statement.executeUpdate<ept id="3">&lt;/i&gt;</ept> methods:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Users can indicate that auto-generated columns should be made available for retrieval by passing one of the following values as a second argument to the <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>Connection.prepareStatement<ept id="1">&lt;/i&gt;</ept>, <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>Statement.execute<ept id="2">&lt;/i&gt;</ept>, or <bpt id="3" ctype="x-i">&lt;i&gt;</bpt>Statement.executeUpdate<ept id="3">&lt;/i&gt;</ept> methods:</mrk></target>
</trans-unit>
<trans-unit id="tu6">
<source xml:lang="en">A constant indicating that auto-generated keys should be made available. The specific constant to use is <bpt id="1" ctype="x-codeph">&lt;codeph&gt;</bpt>Statement.RETURN_GENERATED_KEYS<ept id="1">&lt;/codeph&gt;</ept>.</source>
<seg-source><mrk mid="0" mtype="seg">A constant indicating that auto-generated keys should be made available.</mrk><mrk mid="1" mtype="seg"> The specific constant to use is <bpt id="1" ctype="x-codeph">&lt;codeph&gt;</bpt>Statement.RETURN_GENERATED_KEYS<ept id="1">&lt;/codeph&gt;</ept>.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">A constant indicating that auto-generated keys should be made available.</mrk><mrk mid="1" mtype="seg"> The specific constant to use is <bpt id="1" ctype="x-codeph">&lt;codeph&gt;</bpt>Statement.RETURN_GENERATED_KEYS<ept id="1">&lt;/codeph&gt;</ept>.</mrk></target>
</trans-unit>
<trans-unit id="tu7">
<source xml:lang="en">An array of the names of the columns in the inserted row that should be made available. If any column name in the array does <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>not<ept id="1">&lt;/i&gt;</ept> designate an auto-increment column, <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> will throw an error with the <bpt id="3" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="3">&lt;/ph&gt;</ept> embedded driver. With the client driver, the one element column name is ignored currently and the value returned corresponds to the identity column. To ensure compatibility with future changes an application should ensure the column described is the identity column. If the column name corresponds to another column or a non-existent column then future changes may result in a value for a different column being returned or an exception being thrown.</source>
<seg-source><mrk mid="0" mtype="seg">An array of the names of the columns in the inserted row that should be made available.</mrk><mrk mid="1" mtype="seg"> If any column name in the array does <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>not<ept id="1">&lt;/i&gt;</ept> designate an auto-increment column, <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> will throw an error with the <bpt id="3" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="3">&lt;/ph&gt;</ept> embedded driver.</mrk><mrk mid="2" mtype="seg"> With the client driver, the one element column name is ignored currently and the value returned corresponds to the identity column.</mrk><mrk mid="3" mtype="seg"> To ensure compatibility with future changes an application should ensure the column described is the identity column.</mrk><mrk mid="4" mtype="seg"> If the column name corresponds to another column or a non-existent column then future changes may result in a value for a different column being returned or an exception being thrown.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">An array of the names of the columns in the inserted row that should be made available.</mrk><mrk mid="1" mtype="seg"> If any column name in the array does <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>not<ept id="1">&lt;/i&gt;</ept> designate an auto-increment column, <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> will throw an error with the <bpt id="3" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="3">&lt;/ph&gt;</ept> embedded driver.</mrk><mrk mid="2" mtype="seg"> With the client driver, the one element column name is ignored currently and the value returned corresponds to the identity column.</mrk><mrk mid="3" mtype="seg"> To ensure compatibility with future changes an application should ensure the column described is the identity column.</mrk><mrk mid="4" mtype="seg"> If the column name corresponds to another column or a non-existent column then future changes may result in a value for a different column being returned or an exception being thrown.</mrk></target>
</trans-unit>
<trans-unit id="tu8">
<source xml:lang="en">An array of the positions of the columns in the inserted row that should be made available. If any column position in the array does <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>not<ept id="1">&lt;/i&gt;</ept> correlate to an auto-increment column, <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> will throw an error with the <bpt id="3" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="3">&lt;/ph&gt;</ept> embedded driver. With the client driver, the one element position array is ignored currently and the value returned corresponds to the identity column. To ensure compatibility with future changes an application should ensure the column described is the identity column. If the position corresponds to another column or a non-existent column then future changes may result in a value for a different column being returned or an exception being thrown.</source>
<seg-source><mrk mid="0" mtype="seg">An array of the positions of the columns in the inserted row that should be made available.</mrk><mrk mid="1" mtype="seg"> If any column position in the array does <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>not<ept id="1">&lt;/i&gt;</ept> correlate to an auto-increment column, <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> will throw an error with the <bpt id="3" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="3">&lt;/ph&gt;</ept> embedded driver.</mrk><mrk mid="2" mtype="seg"> With the client driver, the one element position array is ignored currently and the value returned corresponds to the identity column.</mrk><mrk mid="3" mtype="seg"> To ensure compatibility with future changes an application should ensure the column described is the identity column.</mrk><mrk mid="4" mtype="seg"> If the position corresponds to another column or a non-existent column then future changes may result in a value for a different column being returned or an exception being thrown.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">An array of the positions of the columns in the inserted row that should be made available.</mrk><mrk mid="1" mtype="seg"> If any column position in the array does <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>not<ept id="1">&lt;/i&gt;</ept> correlate to an auto-increment column, <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> will throw an error with the <bpt id="3" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="3">&lt;/ph&gt;</ept> embedded driver.</mrk><mrk mid="2" mtype="seg"> With the client driver, the one element position array is ignored currently and the value returned corresponds to the identity column.</mrk><mrk mid="3" mtype="seg"> To ensure compatibility with future changes an application should ensure the column described is the identity column.</mrk><mrk mid="4" mtype="seg"> If the position corresponds to another column or a non-existent column then future changes may result in a value for a different column being returned or an exception being thrown.</mrk></target>
</trans-unit>
<trans-unit id="tu9">
<source xml:lang="en">Example</source>
<seg-source><mrk mid="0" mtype="seg">Example</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Example</mrk></target>
</trans-unit>
<trans-unit id="tu10">
<source xml:lang="en">Assume that we have a table TABLE1 defined as follows:</source>
<seg-source><mrk mid="0" mtype="seg">Assume that we have a table TABLE1 defined as follows:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Assume that we have a table TABLE1 defined as follows:</mrk></target>
</trans-unit>
<trans-unit id="tu11">
<source xml:lang="en">CREATE TABLE TABLE1 (C11 int, C12 int GENERATED ALWAYS AS IDENTITY)</source>
<seg-source><mrk mid="0" mtype="seg">CREATE TABLE TABLE1 (C11 int, C12 int GENERATED ALWAYS AS IDENTITY)</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">CREATE TABLE TABLE1 (C11 int, C12 int GENERATED ALWAYS AS IDENTITY)</mrk></target>
</trans-unit>
<trans-unit id="tu12">
<source xml:lang="en">The following three code fragments will all do the same thing: that is, they will create a <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>ResultSet<ept id="1">&lt;/i&gt;</ept> that contains the value of <bpt id="2" ctype="x-codeph">&lt;codeph&gt;</bpt>C12<ept id="2">&lt;/codeph&gt;</ept> that is inserted into TABLE1.</source>
<seg-source><mrk mid="0" mtype="seg">The following three code fragments will all do the same thing: that is, they will create a <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>ResultSet<ept id="1">&lt;/i&gt;</ept> that contains the value of <bpt id="2" ctype="x-codeph">&lt;codeph&gt;</bpt>C12<ept id="2">&lt;/codeph&gt;</ept> that is inserted into TABLE1.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">The following three code fragments will all do the same thing: that is, they will create a <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>ResultSet<ept id="1">&lt;/i&gt;</ept> that contains the value of <bpt id="2" ctype="x-codeph">&lt;codeph&gt;</bpt>C12<ept id="2">&lt;/codeph&gt;</ept> that is inserted into TABLE1.</mrk></target>
</trans-unit>
<trans-unit id="tu13">
<source xml:lang="en">Code fragment 1:</source>
<seg-source><mrk mid="0" mtype="seg">Code fragment 1:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Code fragment 1:</mrk></target>
</trans-unit>
<trans-unit id="tu14">
<source xml:lang="en">Statement stmt = conn.createStatement(); stmt.execute( "INSERT INTO TABLE1 (C11) VALUES (1)", Statement.RETURN_GENERATED_KEYS); ResultSet rs = stmt.getGeneratedKeys();</source>
<seg-source><mrk mid="0" mtype="seg">Statement stmt = conn.createStatement(); stmt.execute( "INSERT INTO TABLE1 (C11) VALUES (1)", Statement.RETURN_GENERATED_KEYS); ResultSet rs = stmt.getGeneratedKeys();</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Statement stmt = conn.createStatement(); stmt.execute( "INSERT INTO TABLE1 (C11) VALUES (1)", Statement.RETURN_GENERATED_KEYS); ResultSet rs = stmt.getGeneratedKeys();</mrk></target>
</trans-unit>
<trans-unit id="tu15">
<source xml:lang="en">Code fragment 2:</source>
<seg-source><mrk mid="0" mtype="seg">Code fragment 2:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Code fragment 2:</mrk></target>
</trans-unit>
<trans-unit id="tu16">
<source xml:lang="en">Statement stmt = conn.createStatement(); String [] colNames = new String [] { "C12" }; stmt.execute( "INSERT INTO TABLE1 (C11) VALUES (1)", colNames); ResultSet rs = stmt.getGeneratedKeys();</source>
<seg-source><mrk mid="0" mtype="seg">Statement stmt = conn.createStatement(); String [] colNames = new String [] { "C12" }; stmt.execute( "INSERT INTO TABLE1 (C11) VALUES (1)", colNames); ResultSet rs = stmt.getGeneratedKeys();</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Statement stmt = conn.createStatement(); String [] colNames = new String [] { "C12" }; stmt.execute( "INSERT INTO TABLE1 (C11) VALUES (1)", colNames); ResultSet rs = stmt.getGeneratedKeys();</mrk></target>
</trans-unit>
<trans-unit id="tu17">
<source xml:lang="en">Code fragment 3:</source>
<seg-source><mrk mid="0" mtype="seg">Code fragment 3:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Code fragment 3:</mrk></target>
</trans-unit>
<trans-unit id="tu18">
<source xml:lang="en">Statement stmt = conn.createStatement(); int [] colIndexes = new int [] { 2 }; stmt.execute( "INSERT INTO TABLE1 (C11) VALUES (1)", colIndexes); ResultSet rs = stmt.getGeneratedKeys();</source>
<seg-source><mrk mid="0" mtype="seg">Statement stmt = conn.createStatement(); int [] colIndexes = new int [] { 2 }; stmt.execute( "INSERT INTO TABLE1 (C11) VALUES (1)", colIndexes); ResultSet rs = stmt.getGeneratedKeys();</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Statement stmt = conn.createStatement(); int [] colIndexes = new int [] { 2 }; stmt.execute( "INSERT INTO TABLE1 (C11) VALUES (1)", colIndexes); ResultSet rs = stmt.getGeneratedKeys();</mrk></target>
</trans-unit>
<trans-unit id="tu19">
<source xml:lang="en">If there is no indication that auto-generated columns should be made available for retrieval, a call to <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>Statement.getGeneratedKeys<ept id="1">&lt;/i&gt;</ept> will return a null <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>ResultSet<ept id="2">&lt;/i&gt;</ept>.</source>
<seg-source><mrk mid="0" mtype="seg">If there is no indication that auto-generated columns should be made available for retrieval, a call to <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>Statement.getGeneratedKeys<ept id="1">&lt;/i&gt;</ept> will return a null <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>ResultSet<ept id="2">&lt;/i&gt;</ept>.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">If there is no indication that auto-generated columns should be made available for retrieval, a call to <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>Statement.getGeneratedKeys<ept id="1">&lt;/i&gt;</ept> will return a null <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>ResultSet<ept id="2">&lt;/i&gt;</ept>.</mrk></target>
</trans-unit>
</body>
</file>
</xliff>
