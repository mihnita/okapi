<?xml version="1.0" encoding="UTF-8"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:okp="okapi-framework:xliff-extensions" xmlns:its="http://www.w3.org/2005/11/its" xmlns:itsxlf="http://www.w3.org/ns/its-xliff/" its:version="2.0">
<file original="rreffuncxmlexists.dita" source-language="en" target-language="fr" datatype="xml" okp:inputEncoding="utf-8" okp:configId="/home/jimh/Code/Okapi/okapi/okapi/filters/xmlstream/target/classes/net/sf/okapi/filters/xmlstream/dita.yml">
<header><tool tool-id="okapi" tool-name="okapi-tests" tool-version="M29" tool-company="okapi"></tool></header>
<body>
<trans-unit id="tu1">
<source xml:lang="en">XMLEXISTS operator</source>
<seg-source><mrk mid="0" mtype="seg">XMLEXISTS operator</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">XMLEXISTS operator</mrk></target>
</trans-unit>
<trans-unit id="tu2">
<source xml:lang="en">XMLEXISTS is an SQL/XML operator that you can use to query XML values in SQL.</source>
<seg-source><mrk mid="0" mtype="seg">XMLEXISTS is an SQL/XML operator that you can use to query XML values in SQL.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">XMLEXISTS is an SQL/XML operator that you can use to query XML values in SQL.</mrk></target>
</trans-unit>
<trans-unit id="tu3">
<source xml:lang="en">XMLEXISTS operator</source>
<seg-source><mrk mid="0" mtype="seg">XMLEXISTS operator</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">XMLEXISTS operator</mrk></target>
</trans-unit>
<trans-unit id="tu4">
<source xml:lang="en">operators</source>
<seg-source><mrk mid="0" mtype="seg">operators</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">operators</mrk></target>
</trans-unit>
<trans-unit id="tu5">
<source xml:lang="en">XMLEXISTS</source>
<seg-source><mrk mid="0" mtype="seg">XMLEXISTS</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">XMLEXISTS</mrk></target>
</trans-unit>
<trans-unit id="tu6">
<source xml:lang="en">XML</source>
<seg-source><mrk mid="0" mtype="seg">XML</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">XML</mrk></target>
</trans-unit>
<trans-unit id="tu7">
<source xml:lang="en">operators, XMLEXISTS</source>
<seg-source><mrk mid="0" mtype="seg">operators, XMLEXISTS</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">operators, XMLEXISTS</mrk></target>
</trans-unit>
<trans-unit id="tu8">
<source xml:lang="en">The XMLEXISTS operator has two arguments, an XML query expression and a <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> XML value.</source>
<seg-source><mrk mid="0" mtype="seg">The XMLEXISTS operator has two arguments, an XML query expression and a <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> XML value.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">The XMLEXISTS operator has two arguments, an XML query expression and a <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> XML value.</mrk></target>
</trans-unit>
<trans-unit id="tu9">
<source xml:lang="en">Syntax</source>
<seg-source><mrk mid="0" mtype="seg">Syntax</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Syntax</mrk></target>
</trans-unit>
<trans-unit id="tu10">
<source xml:lang="en"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>XMLEXISTS ( <bpt id="2" ctype="x-varname">&lt;varname&gt;</bpt>xqueryStringLiteral<ept id="2">&lt;/varname&gt;</ept> PASSING BY REF <bpt id="3" ctype="x-varname">&lt;varname&gt;</bpt>xmlValueExpression<ept id="3">&lt;/varname&gt;</ept> [ BY REF ] ) <ept id="1">&lt;/b&gt;</ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>XMLEXISTS ( <bpt id="2" ctype="x-varname">&lt;varname&gt;</bpt>xqueryStringLiteral<ept id="2">&lt;/varname&gt;</ept> PASSING BY REF <bpt id="3" ctype="x-varname">&lt;varname&gt;</bpt>xmlValueExpression<ept id="3">&lt;/varname&gt;</ept> [ BY REF ] ) <ept id="1">&lt;/b&gt;</ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>XMLEXISTS ( <bpt id="2" ctype="x-varname">&lt;varname&gt;</bpt>xqueryStringLiteral<ept id="2">&lt;/varname&gt;</ept> PASSING BY REF <bpt id="3" ctype="x-varname">&lt;varname&gt;</bpt>xmlValueExpression<ept id="3">&lt;/varname&gt;</ept> [ BY REF ] ) <ept id="1">&lt;/b&gt;</ept></mrk></target>
</trans-unit>
<trans-unit id="tu11">
<source xml:lang="en"><bpt id="1" ctype="x-varname">&lt;varname&gt;</bpt>xqueryStringLiteral<ept id="1">&lt;/varname&gt;</ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-varname">&lt;varname&gt;</bpt>xqueryStringLiteral<ept id="1">&lt;/varname&gt;</ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-varname">&lt;varname&gt;</bpt>xqueryStringLiteral<ept id="1">&lt;/varname&gt;</ept></mrk></target>
</trans-unit>
<trans-unit id="tu12">
<source xml:lang="en">Must be specified as a string literal. If this argument is specified as a parameter, an expression that is not a literal, or a literal that is not a string (for example an integer), <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> throws an error. The <bpt id="2" ctype="x-varname">&lt;varname&gt;</bpt>xqueryStringLiteral<ept id="2">&lt;/varname&gt;</ept> argument must also be an XPath expression that is supported by Apache Xalan. <bpt id="3" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="3">&lt;/ph&gt;</ept> uses Apache Xalan to evaluate all XML query expressions. Because Xalan does not support full XQuery, neither does <bpt id="4" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="4">&lt;/ph&gt;</ept>. If Xalan is unable to compile or execute the query argument, <bpt id="5" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="5">&lt;/ph&gt;</ept> catches the error that is thrown by Xalan and throws the error as a SQLException. For more on XPath and XQuery expressions, see these Web sites: <bpt id="6" ctype="x-xref">&lt;xref format="html"
href="http://www.w3.org/TR/xpath"&gt;</bpt>http://www.w3.org/TR/xpath<ept id="6">&lt;/xref&gt;</ept> and <bpt id="7" ctype="x-xref">&lt;xref
format="html" href="http://www.w3.org/TR/xquery/"&gt;</bpt>http://www.w3.org/TR/xquery/<ept id="7">&lt;/xref&gt;</ept>.</source>
<seg-source><mrk mid="0" mtype="seg">Must be specified as a string literal.</mrk><mrk mid="1" mtype="seg"> If this argument is specified as a parameter, an expression that is not a literal, or a literal that is not a string (for example an integer), <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> throws an error.</mrk><mrk mid="2" mtype="seg"> The <bpt id="2" ctype="x-varname">&lt;varname&gt;</bpt>xqueryStringLiteral<ept id="2">&lt;/varname&gt;</ept> argument must also be an XPath expression that is supported by Apache Xalan.</mrk><mrk mid="3" mtype="seg"> <bpt id="3" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="3">&lt;/ph&gt;</ept> uses Apache Xalan to evaluate all XML query expressions.</mrk><mrk mid="4" mtype="seg"> Because Xalan does not support full XQuery, neither does <bpt id="4" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="4">&lt;/ph&gt;</ept>.</mrk><mrk mid="5" mtype="seg"> If Xalan is unable to compile or execute the query argument, <bpt id="5" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="5">&lt;/ph&gt;</ept> catches the error that is thrown by Xalan and throws the error as a SQLException.</mrk><mrk mid="6" mtype="seg"> For more on XPath and XQuery expressions, see these Web sites: <bpt id="6" ctype="x-xref">&lt;xref format="html"
href="http://www.w3.org/TR/xpath"&gt;</bpt>http://www.w3.org/TR/xpath<ept id="6">&lt;/xref&gt;</ept> and <bpt id="7" ctype="x-xref">&lt;xref
format="html" href="http://www.w3.org/TR/xquery/"&gt;</bpt>http://www.w3.org/TR/xquery/<ept id="7">&lt;/xref&gt;</ept>.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Must be specified as a string literal.</mrk><mrk mid="1" mtype="seg"> If this argument is specified as a parameter, an expression that is not a literal, or a literal that is not a string (for example an integer), <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> throws an error.</mrk><mrk mid="2" mtype="seg"> The <bpt id="2" ctype="x-varname">&lt;varname&gt;</bpt>xqueryStringLiteral<ept id="2">&lt;/varname&gt;</ept> argument must also be an XPath expression that is supported by Apache Xalan.</mrk><mrk mid="3" mtype="seg"> <bpt id="3" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="3">&lt;/ph&gt;</ept> uses Apache Xalan to evaluate all XML query expressions.</mrk><mrk mid="4" mtype="seg"> Because Xalan does not support full XQuery, neither does <bpt id="4" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="4">&lt;/ph&gt;</ept>.</mrk><mrk mid="5" mtype="seg"> If Xalan is unable to compile or execute the query argument, <bpt id="5" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="5">&lt;/ph&gt;</ept> catches the error that is thrown by Xalan and throws the error as a SQLException.</mrk><mrk mid="6" mtype="seg"> For more on XPath and XQuery expressions, see these Web sites: <bpt id="6" ctype="x-xref">&lt;xref format="html"
href="http://www.w3.org/TR/xpath"&gt;</bpt>http://www.w3.org/TR/xpath<ept id="6">&lt;/xref&gt;</ept> and <bpt id="7" ctype="x-xref">&lt;xref
format="html" href="http://www.w3.org/TR/xquery/"&gt;</bpt>http://www.w3.org/TR/xquery/<ept id="7">&lt;/xref&gt;</ept>.</mrk></target>
</trans-unit>
<trans-unit id="tu13">
<source xml:lang="en"><bpt id="1" ctype="x-varname">&lt;varname&gt;</bpt>xmlValueExpression<ept id="1">&lt;/varname&gt;</ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-varname">&lt;varname&gt;</bpt>xmlValueExpression<ept id="1">&lt;/varname&gt;</ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-varname">&lt;varname&gt;</bpt>xmlValueExpression<ept id="1">&lt;/varname&gt;</ept></mrk></target>
</trans-unit>
<trans-unit id="tu14">
<source xml:lang="en">Must be an XML data value and must constitute a well-formed SQL/XML document. The <bpt id="1" ctype="x-varname">&lt;varname&gt;</bpt>xmlValueExpression<ept id="1">&lt;/varname&gt;</ept> argument cannot be a parameter. <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> does not perform implicit parsing nor casting of XML values, so use of strings or any other data type results in an error. If the argument is a sequence that is returned by the <bpt id="3" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="3">&lt;/ph&gt;</ept> <bpt id="4" ctype="x-xref">&lt;xref href="rreffuncxmlquery.dita#rreffuncxmlquery"&gt;</bpt><ept id="4">&lt;/xref&gt;</ept>, the argument is accepted if it is a sequence of exactly one node that is a document node. Otherwise <bpt id="5" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="5">&lt;/ph&gt;</ept> throws an error.</source>
<seg-source><mrk mid="0" mtype="seg">Must be an XML data value and must constitute a well-formed SQL/XML document.</mrk><mrk mid="1" mtype="seg"> The <bpt id="1" ctype="x-varname">&lt;varname&gt;</bpt>xmlValueExpression<ept id="1">&lt;/varname&gt;</ept> argument cannot be a parameter.</mrk><mrk mid="2" mtype="seg"> <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> does not perform implicit parsing nor casting of XML values, so use of strings or any other data type results in an error.</mrk><mrk mid="3" mtype="seg"> If the argument is a sequence that is returned by the <bpt id="3" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="3">&lt;/ph&gt;</ept> <bpt id="4" ctype="x-xref">&lt;xref href="rreffuncxmlquery.dita#rreffuncxmlquery"&gt;</bpt><ept id="4">&lt;/xref&gt;</ept>, the argument is accepted if it is a sequence of exactly one node that is a document node.</mrk><mrk mid="4" mtype="seg"> Otherwise <bpt id="5" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="5">&lt;/ph&gt;</ept> throws an error.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Must be an XML data value and must constitute a well-formed SQL/XML document.</mrk><mrk mid="1" mtype="seg"> The <bpt id="1" ctype="x-varname">&lt;varname&gt;</bpt>xmlValueExpression<ept id="1">&lt;/varname&gt;</ept> argument cannot be a parameter.</mrk><mrk mid="2" mtype="seg"> <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> does not perform implicit parsing nor casting of XML values, so use of strings or any other data type results in an error.</mrk><mrk mid="3" mtype="seg"> If the argument is a sequence that is returned by the <bpt id="3" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="3">&lt;/ph&gt;</ept> <bpt id="4" ctype="x-xref">&lt;xref href="rreffuncxmlquery.dita#rreffuncxmlquery"&gt;</bpt><ept id="4">&lt;/xref&gt;</ept>, the argument is accepted if it is a sequence of exactly one node that is a document node.</mrk><mrk mid="4" mtype="seg"> Otherwise <bpt id="5" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="5">&lt;/ph&gt;</ept> throws an error.</mrk></target>
</trans-unit>
<trans-unit id="tu15">
<source xml:lang="en">BY REF</source>
<seg-source><mrk mid="0" mtype="seg">BY REF</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">BY REF</mrk></target>
</trans-unit>
<trans-unit id="tu16">
<source xml:lang="en">Optional keywords that describe the only value passing mechanism supported by <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept>. Since BY REF is also the default passing mechanism, the XMLEXISTS operator behaves the same whether the keywords are present or not. For more information on passing mechanisms, see the SQL/XML specification.</source>
<seg-source><mrk mid="0" mtype="seg">Optional keywords that describe the only value passing mechanism supported by <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept>.</mrk><mrk mid="1" mtype="seg"> Since BY REF is also the default passing mechanism, the XMLEXISTS operator behaves the same whether the keywords are present or not.</mrk><mrk mid="2" mtype="seg"> For more information on passing mechanisms, see the SQL/XML specification.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Optional keywords that describe the only value passing mechanism supported by <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept>.</mrk><mrk mid="1" mtype="seg"> Since BY REF is also the default passing mechanism, the XMLEXISTS operator behaves the same whether the keywords are present or not.</mrk><mrk mid="2" mtype="seg"> For more information on passing mechanisms, see the SQL/XML specification.</mrk></target>
</trans-unit>
<trans-unit id="tu17">
<source xml:lang="en">Operator results and combining with other operators</source>
<seg-source><mrk mid="0" mtype="seg">Operator results and combining with other operators</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Operator results and combining with other operators</mrk></target>
</trans-unit>
<trans-unit id="tu18">
<source xml:lang="en">The result of the XMLEXISTS operator is a SQL boolean value that is based on the results from evaluating the <bpt id="1" ctype="x-varname">&lt;varname&gt;</bpt>xqueryStringLiteral<ept id="1">&lt;/varname&gt;</ept> against the <bpt id="2" ctype="x-varname">&lt;varname&gt;</bpt>xmlValueExpression<ept id="2">&lt;/varname&gt;</ept>. The XMLEXISTS operator returns:</source>
<seg-source><mrk mid="0" mtype="seg">The result of the XMLEXISTS operator is a SQL boolean value that is based on the results from evaluating the <bpt id="1" ctype="x-varname">&lt;varname&gt;</bpt>xqueryStringLiteral<ept id="1">&lt;/varname&gt;</ept> against the <bpt id="2" ctype="x-varname">&lt;varname&gt;</bpt>xmlValueExpression<ept id="2">&lt;/varname&gt;</ept>.</mrk><mrk mid="1" mtype="seg"> The XMLEXISTS operator returns:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">The result of the XMLEXISTS operator is a SQL boolean value that is based on the results from evaluating the <bpt id="1" ctype="x-varname">&lt;varname&gt;</bpt>xqueryStringLiteral<ept id="1">&lt;/varname&gt;</ept> against the <bpt id="2" ctype="x-varname">&lt;varname&gt;</bpt>xmlValueExpression<ept id="2">&lt;/varname&gt;</ept>.</mrk><mrk mid="1" mtype="seg"> The XMLEXISTS operator returns:</mrk></target>
</trans-unit>
<trans-unit id="tu19">
<source xml:lang="en">UNKNOWN</source>
<seg-source><mrk mid="0" mtype="seg">UNKNOWN</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">UNKNOWN</mrk></target>
</trans-unit>
<trans-unit id="tu20">
<source xml:lang="en">When the <bpt id="1" ctype="x-varname">&lt;varname&gt;</bpt>xmlValueExpression<ept id="1">&lt;/varname&gt;</ept> is null.</source>
<seg-source><mrk mid="0" mtype="seg">When the <bpt id="1" ctype="x-varname">&lt;varname&gt;</bpt>xmlValueExpression<ept id="1">&lt;/varname&gt;</ept> is null.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">When the <bpt id="1" ctype="x-varname">&lt;varname&gt;</bpt>xmlValueExpression<ept id="1">&lt;/varname&gt;</ept> is null.</mrk></target>
</trans-unit>
<trans-unit id="tu21">
<source xml:lang="en">TRUE</source>
<seg-source><mrk mid="0" mtype="seg">TRUE</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">TRUE</mrk></target>
</trans-unit>
<trans-unit id="tu22">
<source xml:lang="en">When the evaluation of the specified query expression against the specified <bpt id="1" ctype="x-varname">&lt;varname&gt;</bpt>xmlValueExpression<ept id="1">&lt;/varname&gt;</ept> returns a non-empty sequence of nodes or values.</source>
<seg-source><mrk mid="0" mtype="seg">When the evaluation of the specified query expression against the specified <bpt id="1" ctype="x-varname">&lt;varname&gt;</bpt>xmlValueExpression<ept id="1">&lt;/varname&gt;</ept> returns a non-empty sequence of nodes or values.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">When the evaluation of the specified query expression against the specified <bpt id="1" ctype="x-varname">&lt;varname&gt;</bpt>xmlValueExpression<ept id="1">&lt;/varname&gt;</ept> returns a non-empty sequence of nodes or values.</mrk></target>
</trans-unit>
<trans-unit id="tu23">
<source xml:lang="en">FALSE</source>
<seg-source><mrk mid="0" mtype="seg">FALSE</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">FALSE</mrk></target>
</trans-unit>
<trans-unit id="tu24">
<source xml:lang="en">When evaluation of the specified query expression against the specified <bpt id="1" ctype="x-varname">&lt;varname&gt;</bpt>xmlValueExpression<ept id="1">&lt;/varname&gt;</ept> returns an empty sequence.</source>
<seg-source><mrk mid="0" mtype="seg">When evaluation of the specified query expression against the specified <bpt id="1" ctype="x-varname">&lt;varname&gt;</bpt>xmlValueExpression<ept id="1">&lt;/varname&gt;</ept> returns an empty sequence.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">When evaluation of the specified query expression against the specified <bpt id="1" ctype="x-varname">&lt;varname&gt;</bpt>xmlValueExpression<ept id="1">&lt;/varname&gt;</ept> returns an empty sequence.</mrk></target>
</trans-unit>
<trans-unit id="tu25">
<source xml:lang="en">The XMLEXISTS operator does not return the actual results from the evaluation of the query. You must use the XMLQUERY operator to retrieve the actual results.</source>
<seg-source><mrk mid="0" mtype="seg">The XMLEXISTS operator does not return the actual results from the evaluation of the query.</mrk><mrk mid="1" mtype="seg"> You must use the XMLQUERY operator to retrieve the actual results.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">The XMLEXISTS operator does not return the actual results from the evaluation of the query.</mrk><mrk mid="1" mtype="seg"> You must use the XMLQUERY operator to retrieve the actual results.</mrk></target>
</trans-unit>
<trans-unit id="tu26">
<source xml:lang="en">Since the result of the XMLEXISTS operator is an SQL boolean data type, you can use the XMLEXISTS operator wherever a boolean function is allowed. For example, you can use the XMLEXISTS operator as a check constraint in a table declaration or as a predicate in a WHERE clause.</source>
<seg-source><mrk mid="0" mtype="seg">Since the result of the XMLEXISTS operator is an SQL boolean data type, you can use the XMLEXISTS operator wherever a boolean function is allowed.</mrk><mrk mid="1" mtype="seg"> For example, you can use the XMLEXISTS operator as a check constraint in a table declaration or as a predicate in a WHERE clause.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Since the result of the XMLEXISTS operator is an SQL boolean data type, you can use the XMLEXISTS operator wherever a boolean function is allowed.</mrk><mrk mid="1" mtype="seg"> For example, you can use the XMLEXISTS operator as a check constraint in a table declaration or as a predicate in a WHERE clause.</mrk></target>
</trans-unit>
<trans-unit id="tu27">
<source xml:lang="en">Examples</source>
<seg-source><mrk mid="0" mtype="seg">Examples</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Examples</mrk></target>
</trans-unit>
<trans-unit id="tu28">
<source xml:lang="en">In the <bpt id="1" ctype="x-codeph">&lt;codeph&gt;</bpt>x_table<ept id="1">&lt;/codeph&gt;</ept> table, to determine if the <bpt id="2" ctype="x-codeph">&lt;codeph&gt;</bpt>xcol<ept id="2">&lt;/codeph&gt;</ept> XML column for each row has an element called <bpt id="3" ctype="x-codeph">&lt;codeph&gt;</bpt>student<ept id="3">&lt;/codeph&gt;</ept> with an <bpt id="4" ctype="x-codeph">&lt;codeph&gt;</bpt>age<ept id="4">&lt;/codeph&gt;</ept> attribute equal to 20, use this statement:</source>
<seg-source><mrk mid="0" mtype="seg">In the <bpt id="1" ctype="x-codeph">&lt;codeph&gt;</bpt>x_table<ept id="1">&lt;/codeph&gt;</ept> table, to determine if the <bpt id="2" ctype="x-codeph">&lt;codeph&gt;</bpt>xcol<ept id="2">&lt;/codeph&gt;</ept> XML column for each row has an element called <bpt id="3" ctype="x-codeph">&lt;codeph&gt;</bpt>student<ept id="3">&lt;/codeph&gt;</ept> with an <bpt id="4" ctype="x-codeph">&lt;codeph&gt;</bpt>age<ept id="4">&lt;/codeph&gt;</ept> attribute equal to 20, use this statement:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">In the <bpt id="1" ctype="x-codeph">&lt;codeph&gt;</bpt>x_table<ept id="1">&lt;/codeph&gt;</ept> table, to determine if the <bpt id="2" ctype="x-codeph">&lt;codeph&gt;</bpt>xcol<ept id="2">&lt;/codeph&gt;</ept> XML column for each row has an element called <bpt id="3" ctype="x-codeph">&lt;codeph&gt;</bpt>student<ept id="3">&lt;/codeph&gt;</ept> with an <bpt id="4" ctype="x-codeph">&lt;codeph&gt;</bpt>age<ept id="4">&lt;/codeph&gt;</ept> attribute equal to 20, use this statement:</mrk></target>
</trans-unit>
<trans-unit id="tu29">
<source xml:lang="en"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>SELECT id, XMLEXISTS('//student[@age=20]' PASSING BY REF xcol) FROM x_table<ept id="1">&lt;/b&gt;</ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>SELECT id, XMLEXISTS('//student[@age=20]' PASSING BY REF xcol) FROM x_table<ept id="1">&lt;/b&gt;</ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>SELECT id, XMLEXISTS('//student[@age=20]' PASSING BY REF xcol) FROM x_table<ept id="1">&lt;/b&gt;</ept></mrk></target>
</trans-unit>
<trans-unit id="tu30">
<source xml:lang="en">In the <bpt id="1" ctype="x-codeph">&lt;codeph&gt;</bpt>x_table<ept id="1">&lt;/codeph&gt;</ept> table, to return the ID for every row whose <bpt id="2" ctype="x-codeph">&lt;codeph&gt;</bpt>xcol<ept id="2">&lt;/codeph&gt;</ept> XML column is non-null and contains the element <bpt id="3" ctype="x-codeph">&lt;codeph&gt;</bpt>/roster/student<ept id="3">&lt;/codeph&gt;</ept>, use this statement:</source>
<seg-source><mrk mid="0" mtype="seg">In the <bpt id="1" ctype="x-codeph">&lt;codeph&gt;</bpt>x_table<ept id="1">&lt;/codeph&gt;</ept> table, to return the ID for every row whose <bpt id="2" ctype="x-codeph">&lt;codeph&gt;</bpt>xcol<ept id="2">&lt;/codeph&gt;</ept> XML column is non-null and contains the element <bpt id="3" ctype="x-codeph">&lt;codeph&gt;</bpt>/roster/student<ept id="3">&lt;/codeph&gt;</ept>, use this statement:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">In the <bpt id="1" ctype="x-codeph">&lt;codeph&gt;</bpt>x_table<ept id="1">&lt;/codeph&gt;</ept> table, to return the ID for every row whose <bpt id="2" ctype="x-codeph">&lt;codeph&gt;</bpt>xcol<ept id="2">&lt;/codeph&gt;</ept> XML column is non-null and contains the element <bpt id="3" ctype="x-codeph">&lt;codeph&gt;</bpt>/roster/student<ept id="3">&lt;/codeph&gt;</ept>, use this statement:</mrk></target>
</trans-unit>
<trans-unit id="tu31">
<source xml:lang="en"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>SELECT id FROM x_table WHERE XMLEXISTS('/roster/student' PASSING BY REF xcol)<ept id="1">&lt;/b&gt;</ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>SELECT id FROM x_table WHERE XMLEXISTS('/roster/student' PASSING BY REF xcol)<ept id="1">&lt;/b&gt;</ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>SELECT id FROM x_table WHERE XMLEXISTS('/roster/student' PASSING BY REF xcol)<ept id="1">&lt;/b&gt;</ept></mrk></target>
</trans-unit>
<trans-unit id="tu32">
<source xml:lang="en">You can create the <bpt id="1" ctype="x-codeph">&lt;codeph&gt;</bpt>x_table<ept id="1">&lt;/codeph&gt;</ept> table with a check constraint that limits which XML values can be inserted into the <bpt id="2" ctype="x-codeph">&lt;codeph&gt;</bpt>xcol<ept id="2">&lt;/codeph&gt;</ept> XML column. In this example, the constraint is that the column has at least one <bpt id="3" ctype="x-codeph">&lt;codeph&gt;</bpt>student<ept id="3">&lt;/codeph&gt;</ept> element with an <bpt id="4" ctype="x-codeph">&lt;codeph&gt;</bpt>age<ept id="4">&lt;/codeph&gt;</ept> attribute with a value that is less than 25. To create the table, use this statement:</source>
<seg-source><mrk mid="0" mtype="seg">You can create the <bpt id="1" ctype="x-codeph">&lt;codeph&gt;</bpt>x_table<ept id="1">&lt;/codeph&gt;</ept> table with a check constraint that limits which XML values can be inserted into the <bpt id="2" ctype="x-codeph">&lt;codeph&gt;</bpt>xcol<ept id="2">&lt;/codeph&gt;</ept> XML column.</mrk><mrk mid="1" mtype="seg"> In this example, the constraint is that the column has at least one <bpt id="3" ctype="x-codeph">&lt;codeph&gt;</bpt>student<ept id="3">&lt;/codeph&gt;</ept> element with an <bpt id="4" ctype="x-codeph">&lt;codeph&gt;</bpt>age<ept id="4">&lt;/codeph&gt;</ept> attribute with a value that is less than 25.</mrk><mrk mid="2" mtype="seg"> To create the table, use this statement:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">You can create the <bpt id="1" ctype="x-codeph">&lt;codeph&gt;</bpt>x_table<ept id="1">&lt;/codeph&gt;</ept> table with a check constraint that limits which XML values can be inserted into the <bpt id="2" ctype="x-codeph">&lt;codeph&gt;</bpt>xcol<ept id="2">&lt;/codeph&gt;</ept> XML column.</mrk><mrk mid="1" mtype="seg"> In this example, the constraint is that the column has at least one <bpt id="3" ctype="x-codeph">&lt;codeph&gt;</bpt>student<ept id="3">&lt;/codeph&gt;</ept> element with an <bpt id="4" ctype="x-codeph">&lt;codeph&gt;</bpt>age<ept id="4">&lt;/codeph&gt;</ept> attribute with a value that is less than 25.</mrk><mrk mid="2" mtype="seg"> To create the table, use this statement:</mrk></target>
</trans-unit>
<trans-unit id="tu33">
<source xml:lang="en"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>CREATE TABLE x_table ( id INT, xcol XML CHECK (XMLEXISTS ('//student[@age &lt; 25]' PASSING BY REF xcol)) )<ept id="1">&lt;/b&gt;</ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>CREATE TABLE x_table ( id INT, xcol XML CHECK (XMLEXISTS ('//student[@age &lt; 25]' PASSING BY REF xcol)) )<ept id="1">&lt;/b&gt;</ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>CREATE TABLE x_table ( id INT, xcol XML CHECK (XMLEXISTS ('//student[@age &lt; 25]' PASSING BY REF xcol)) )<ept id="1">&lt;/b&gt;</ept></mrk></target>
</trans-unit>
<trans-unit id="tu34">
<source xml:lang="en">Usage note</source>
<seg-source><mrk mid="0" mtype="seg">Usage note</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Usage note</mrk></target>
</trans-unit>
<trans-unit id="tu35">
<source xml:lang="en"><bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> requires that a JAXP parser (such as Apache Xerces) and Apache Xalan are listed in the Java classpath for the XML functions to work. If either the JAXP parser or Xalan is missing from the classpath, attempts to use the XMLEXISTS operator will result in an error. In some situations, you may need to take steps to place the parser and Xalan in your classpath. See "XML data types and operators" in the <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#pub/citdevelop"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> for details.</source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> requires that a JAXP parser (such as Apache Xerces) and Apache Xalan are listed in the Java classpath for the XML functions to work.</mrk><mrk mid="1" mtype="seg"> If either the JAXP parser or Xalan is missing from the classpath, attempts to use the XMLEXISTS operator will result in an error.</mrk><mrk mid="2" mtype="seg"> In some situations, you may need to take steps to place the parser and Xalan in your classpath.</mrk><mrk mid="3" mtype="seg"> See "XML data types and operators" in the <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#pub/citdevelop"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> for details.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> requires that a JAXP parser (such as Apache Xerces) and Apache Xalan are listed in the Java classpath for the XML functions to work.</mrk><mrk mid="1" mtype="seg"> If either the JAXP parser or Xalan is missing from the classpath, attempts to use the XMLEXISTS operator will result in an error.</mrk><mrk mid="2" mtype="seg"> In some situations, you may need to take steps to place the parser and Xalan in your classpath.</mrk><mrk mid="3" mtype="seg"> See "XML data types and operators" in the <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#pub/citdevelop"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> for details.</mrk></target>
</trans-unit>
</body>
</file>
</xliff>
