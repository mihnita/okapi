<?xml version="1.0" encoding="UTF-8"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:okp="okapi-framework:xliff-extensions" xmlns:its="http://www.w3.org/2005/11/its" xmlns:itsxlf="http://www.w3.org/ns/its-xliff/" its:version="2.0">
<file original="rrefsqlj14122.dita" source-language="en" target-language="fr" datatype="xml" okp:inputEncoding="utf-8" okp:configId="/home/jimh/Code/Okapi/okapi/okapi/filters/xmlstream/target/classes/net/sf/okapi/filters/xmlstream/dita.yml">
<header><tool tool-id="okapi" tool-name="okapi-tests" tool-version="M29" tool-company="okapi"></tool></header>
<body>
<trans-unit id="tu1">
<source xml:lang="en">REAL data type</source>
<seg-source><mrk mid="0" mtype="seg">REAL data type</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">REAL data type</mrk></target>
</trans-unit>
<trans-unit id="tu2">
<source xml:lang="en">REAL data type</source>
<seg-source><mrk mid="0" mtype="seg">REAL data type</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">REAL data type</mrk></target>
</trans-unit>
<trans-unit id="tu3">
<source xml:lang="en">The REAL data type provides 4 bytes of storage for numbers using IEEE floating-point notation.</source>
<seg-source><mrk mid="0" mtype="seg">The REAL data type provides 4 bytes of storage for numbers using IEEE floating-point notation.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">The REAL data type provides 4 bytes of storage for numbers using IEEE floating-point notation.</mrk></target>
</trans-unit>
<trans-unit id="tu4">
<source xml:lang="en">Syntax</source>
<seg-source><mrk mid="0" mtype="seg">Syntax</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Syntax</mrk></target>
</trans-unit>
<trans-unit id="tu5">
<source xml:lang="en"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>REAL<ept id="1">&lt;/b&gt;</ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>REAL<ept id="1">&lt;/b&gt;</ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>REAL<ept id="1">&lt;/b&gt;</ept></mrk></target>
</trans-unit>
<trans-unit id="tu6">
<source xml:lang="en">Corresponding compile-time Java type</source>
<seg-source><mrk mid="0" mtype="seg">Corresponding compile-time Java type</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Corresponding compile-time Java type</mrk></target>
</trans-unit>
<trans-unit id="tu7">
<source xml:lang="en"><bpt id="1" ctype="x-i">&lt;i&gt;</bpt>java.lang.Float<ept id="1">&lt;/i&gt;</ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-i">&lt;i&gt;</bpt>java.lang.Float<ept id="1">&lt;/i&gt;</ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-i">&lt;i&gt;</bpt>java.lang.Float<ept id="1">&lt;/i&gt;</ept></mrk></target>
</trans-unit>
<trans-unit id="tu8">
<source xml:lang="en">JDBC metadata type (java.sql.Types)</source>
<seg-source><mrk mid="0" mtype="seg">JDBC metadata type (java.sql.Types)</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">JDBC metadata type (java.sql.Types)</mrk></target>
</trans-unit>
<trans-unit id="tu9">
<source xml:lang="en">REAL</source>
<seg-source><mrk mid="0" mtype="seg">REAL</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">REAL</mrk></target>
</trans-unit>
<trans-unit id="tu10">
<source xml:lang="en">Limitations</source>
<seg-source><mrk mid="0" mtype="seg">Limitations</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Limitations</mrk></target>
</trans-unit>
<trans-unit id="tu11">
<source xml:lang="en">REAL value ranges:</source>
<seg-source><mrk mid="0" mtype="seg">REAL value ranges:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">REAL value ranges:</mrk></target>
</trans-unit>
<trans-unit id="tu12">
<source xml:lang="en">Largest negative REAL value: -3.4028235E+38</source>
<seg-source><mrk mid="0" mtype="seg">Largest negative REAL value: -3.4028235E+38</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Largest negative REAL value: -3.4028235E+38</mrk></target>
</trans-unit>
<trans-unit id="tu13">
<source xml:lang="en">Largest positive REAL value: 3.4028235E+38</source>
<seg-source><mrk mid="0" mtype="seg">Largest positive REAL value: 3.4028235E+38</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Largest positive REAL value: 3.4028235E+38</mrk></target>
</trans-unit>
<trans-unit id="tu14">
<source xml:lang="en">Smallest negative normalized REAL value: -1.17549435E-38</source>
<seg-source><mrk mid="0" mtype="seg">Smallest negative normalized REAL value: -1.17549435E-38</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Smallest negative normalized REAL value: -1.17549435E-38</mrk></target>
</trans-unit>
<trans-unit id="tu15">
<source xml:lang="en">Smallest positive normalized REAL value: 1.17549435E-38</source>
<seg-source><mrk mid="0" mtype="seg">Smallest positive normalized REAL value: 1.17549435E-38</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Smallest positive normalized REAL value: 1.17549435E-38</mrk></target>
</trans-unit>
<trans-unit id="tu16">
<source xml:lang="en">Smallest negative denormalized REAL value: -1.4E-45</source>
<seg-source><mrk mid="0" mtype="seg">Smallest negative denormalized REAL value: -1.4E-45</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Smallest negative denormalized REAL value: -1.4E-45</mrk></target>
</trans-unit>
<trans-unit id="tu17">
<source xml:lang="en">Smallest positive denormalized REAL value: 1.4E-45</source>
<seg-source><mrk mid="0" mtype="seg">Smallest positive denormalized REAL value: 1.4E-45</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Smallest positive denormalized REAL value: 1.4E-45</mrk></target>
</trans-unit>
<trans-unit id="tu18">
<source xml:lang="en">These limits are the same as the <bpt id="1" ctype="x-codeph">&lt;codeph&gt;</bpt>java.lang.Float<ept id="1">&lt;/codeph&gt;</ept> Java type limits.</source>
<seg-source><mrk mid="0" mtype="seg">These limits are the same as the <bpt id="1" ctype="x-codeph">&lt;codeph&gt;</bpt>java.lang.Float<ept id="1">&lt;/codeph&gt;</ept> Java type limits.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">These limits are the same as the <bpt id="1" ctype="x-codeph">&lt;codeph&gt;</bpt>java.lang.Float<ept id="1">&lt;/codeph&gt;</ept> Java type limits.</mrk></target>
</trans-unit>
<trans-unit id="tu19">
<source xml:lang="en">An exception is thrown when any double value is calculated or entered that is outside of these value ranges. Arithmetic operations <bpt id="1" ctype="x-b">&lt;b&gt;</bpt>do not<ept id="1">&lt;/b&gt;</ept> round their resulting values to zero. If the values are too small, you will receive an exception. The arithmetic operations take place with double arithmetic in order to detect underflows.</source>
<seg-source><mrk mid="0" mtype="seg">An exception is thrown when any double value is calculated or entered that is outside of these value ranges.</mrk><mrk mid="1" mtype="seg"> Arithmetic operations <bpt id="1" ctype="x-b">&lt;b&gt;</bpt>do not<ept id="1">&lt;/b&gt;</ept> round their resulting values to zero.</mrk><mrk mid="2" mtype="seg"> If the values are too small, you will receive an exception.</mrk><mrk mid="3" mtype="seg"> The arithmetic operations take place with double arithmetic in order to detect underflows.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">An exception is thrown when any double value is calculated or entered that is outside of these value ranges.</mrk><mrk mid="1" mtype="seg"> Arithmetic operations <bpt id="1" ctype="x-b">&lt;b&gt;</bpt>do not<ept id="1">&lt;/b&gt;</ept> round their resulting values to zero.</mrk><mrk mid="2" mtype="seg"> If the values are too small, you will receive an exception.</mrk><mrk mid="3" mtype="seg"> The arithmetic operations take place with double arithmetic in order to detect underflows.</mrk></target>
</trans-unit>
<trans-unit id="tu20">
<source xml:lang="en"><bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> normalizes -0.0 to positive 0.0.</source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> normalizes -0.0 to positive 0.0.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> normalizes -0.0 to positive 0.0.</mrk></target>
</trans-unit>
<trans-unit id="tu21">
<source xml:lang="en"><bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> throws an exception if an operation calculates or tries to store a value of NaN, positive infinity, or negative infinity, as defined by the <bpt id="2" ctype="x-cite">&lt;cite&gt;</bpt>IEEE 754 Standard for Binary Floating-Point Arithmetic<ept id="2">&lt;/cite&gt;</ept> and as represented with named constants in the Java programming language (for example, <bpt id="3" ctype="x-codeph">&lt;codeph&gt;</bpt>Double.NaN<ept id="3">&lt;/codeph&gt;</ept>).</source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> throws an exception if an operation calculates or tries to store a value of NaN, positive infinity, or negative infinity, as defined by the <bpt id="2" ctype="x-cite">&lt;cite&gt;</bpt>IEEE 754 Standard for Binary Floating-Point Arithmetic<ept id="2">&lt;/cite&gt;</ept> and as represented with named constants in the Java programming language (for example, <bpt id="3" ctype="x-codeph">&lt;codeph&gt;</bpt>Double.NaN<ept id="3">&lt;/codeph&gt;</ept>).</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> throws an exception if an operation calculates or tries to store a value of NaN, positive infinity, or negative infinity, as defined by the <bpt id="2" ctype="x-cite">&lt;cite&gt;</bpt>IEEE 754 Standard for Binary Floating-Point Arithmetic<ept id="2">&lt;/cite&gt;</ept> and as represented with named constants in the Java programming language (for example, <bpt id="3" ctype="x-codeph">&lt;codeph&gt;</bpt>Double.NaN<ept id="3">&lt;/codeph&gt;</ept>).</mrk></target>
</trans-unit>
<trans-unit id="tu22">
<source xml:lang="en">Numeric floating-point constants are limited to a length of 30 characters.</source>
<seg-source><mrk mid="0" mtype="seg">Numeric floating-point constants are limited to a length of 30 characters.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Numeric floating-point constants are limited to a length of 30 characters.</mrk></target>
</trans-unit>
<trans-unit id="tu23">
<source xml:lang="en">-- this example will fail because the constant is too long: <bpt id="1" ctype="x-b">&lt;b&gt;</bpt>values 01234567890123456789012345678901e0;<ept id="1">&lt;/b&gt;</ept></source>
<seg-source><mrk mid="0" mtype="seg">-- this example will fail because the constant is too long: <bpt id="1" ctype="x-b">&lt;b&gt;</bpt>values 01234567890123456789012345678901e0;<ept id="1">&lt;/b&gt;</ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">-- this example will fail because the constant is too long: <bpt id="1" ctype="x-b">&lt;b&gt;</bpt>values 01234567890123456789012345678901e0;<ept id="1">&lt;/b&gt;</ept></mrk></target>
</trans-unit>
<trans-unit id="tu24">
<source xml:lang="en">When mixed with other data types in expressions, the resulting data type follows the rules shown in <bpt id="1" ctype="x-xref">&lt;xref href="rrefsqlj27767.dita#rrefsqlj27767"&gt;</bpt><ept id="1">&lt;/xref&gt;</ept>.</source>
<seg-source><mrk mid="0" mtype="seg">When mixed with other data types in expressions, the resulting data type follows the rules shown in <bpt id="1" ctype="x-xref">&lt;xref href="rrefsqlj27767.dita#rrefsqlj27767"&gt;</bpt><ept id="1">&lt;/xref&gt;</ept>.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">When mixed with other data types in expressions, the resulting data type follows the rules shown in <bpt id="1" ctype="x-xref">&lt;xref href="rrefsqlj27767.dita#rrefsqlj27767"&gt;</bpt><ept id="1">&lt;/xref&gt;</ept>.</mrk></target>
</trans-unit>
<trans-unit id="tu25">
<source xml:lang="en">See also <bpt id="1" ctype="x-xref">&lt;xref href="rrefsqlj20204.dita#rrefsqlj20204"&gt;</bpt><ept id="1">&lt;/xref&gt;</ept>.</source>
<seg-source><mrk mid="0" mtype="seg">See also <bpt id="1" ctype="x-xref">&lt;xref href="rrefsqlj20204.dita#rrefsqlj20204"&gt;</bpt><ept id="1">&lt;/xref&gt;</ept>.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">See also <bpt id="1" ctype="x-xref">&lt;xref href="rrefsqlj20204.dita#rrefsqlj20204"&gt;</bpt><ept id="1">&lt;/xref&gt;</ept>.</mrk></target>
</trans-unit>
<trans-unit id="tu26">
<source xml:lang="en">Constants always map to DOUBLE PRECISION; use a CAST to convert a constant to a REAL.</source>
<seg-source><mrk mid="0" mtype="seg">Constants always map to DOUBLE PRECISION; use a CAST to convert a constant to a REAL.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Constants always map to DOUBLE PRECISION; use a CAST to convert a constant to a REAL.</mrk></target>
</trans-unit>
</body>
</file>
</xliff>
