<?xml version="1.0" encoding="UTF-8"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:okp="okapi-framework:xliff-extensions" xmlns:its="http://www.w3.org/2005/11/its" xmlns:itsxlf="http://www.w3.org/ns/its-xliff/" its:version="2.0">
<file original="cdevspecialudt.dita" source-language="en" target-language="fr" datatype="xml" okp:inputEncoding="utf-8" okp:configId="/home/jimh/Code/Okapi/okapi/okapi/filters/xmlstream/target/classes/net/sf/okapi/filters/xmlstream/dita.yml">
<header><tool tool-id="okapi" tool-name="okapi-tests" tool-version="M29" tool-company="okapi"></tool></header>
<body>
<trans-unit id="tu1">
<source xml:lang="en">Programming user-defined types</source>
<seg-source><mrk mid="0" mtype="seg">Programming user-defined types</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Programming user-defined types</mrk></target>
</trans-unit>
<trans-unit id="tu2">
<source xml:lang="en"><bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> allows you to create user-defined types. A user-defined type is a serializable Java class whose instances are stored in columns. The class must implement the <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>java.io.Serializable<ept id="2">&lt;/i&gt;</ept> interface, and it must be declared to <bpt id="3" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="3">&lt;/ph&gt;</ept> by means of a CREATE TYPE statement.</source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> allows you to create user-defined types.</mrk><mrk mid="1" mtype="seg"> A user-defined type is a serializable Java class whose instances are stored in columns.</mrk><mrk mid="2" mtype="seg"> The class must implement the <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>java.io.Serializable<ept id="2">&lt;/i&gt;</ept> interface, and it must be declared to <bpt id="3" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="3">&lt;/ph&gt;</ept> by means of a CREATE TYPE statement.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> allows you to create user-defined types.</mrk><mrk mid="1" mtype="seg"> A user-defined type is a serializable Java class whose instances are stored in columns.</mrk><mrk mid="2" mtype="seg"> The class must implement the <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>java.io.Serializable<ept id="2">&lt;/i&gt;</ept> interface, and it must be declared to <bpt id="3" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="3">&lt;/ph&gt;</ept> by means of a CREATE TYPE statement.</mrk></target>
</trans-unit>
<trans-unit id="tu3">
<source xml:lang="en">types</source>
<seg-source><mrk mid="0" mtype="seg">types</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">types</mrk></target>
</trans-unit>
<trans-unit id="tu4">
<source xml:lang="en">user-defined</source>
<seg-source><mrk mid="0" mtype="seg">user-defined</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">user-defined</mrk></target>
</trans-unit>
<trans-unit id="tu5">
<source xml:lang="en">user-defined types</source>
<seg-source><mrk mid="0" mtype="seg">user-defined types</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">user-defined types</mrk></target>
</trans-unit>
<trans-unit id="tu6">
<source xml:lang="en">programming</source>
<seg-source><mrk mid="0" mtype="seg">programming</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">programming</mrk></target>
</trans-unit>
<trans-unit id="tu7">
<source xml:lang="en">The key to designing a good user-defined type is to remember that data evolves over time, just like code. A good user-defined type has version information built into it. This allows the user-defined data to upgrade itself as the application changes. For this reason, it is a good idea for a user-defined type to implement <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>java.io.Externalizable<ept id="1">&lt;/i&gt;</ept> and not just <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>java.io.Serializable<ept id="2">&lt;/i&gt;</ept>. Although the SQL standard allows a Java class to implement only <bpt id="3" ctype="x-i">&lt;i&gt;</bpt>java.io.Serializable<ept id="3">&lt;/i&gt;</ept>, this is bad practice for the following reasons:</source>
<seg-source><mrk mid="0" mtype="seg">The key to designing a good user-defined type is to remember that data evolves over time, just like code.</mrk><mrk mid="1" mtype="seg"> A good user-defined type has version information built into it.</mrk><mrk mid="2" mtype="seg"> This allows the user-defined data to upgrade itself as the application changes.</mrk><mrk mid="3" mtype="seg"> For this reason, it is a good idea for a user-defined type to implement <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>java.io.Externalizable<ept id="1">&lt;/i&gt;</ept> and not just <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>java.io.Serializable<ept id="2">&lt;/i&gt;</ept>.</mrk><mrk mid="4" mtype="seg"> Although the SQL standard allows a Java class to implement only <bpt id="3" ctype="x-i">&lt;i&gt;</bpt>java.io.Serializable<ept id="3">&lt;/i&gt;</ept>, this is bad practice for the following reasons:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">The key to designing a good user-defined type is to remember that data evolves over time, just like code.</mrk><mrk mid="1" mtype="seg"> A good user-defined type has version information built into it.</mrk><mrk mid="2" mtype="seg"> This allows the user-defined data to upgrade itself as the application changes.</mrk><mrk mid="3" mtype="seg"> For this reason, it is a good idea for a user-defined type to implement <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>java.io.Externalizable<ept id="1">&lt;/i&gt;</ept> and not just <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>java.io.Serializable<ept id="2">&lt;/i&gt;</ept>.</mrk><mrk mid="4" mtype="seg"> Although the SQL standard allows a Java class to implement only <bpt id="3" ctype="x-i">&lt;i&gt;</bpt>java.io.Serializable<ept id="3">&lt;/i&gt;</ept>, this is bad practice for the following reasons:</mrk></target>
</trans-unit>
<trans-unit id="tu8">
<source xml:lang="en"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>Recompilation<ept id="1">&lt;/b&gt;</ept> - If the second version of your application is compiled on a different platform from the first version, then your serialized objects may fail to deserialize. This problem and a possible workaround are discussed in the "Version Control" section near the end of this <bpt id="2" ctype="x-xref">&lt;xref format="html"
href="http://java.sun.com/developer/technicalArticles/Programming/serialization/"
scope="external"&gt;</bpt>Serialization Primer<ept id="2">&lt;/xref&gt;</ept> and in the last paragraph of the header comment for <bpt id="3" ctype="x-i">&lt;i&gt;</bpt>java.io.Serializable<ept id="3">&lt;/i&gt;</ept>.</source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>Recompilation<ept id="1">&lt;/b&gt;</ept> - If the second version of your application is compiled on a different platform from the first version, then your serialized objects may fail to deserialize.</mrk><mrk mid="1" mtype="seg"> This problem and a possible workaround are discussed in the "Version Control" section near the end of this <bpt id="2" ctype="x-xref">&lt;xref format="html"
href="http://java.sun.com/developer/technicalArticles/Programming/serialization/"
scope="external"&gt;</bpt>Serialization Primer<ept id="2">&lt;/xref&gt;</ept> and in the last paragraph of the header comment for <bpt id="3" ctype="x-i">&lt;i&gt;</bpt>java.io.Serializable<ept id="3">&lt;/i&gt;</ept>.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>Recompilation<ept id="1">&lt;/b&gt;</ept> - If the second version of your application is compiled on a different platform from the first version, then your serialized objects may fail to deserialize.</mrk><mrk mid="1" mtype="seg"> This problem and a possible workaround are discussed in the "Version Control" section near the end of this <bpt id="2" ctype="x-xref">&lt;xref format="html"
href="http://java.sun.com/developer/technicalArticles/Programming/serialization/"
scope="external"&gt;</bpt>Serialization Primer<ept id="2">&lt;/xref&gt;</ept> and in the last paragraph of the header comment for <bpt id="3" ctype="x-i">&lt;i&gt;</bpt>java.io.Serializable<ept id="3">&lt;/i&gt;</ept>.</mrk></target>
</trans-unit>
<trans-unit id="tu9">
<source xml:lang="en"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>Evolution<ept id="1">&lt;/b&gt;</ept> - Your tools for evolving a class which simply implements <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>java.io.Serializable<ept id="2">&lt;/i&gt;</ept> are very limited.</source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>Evolution<ept id="1">&lt;/b&gt;</ept> - Your tools for evolving a class which simply implements <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>java.io.Serializable<ept id="2">&lt;/i&gt;</ept> are very limited.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>Evolution<ept id="1">&lt;/b&gt;</ept> - Your tools for evolving a class which simply implements <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>java.io.Serializable<ept id="2">&lt;/i&gt;</ept> are very limited.</mrk></target>
</trans-unit>
<trans-unit id="tu10">
<source xml:lang="en">Fortunately, it is easy to write a version-aware UDT which implements <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>java.io.Serializable<ept id="1">&lt;/i&gt;</ept> and can evolve itself over time. For example, here is the first version of such a class:</source>
<seg-source><mrk mid="0" mtype="seg">Fortunately, it is easy to write a version-aware UDT which implements <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>java.io.Serializable<ept id="1">&lt;/i&gt;</ept> and can evolve itself over time.</mrk><mrk mid="1" mtype="seg"> For example, here is the first version of such a class:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Fortunately, it is easy to write a version-aware UDT which implements <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>java.io.Serializable<ept id="1">&lt;/i&gt;</ept> and can evolve itself over time.</mrk><mrk mid="1" mtype="seg"> For example, here is the first version of such a class:</mrk></target>
</trans-unit>
<trans-unit id="tu11">
<source xml:lang="en">package com.example.types; import java.io.*; import java.math.*; public class Price implements Externalizable { // initial version id private static final int FIRST_VERSION = 0; public String currencyCode; public BigDecimal amount; // zero-arg constructor needed by Externalizable machinery public Price() {} public Price( String currencyCode, BigDecimal amount ) { this.currencyCode = currencyCode; this.amount = amount; } // Externalizable implementation public void writeExternal(ObjectOutput out) throws IOException { // first write the version id out.writeInt( FIRST_VERSION ); // now write the state out.writeObject( currencyCode ); out.writeObject( amount ); } public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException { // read the version id int oldVersion = in.readInt(); if ( oldVersion &lt; FIRST_VERSION ) { throw new IOException( "Corrupt data stream." ); } if ( oldVersion &gt; FIRST_VERSION ) { throw new IOException( "Can't deserialize from the future." ); } currencyCode = (String) in.readObject(); amount = (BigDecimal) in.readObject(); } }</source>
<seg-source><mrk mid="0" mtype="seg">package com.example.types; import java.io.*; import java.math.*; public class Price implements Externalizable { // initial version id private static final int FIRST_VERSION = 0; public String currencyCode; public BigDecimal amount; // zero-arg constructor needed by Externalizable machinery public Price() {} public Price( String currencyCode, BigDecimal amount ) { this.currencyCode = currencyCode; this.amount = amount; } // Externalizable implementation public void writeExternal(ObjectOutput out) throws IOException { // first write the version id out.writeInt( FIRST_VERSION ); // now write the state out.writeObject( currencyCode ); out.writeObject( amount ); } public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException { // read the version id int oldVersion = in.readInt(); if ( oldVersion &lt; FIRST_VERSION ) { throw new IOException( "Corrupt data stream." ); } if ( oldVersion &gt; FIRST_VERSION ) { throw new IOException( "Can't deserialize from the future." ); } currencyCode = (String) in.readObject(); amount = (BigDecimal) in.readObject(); } }</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">package com.example.types; import java.io.*; import java.math.*; public class Price implements Externalizable { // initial version id private static final int FIRST_VERSION = 0; public String currencyCode; public BigDecimal amount; // zero-arg constructor needed by Externalizable machinery public Price() {} public Price( String currencyCode, BigDecimal amount ) { this.currencyCode = currencyCode; this.amount = amount; } // Externalizable implementation public void writeExternal(ObjectOutput out) throws IOException { // first write the version id out.writeInt( FIRST_VERSION ); // now write the state out.writeObject( currencyCode ); out.writeObject( amount ); } public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException { // read the version id int oldVersion = in.readInt(); if ( oldVersion &lt; FIRST_VERSION ) { throw new IOException( "Corrupt data stream." ); } if ( oldVersion &gt; FIRST_VERSION ) { throw new IOException( "Can't deserialize from the future." ); } currencyCode = (String) in.readObject(); amount = (BigDecimal) in.readObject(); } }</mrk></target>
</trans-unit>
<trans-unit id="tu12">
<source xml:lang="en">After this, it is easy to write a second version of the user-defined type which adds a new field. When old versions of <bpt id="1" ctype="x-codeph">&lt;codeph&gt;</bpt>Price<ept id="1">&lt;/codeph&gt;</ept> values are read from the database, they upgrade themselves on the fly. Changes are shown in <bpt id="2" ctype="x-b">&lt;b&gt;</bpt>bold<ept id="2">&lt;/b&gt;</ept>:</source>
<seg-source><mrk mid="0" mtype="seg">After this, it is easy to write a second version of the user-defined type which adds a new field.</mrk><mrk mid="1" mtype="seg"> When old versions of <bpt id="1" ctype="x-codeph">&lt;codeph&gt;</bpt>Price<ept id="1">&lt;/codeph&gt;</ept> values are read from the database, they upgrade themselves on the fly.</mrk><mrk mid="2" mtype="seg"> Changes are shown in <bpt id="2" ctype="x-b">&lt;b&gt;</bpt>bold<ept id="2">&lt;/b&gt;</ept>:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">After this, it is easy to write a second version of the user-defined type which adds a new field.</mrk><mrk mid="1" mtype="seg"> When old versions of <bpt id="1" ctype="x-codeph">&lt;codeph&gt;</bpt>Price<ept id="1">&lt;/codeph&gt;</ept> values are read from the database, they upgrade themselves on the fly.</mrk><mrk mid="2" mtype="seg"> Changes are shown in <bpt id="2" ctype="x-b">&lt;b&gt;</bpt>bold<ept id="2">&lt;/b&gt;</ept>:</mrk></target>
</trans-unit>
<trans-unit id="tu13">
<source xml:lang="en">package com.example.types; import java.io.*; import java.math.*; <bpt id="1" ctype="x-b">&lt;b&gt;</bpt>import java.sql.*;<ept id="1">&lt;/b&gt;</ept> public class Price implements Externalizable { // initial version id private static final int FIRST_VERSION = 0; <bpt id="2" ctype="x-b">&lt;b&gt;</bpt>private static final int TIMESTAMPED_VERSION = FIRST_VERSION + 1;<ept id="2">&lt;/b&gt;</ept> <bpt id="3" ctype="x-b">&lt;b&gt;</bpt>private static final Timestamp DEFAULT_TIMESTAMP = new Timestamp( 0L );<ept id="3">&lt;/b&gt;</ept> public String currencyCode; public BigDecimal amount; <bpt id="4" ctype="x-b">&lt;b&gt;</bpt>public Timestamp timeInstant;<ept id="4">&lt;/b&gt;</ept> // 0-arg constructor needed by Externalizable machinery public Price() {} public Price( String currencyCode, BigDecimal amount<bpt id="5" ctype="x-b">&lt;b&gt;</bpt>, Timestamp timeInstant<ept id="5">&lt;/b&gt;</ept> ) { this.currencyCode = currencyCode; this.amount = amount; <bpt id="6" ctype="x-b">&lt;b&gt;</bpt>this.timeInstant = timeInstant;<ept id="6">&lt;/b&gt;</ept> } // Externalizable implementation public void writeExternal(ObjectOutput out) throws IOException { // first write the version id out.writeInt( <bpt id="7" ctype="x-b">&lt;b&gt;</bpt>TIMESTAMPED_VERSION<ept id="7">&lt;/b&gt;</ept> ); // now write the state out.writeObject( currencyCode ); out.writeObject( amount ); <bpt id="8" ctype="x-b">&lt;b&gt;</bpt>out.writeObject( timeInstant );<ept id="8">&lt;/b&gt;</ept> } public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException { // read the version id int oldVersion = in.readInt(); if ( oldVersion &lt; FIRST_VERSION ) { throw new IOException( "Corrupt data stream." ); } if ( oldVersion &gt; <bpt id="9" ctype="x-b">&lt;b&gt;</bpt>TIMESTAMPED_VERSION<ept id="9">&lt;/b&gt;</ept> ) { throw new IOException( "Can't deserialize from the future." ); } currencyCode = (String) in.readObject(); amount = (BigDecimal) in.readObject(); <bpt id="10" ctype="x-b">&lt;b&gt;</bpt>if ( oldVersion &gt;= TIMESTAMPED_VERSION ) { timeInstant = (Timestamp) in.readObject(); } else { timeInstant = DEFAULT_TIMESTAMP;<ept id="10">&lt;/b&gt;</ept> } } }</source>
<seg-source><mrk mid="0" mtype="seg">package com.example.types; import java.io.*; import java.math.*; <bpt id="1" ctype="x-b">&lt;b&gt;</bpt>import java.sql.*;<ept id="1">&lt;/b&gt;</ept> public class Price implements Externalizable { // initial version id private static final int FIRST_VERSION = 0; <bpt id="2" ctype="x-b">&lt;b&gt;</bpt>private static final int TIMESTAMPED_VERSION = FIRST_VERSION + 1;<ept id="2">&lt;/b&gt;</ept> <bpt id="3" ctype="x-b">&lt;b&gt;</bpt>private static final Timestamp DEFAULT_TIMESTAMP = new Timestamp( 0L );<ept id="3">&lt;/b&gt;</ept> public String currencyCode; public BigDecimal amount; <bpt id="4" ctype="x-b">&lt;b&gt;</bpt>public Timestamp timeInstant;<ept id="4">&lt;/b&gt;</ept> // 0-arg constructor needed by Externalizable machinery public Price() {} public Price( String currencyCode, BigDecimal amount<bpt id="5" ctype="x-b">&lt;b&gt;</bpt>, Timestamp timeInstant<ept id="5">&lt;/b&gt;</ept> ) { this.currencyCode = currencyCode; this.amount = amount; <bpt id="6" ctype="x-b">&lt;b&gt;</bpt>this.timeInstant = timeInstant;<ept id="6">&lt;/b&gt;</ept> } // Externalizable implementation public void writeExternal(ObjectOutput out) throws IOException { // first write the version id out.writeInt( <bpt id="7" ctype="x-b">&lt;b&gt;</bpt>TIMESTAMPED_VERSION<ept id="7">&lt;/b&gt;</ept> ); // now write the state out.writeObject( currencyCode ); out.writeObject( amount ); <bpt id="8" ctype="x-b">&lt;b&gt;</bpt>out.writeObject( timeInstant );<ept id="8">&lt;/b&gt;</ept> } public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException { // read the version id int oldVersion = in.readInt(); if ( oldVersion &lt; FIRST_VERSION ) { throw new IOException( "Corrupt data stream." ); } if ( oldVersion &gt; <bpt id="9" ctype="x-b">&lt;b&gt;</bpt>TIMESTAMPED_VERSION<ept id="9">&lt;/b&gt;</ept> ) { throw new IOException( "Can't deserialize from the future." ); } currencyCode = (String) in.readObject(); amount = (BigDecimal) in.readObject(); <bpt id="10" ctype="x-b">&lt;b&gt;</bpt>if ( oldVersion &gt;= TIMESTAMPED_VERSION ) { timeInstant = (Timestamp) in.readObject(); } else { timeInstant = DEFAULT_TIMESTAMP;<ept id="10">&lt;/b&gt;</ept> } } }</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">package com.example.types; import java.io.*; import java.math.*; <bpt id="1" ctype="x-b">&lt;b&gt;</bpt>import java.sql.*;<ept id="1">&lt;/b&gt;</ept> public class Price implements Externalizable { // initial version id private static final int FIRST_VERSION = 0; <bpt id="2" ctype="x-b">&lt;b&gt;</bpt>private static final int TIMESTAMPED_VERSION = FIRST_VERSION + 1;<ept id="2">&lt;/b&gt;</ept> <bpt id="3" ctype="x-b">&lt;b&gt;</bpt>private static final Timestamp DEFAULT_TIMESTAMP = new Timestamp( 0L );<ept id="3">&lt;/b&gt;</ept> public String currencyCode; public BigDecimal amount; <bpt id="4" ctype="x-b">&lt;b&gt;</bpt>public Timestamp timeInstant;<ept id="4">&lt;/b&gt;</ept> // 0-arg constructor needed by Externalizable machinery public Price() {} public Price( String currencyCode, BigDecimal amount<bpt id="5" ctype="x-b">&lt;b&gt;</bpt>, Timestamp timeInstant<ept id="5">&lt;/b&gt;</ept> ) { this.currencyCode = currencyCode; this.amount = amount; <bpt id="6" ctype="x-b">&lt;b&gt;</bpt>this.timeInstant = timeInstant;<ept id="6">&lt;/b&gt;</ept> } // Externalizable implementation public void writeExternal(ObjectOutput out) throws IOException { // first write the version id out.writeInt( <bpt id="7" ctype="x-b">&lt;b&gt;</bpt>TIMESTAMPED_VERSION<ept id="7">&lt;/b&gt;</ept> ); // now write the state out.writeObject( currencyCode ); out.writeObject( amount ); <bpt id="8" ctype="x-b">&lt;b&gt;</bpt>out.writeObject( timeInstant );<ept id="8">&lt;/b&gt;</ept> } public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException { // read the version id int oldVersion = in.readInt(); if ( oldVersion &lt; FIRST_VERSION ) { throw new IOException( "Corrupt data stream." ); } if ( oldVersion &gt; <bpt id="9" ctype="x-b">&lt;b&gt;</bpt>TIMESTAMPED_VERSION<ept id="9">&lt;/b&gt;</ept> ) { throw new IOException( "Can't deserialize from the future." ); } currencyCode = (String) in.readObject(); amount = (BigDecimal) in.readObject(); <bpt id="10" ctype="x-b">&lt;b&gt;</bpt>if ( oldVersion &gt;= TIMESTAMPED_VERSION ) { timeInstant = (Timestamp) in.readObject(); } else { timeInstant = DEFAULT_TIMESTAMP;<ept id="10">&lt;/b&gt;</ept> } } }</mrk></target>
</trans-unit>
<trans-unit id="tu14">
<source xml:lang="en">An application needs to keep its code in sync across all tiers. This is true for all Java code which runs both in the client and in the server. This is true for functions and procedures which run in multiple tiers. It is also true for user-defined types which run in multiple tiers. The programmer should code defensively for the case when the client and server are running different versions of the application code. In particular, the programmer should write defensive serialization logic for user-defined types so that the application gracefully handles client/server version mismatches.</source>
<seg-source><mrk mid="0" mtype="seg">An application needs to keep its code in sync across all tiers.</mrk><mrk mid="1" mtype="seg"> This is true for all Java code which runs both in the client and in the server.</mrk><mrk mid="2" mtype="seg"> This is true for functions and procedures which run in multiple tiers.</mrk><mrk mid="3" mtype="seg"> It is also true for user-defined types which run in multiple tiers.</mrk><mrk mid="4" mtype="seg"> The programmer should code defensively for the case when the client and server are running different versions of the application code.</mrk><mrk mid="5" mtype="seg"> In particular, the programmer should write defensive serialization logic for user-defined types so that the application gracefully handles client/server version mismatches.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">An application needs to keep its code in sync across all tiers.</mrk><mrk mid="1" mtype="seg"> This is true for all Java code which runs both in the client and in the server.</mrk><mrk mid="2" mtype="seg"> This is true for functions and procedures which run in multiple tiers.</mrk><mrk mid="3" mtype="seg"> It is also true for user-defined types which run in multiple tiers.</mrk><mrk mid="4" mtype="seg"> The programmer should code defensively for the case when the client and server are running different versions of the application code.</mrk><mrk mid="5" mtype="seg"> In particular, the programmer should write defensive serialization logic for user-defined types so that the application gracefully handles client/server version mismatches.</mrk></target>
</trans-unit>
</body>
</file>
</xliff>
