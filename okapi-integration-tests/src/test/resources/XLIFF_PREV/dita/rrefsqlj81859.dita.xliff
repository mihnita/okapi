<?xml version="1.0" encoding="UTF-8"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:okp="okapi-framework:xliff-extensions" xmlns:its="http://www.w3.org/2005/11/its" xmlns:itsxlf="http://www.w3.org/ns/its-xliff/" its:version="2.0">
<file original="rrefsqlj81859.dita" source-language="en" target-language="fr" datatype="xml" okp:inputEncoding="utf-8" okp:configId="/home/jimh/Code/Okapi/okapi/okapi/filters/xmlstream/target/classes/net/sf/okapi/filters/xmlstream/dita.yml">
<header><tool tool-id="okapi" tool-name="okapi-tests" tool-version="M29" tool-company="okapi"></tool></header>
<body>
<trans-unit id="tu1">
<source xml:lang="en">ALTER TABLE statement</source>
<seg-source><mrk mid="0" mtype="seg">ALTER TABLE statement</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">ALTER TABLE statement</mrk></target>
</trans-unit>
<trans-unit id="tu2">
<source xml:lang="en">ALTER TABLE statement</source>
<seg-source><mrk mid="0" mtype="seg">ALTER TABLE statement</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">ALTER TABLE statement</mrk></target>
</trans-unit>
<trans-unit id="tu3">
<source xml:lang="en">Compressing tables</source>
<seg-source><mrk mid="0" mtype="seg">Compressing tables</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Compressing tables</mrk></target>
</trans-unit>
<trans-unit id="tu4">
<source xml:lang="en">Tables</source>
<seg-source><mrk mid="0" mtype="seg">Tables</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Tables</mrk></target>
</trans-unit>
<trans-unit id="tu5">
<source xml:lang="en">altering</source>
<seg-source><mrk mid="0" mtype="seg">altering</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">altering</mrk></target>
</trans-unit>
<trans-unit id="tu6">
<source xml:lang="en">compressing</source>
<seg-source><mrk mid="0" mtype="seg">compressing</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">compressing</mrk></target>
</trans-unit>
<trans-unit id="tu7">
<source xml:lang="en">Columns</source>
<seg-source><mrk mid="0" mtype="seg">Columns</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Columns</mrk></target>
</trans-unit>
<trans-unit id="tu8">
<source xml:lang="en">adding</source>
<seg-source><mrk mid="0" mtype="seg">adding</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">adding</mrk></target>
</trans-unit>
<trans-unit id="tu9">
<source xml:lang="en">Constraints</source>
<seg-source><mrk mid="0" mtype="seg">Constraints</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Constraints</mrk></target>
</trans-unit>
<trans-unit id="tu10">
<source xml:lang="en">adding</source>
<seg-source><mrk mid="0" mtype="seg">adding</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">adding</mrk></target>
</trans-unit>
<trans-unit id="tu11">
<source xml:lang="en">dropping</source>
<seg-source><mrk mid="0" mtype="seg">dropping</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">dropping</mrk></target>
</trans-unit>
<trans-unit id="tu12">
<source xml:lang="en">compressing</source>
<seg-source><mrk mid="0" mtype="seg">compressing</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">compressing</mrk></target>
</trans-unit>
<trans-unit id="tu13">
<source xml:lang="en">Defaults</source>
<seg-source><mrk mid="0" mtype="seg">Defaults</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Defaults</mrk></target>
</trans-unit>
<trans-unit id="tu14">
<source xml:lang="en">adding</source>
<seg-source><mrk mid="0" mtype="seg">adding</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">adding</mrk></target>
</trans-unit>
<trans-unit id="tu15">
<source xml:lang="en">dropping</source>
<seg-source><mrk mid="0" mtype="seg">dropping</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">dropping</mrk></target>
</trans-unit>
<trans-unit id="tu16">
<source xml:lang="en">Adding Columns</source>
<seg-source><mrk mid="0" mtype="seg">Adding Columns</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Adding Columns</mrk></target>
</trans-unit>
<trans-unit id="tu17">
<source xml:lang="en">Adding Constraints</source>
<seg-source><mrk mid="0" mtype="seg">Adding Constraints</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Adding Constraints</mrk></target>
</trans-unit>
<trans-unit id="tu18">
<source xml:lang="en">Dropping Constraints</source>
<seg-source><mrk mid="0" mtype="seg">Dropping Constraints</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Dropping Constraints</mrk></target>
</trans-unit>
<trans-unit id="tu19">
<source xml:lang="en">Defaults</source>
<seg-source><mrk mid="0" mtype="seg">Defaults</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Defaults</mrk></target>
</trans-unit>
<trans-unit id="tu20">
<source xml:lang="en">setting</source>
<seg-source><mrk mid="0" mtype="seg">setting</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">setting</mrk></target>
</trans-unit>
<trans-unit id="tu21">
<source xml:lang="en">Tables</source>
<seg-source><mrk mid="0" mtype="seg">Tables</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Tables</mrk></target>
</trans-unit>
<trans-unit id="tu22">
<source xml:lang="en">changing lock granularity for</source>
<seg-source><mrk mid="0" mtype="seg">changing lock granularity for</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">changing lock granularity for</mrk></target>
</trans-unit>
<trans-unit id="tu23">
<source xml:lang="en">Data types</source>
<seg-source><mrk mid="0" mtype="seg">Data types</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Data types</mrk></target>
</trans-unit>
<trans-unit id="tu24">
<source xml:lang="en">modifying</source>
<seg-source><mrk mid="0" mtype="seg">modifying</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">modifying</mrk></target>
</trans-unit>
<trans-unit id="tu25">
<source xml:lang="en">The ALTER TABLE statement allows you to:</source>
<seg-source><mrk mid="0" mtype="seg">The ALTER TABLE statement allows you to:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">The ALTER TABLE statement allows you to:</mrk></target>
</trans-unit>
<trans-unit id="tu26">
<source xml:lang="en">Add a column to a table</source>
<seg-source><mrk mid="0" mtype="seg">Add a column to a table</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Add a column to a table</mrk></target>
</trans-unit>
<trans-unit id="tu27">
<source xml:lang="en">Add a constraint to a table</source>
<seg-source><mrk mid="0" mtype="seg">Add a constraint to a table</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Add a constraint to a table</mrk></target>
</trans-unit>
<trans-unit id="tu28">
<source xml:lang="en">Drop a column from a table</source>
<seg-source><mrk mid="0" mtype="seg">Drop a column from a table</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Drop a column from a table</mrk></target>
</trans-unit>
<trans-unit id="tu29">
<source xml:lang="en">Drop an existing constraint from a table</source>
<seg-source><mrk mid="0" mtype="seg">Drop an existing constraint from a table</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Drop an existing constraint from a table</mrk></target>
</trans-unit>
<trans-unit id="tu30">
<source xml:lang="en">Increase the width of a VARCHAR or VARCHAR FOR BIT DATA column</source>
<seg-source><mrk mid="0" mtype="seg">Increase the width of a VARCHAR or VARCHAR FOR BIT DATA column</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Increase the width of a VARCHAR or VARCHAR FOR BIT DATA column</mrk></target>
</trans-unit>
<trans-unit id="tu31">
<source xml:lang="en">Override row-level locking for the table (or drop the override)</source>
<seg-source><mrk mid="0" mtype="seg">Override row-level locking for the table (or drop the override)</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Override row-level locking for the table (or drop the override)</mrk></target>
</trans-unit>
<trans-unit id="tu32">
<source xml:lang="en">Change the increment value and start value of the identity column</source>
<seg-source><mrk mid="0" mtype="seg">Change the increment value and start value of the identity column</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Change the increment value and start value of the identity column</mrk></target>
</trans-unit>
<trans-unit id="tu33">
<source xml:lang="en">Change the nullability constraint for a column</source>
<seg-source><mrk mid="0" mtype="seg">Change the nullability constraint for a column</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Change the nullability constraint for a column</mrk></target>
</trans-unit>
<trans-unit id="tu34">
<source xml:lang="en">Change the default value for a column</source>
<seg-source><mrk mid="0" mtype="seg">Change the default value for a column</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Change the default value for a column</mrk></target>
</trans-unit>
<trans-unit id="tu35">
<source xml:lang="en">Syntax</source>
<seg-source><mrk mid="0" mtype="seg">Syntax</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Syntax</mrk></target>
</trans-unit>
<trans-unit id="tu36">
<source xml:lang="en"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>ALTER TABLE <bpt id="2" ctype="x-i">&lt;i&gt;</bpt><bpt id="3" ctype="x-xref">&lt;xref href="rreftablename.dita#rreftablename"&gt;</bpt>tableName<ept id="3">&lt;/xref&gt;</ept><ept id="2">&lt;/i&gt;</ept> { ADD COLUMN <bpt id="4" ctype="x-i">&lt;i&gt;</bpt><bpt id="5" ctype="x-xref">&lt;xref href="rrefsqlj81859.dita#rrefsqlj81859/rrefaltercolumndef"&gt;</bpt>columnDefinition<ept id="5">&lt;/xref&gt;</ept><ept id="4">&lt;/i&gt;</ept> | ADD <bpt id="6" ctype="x-i">&lt;i&gt;</bpt><bpt id="7" ctype="x-xref">&lt;xref href="rrefsqlj13590.dita#rrefsqlj13590"&gt;</bpt>CONSTRAINT clause<ept id="7">&lt;/xref&gt;</ept><ept id="6">&lt;/i&gt;</ept> | DROP [ COLUMN ] <bpt id="8" ctype="x-i">&lt;i&gt;</bpt><bpt id="9" ctype="x-xref">&lt;xref
href="rrefcolumnname.dita#rrefcolumnname"&gt;</bpt>columnName<ept id="9">&lt;/xref&gt;</ept><ept id="8">&lt;/i&gt;</ept> [ CASCADE | RESTRICT ] | DROP { PRIMARY KEY | FOREIGN KEY <bpt id="10" ctype="x-i">&lt;i&gt;</bpt><bpt id="11" ctype="x-xref">&lt;xref
href="rrefconstraintname.dita#rrefconstraintname"&gt;</bpt>constraintName<ept id="11">&lt;/xref&gt;</ept><ept id="10">&lt;/i&gt;</ept> | UNIQUE <bpt id="12" ctype="x-i">&lt;i&gt;</bpt><bpt id="13" ctype="x-xref">&lt;xref
href="rrefconstraintname.dita#rrefconstraintname"&gt;</bpt>constraintName<ept id="13">&lt;/xref&gt;</ept><ept id="12">&lt;/i&gt;</ept> | CHECK <bpt id="14" ctype="x-i">&lt;i&gt;</bpt><bpt id="15" ctype="x-xref">&lt;xref
href="rrefconstraintname.dita#rrefconstraintname"&gt;</bpt>constraintName<ept id="15">&lt;/xref&gt;</ept><ept id="14">&lt;/i&gt;</ept> | CONSTRAINT <bpt id="16" ctype="x-i">&lt;i&gt;</bpt><bpt id="17" ctype="x-xref">&lt;xref
href="rrefconstraintname.dita#rrefconstraintname"&gt;</bpt>constraintName<ept id="17">&lt;/xref&gt;</ept><ept id="16">&lt;/i&gt;</ept> } | ALTER [ COLUMN ] <bpt id="18" ctype="x-i">&lt;i&gt;</bpt><bpt id="19" ctype="x-xref">&lt;xref href="rrefsqlj81859.dita#rrefsqlj81859/rrefsqlj37860"&gt;</bpt>columnAlteration<ept id="19">&lt;/xref&gt;</ept><ept id="18">&lt;/i&gt;</ept> | LOCKSIZE { ROW | TABLE } }<ept id="1">&lt;/b&gt;</ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>ALTER TABLE <bpt id="2" ctype="x-i">&lt;i&gt;</bpt><bpt id="3" ctype="x-xref">&lt;xref href="rreftablename.dita#rreftablename"&gt;</bpt>tableName<ept id="3">&lt;/xref&gt;</ept><ept id="2">&lt;/i&gt;</ept> { ADD COLUMN <bpt id="4" ctype="x-i">&lt;i&gt;</bpt><bpt id="5" ctype="x-xref">&lt;xref href="rrefsqlj81859.dita#rrefsqlj81859/rrefaltercolumndef"&gt;</bpt>columnDefinition<ept id="5">&lt;/xref&gt;</ept><ept id="4">&lt;/i&gt;</ept> | ADD <bpt id="6" ctype="x-i">&lt;i&gt;</bpt><bpt id="7" ctype="x-xref">&lt;xref href="rrefsqlj13590.dita#rrefsqlj13590"&gt;</bpt>CONSTRAINT clause<ept id="7">&lt;/xref&gt;</ept><ept id="6">&lt;/i&gt;</ept> | DROP [ COLUMN ] <bpt id="8" ctype="x-i">&lt;i&gt;</bpt><bpt id="9" ctype="x-xref">&lt;xref
href="rrefcolumnname.dita#rrefcolumnname"&gt;</bpt>columnName<ept id="9">&lt;/xref&gt;</ept><ept id="8">&lt;/i&gt;</ept> [ CASCADE | RESTRICT ] | DROP { PRIMARY KEY | FOREIGN KEY <bpt id="10" ctype="x-i">&lt;i&gt;</bpt><bpt id="11" ctype="x-xref">&lt;xref
href="rrefconstraintname.dita#rrefconstraintname"&gt;</bpt>constraintName<ept id="11">&lt;/xref&gt;</ept><ept id="10">&lt;/i&gt;</ept> | UNIQUE <bpt id="12" ctype="x-i">&lt;i&gt;</bpt><bpt id="13" ctype="x-xref">&lt;xref
href="rrefconstraintname.dita#rrefconstraintname"&gt;</bpt>constraintName<ept id="13">&lt;/xref&gt;</ept><ept id="12">&lt;/i&gt;</ept> | CHECK <bpt id="14" ctype="x-i">&lt;i&gt;</bpt><bpt id="15" ctype="x-xref">&lt;xref
href="rrefconstraintname.dita#rrefconstraintname"&gt;</bpt>constraintName<ept id="15">&lt;/xref&gt;</ept><ept id="14">&lt;/i&gt;</ept> | CONSTRAINT <bpt id="16" ctype="x-i">&lt;i&gt;</bpt><bpt id="17" ctype="x-xref">&lt;xref
href="rrefconstraintname.dita#rrefconstraintname"&gt;</bpt>constraintName<ept id="17">&lt;/xref&gt;</ept><ept id="16">&lt;/i&gt;</ept> } | ALTER [ COLUMN ] <bpt id="18" ctype="x-i">&lt;i&gt;</bpt><bpt id="19" ctype="x-xref">&lt;xref href="rrefsqlj81859.dita#rrefsqlj81859/rrefsqlj37860"&gt;</bpt>columnAlteration<ept id="19">&lt;/xref&gt;</ept><ept id="18">&lt;/i&gt;</ept> | LOCKSIZE { ROW | TABLE } }<ept id="1">&lt;/b&gt;</ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>ALTER TABLE <bpt id="2" ctype="x-i">&lt;i&gt;</bpt><bpt id="3" ctype="x-xref">&lt;xref href="rreftablename.dita#rreftablename"&gt;</bpt>tableName<ept id="3">&lt;/xref&gt;</ept><ept id="2">&lt;/i&gt;</ept> { ADD COLUMN <bpt id="4" ctype="x-i">&lt;i&gt;</bpt><bpt id="5" ctype="x-xref">&lt;xref href="rrefsqlj81859.dita#rrefsqlj81859/rrefaltercolumndef"&gt;</bpt>columnDefinition<ept id="5">&lt;/xref&gt;</ept><ept id="4">&lt;/i&gt;</ept> | ADD <bpt id="6" ctype="x-i">&lt;i&gt;</bpt><bpt id="7" ctype="x-xref">&lt;xref href="rrefsqlj13590.dita#rrefsqlj13590"&gt;</bpt>CONSTRAINT clause<ept id="7">&lt;/xref&gt;</ept><ept id="6">&lt;/i&gt;</ept> | DROP [ COLUMN ] <bpt id="8" ctype="x-i">&lt;i&gt;</bpt><bpt id="9" ctype="x-xref">&lt;xref
href="rrefcolumnname.dita#rrefcolumnname"&gt;</bpt>columnName<ept id="9">&lt;/xref&gt;</ept><ept id="8">&lt;/i&gt;</ept> [ CASCADE | RESTRICT ] | DROP { PRIMARY KEY | FOREIGN KEY <bpt id="10" ctype="x-i">&lt;i&gt;</bpt><bpt id="11" ctype="x-xref">&lt;xref
href="rrefconstraintname.dita#rrefconstraintname"&gt;</bpt>constraintName<ept id="11">&lt;/xref&gt;</ept><ept id="10">&lt;/i&gt;</ept> | UNIQUE <bpt id="12" ctype="x-i">&lt;i&gt;</bpt><bpt id="13" ctype="x-xref">&lt;xref
href="rrefconstraintname.dita#rrefconstraintname"&gt;</bpt>constraintName<ept id="13">&lt;/xref&gt;</ept><ept id="12">&lt;/i&gt;</ept> | CHECK <bpt id="14" ctype="x-i">&lt;i&gt;</bpt><bpt id="15" ctype="x-xref">&lt;xref
href="rrefconstraintname.dita#rrefconstraintname"&gt;</bpt>constraintName<ept id="15">&lt;/xref&gt;</ept><ept id="14">&lt;/i&gt;</ept> | CONSTRAINT <bpt id="16" ctype="x-i">&lt;i&gt;</bpt><bpt id="17" ctype="x-xref">&lt;xref
href="rrefconstraintname.dita#rrefconstraintname"&gt;</bpt>constraintName<ept id="17">&lt;/xref&gt;</ept><ept id="16">&lt;/i&gt;</ept> } | ALTER [ COLUMN ] <bpt id="18" ctype="x-i">&lt;i&gt;</bpt><bpt id="19" ctype="x-xref">&lt;xref href="rrefsqlj81859.dita#rrefsqlj81859/rrefsqlj37860"&gt;</bpt>columnAlteration<ept id="19">&lt;/xref&gt;</ept><ept id="18">&lt;/i&gt;</ept> | LOCKSIZE { ROW | TABLE } }<ept id="1">&lt;/b&gt;</ept></mrk></target>
</trans-unit>
<trans-unit id="tu37">
<source xml:lang="en">columnDefinition</source>
<seg-source><mrk mid="0" mtype="seg">columnDefinition</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">columnDefinition</mrk></target>
</trans-unit>
<trans-unit id="tu38">
<source xml:lang="en"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt><bpt id="2" ctype="x-i">&lt;i&gt;</bpt><bpt id="3" ctype="x-xref">&lt;xref
href="rrefsimplecolumnname.dita#rrefsimplecolumnname"&gt;</bpt>simpleColumnName<ept id="3">&lt;/xref&gt;</ept><ept id="2">&lt;/i&gt;</ept> [ <bpt id="4" ctype="x-i">&lt;i&gt;</bpt>dataType<ept id="4">&lt;/i&gt;</ept> ] [ <bpt id="5" ctype="x-i">&lt;i&gt;</bpt><bpt id="6" ctype="x-xref">&lt;xref href="rrefsqlj16095.dita#rrefsqlj16095"&gt;</bpt>columnLevelConstraint<ept id="6">&lt;/xref&gt;</ept><ept id="5">&lt;/i&gt;</ept> ]* [ [ WITH ] DEFAULT <bpt id="7" ctype="x-varname">&lt;varname&gt;</bpt>defaultConstantExpression<ept id="7">&lt;/varname&gt;</ept> | <bpt id="8" ctype="x-i">&lt;i&gt;</bpt><bpt id="9" ctype="x-xref">&lt;xref href="rrefsqljgenerationclause.dita#rrefsqljgenerationclause"&gt;</bpt>generationClause<ept id="9">&lt;/xref&gt;</ept><ept id="8">&lt;/i&gt;</ept> ]<ept id="1">&lt;/b&gt;</ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt><bpt id="2" ctype="x-i">&lt;i&gt;</bpt><bpt id="3" ctype="x-xref">&lt;xref
href="rrefsimplecolumnname.dita#rrefsimplecolumnname"&gt;</bpt>simpleColumnName<ept id="3">&lt;/xref&gt;</ept><ept id="2">&lt;/i&gt;</ept> [ <bpt id="4" ctype="x-i">&lt;i&gt;</bpt>dataType<ept id="4">&lt;/i&gt;</ept> ] [ <bpt id="5" ctype="x-i">&lt;i&gt;</bpt><bpt id="6" ctype="x-xref">&lt;xref href="rrefsqlj16095.dita#rrefsqlj16095"&gt;</bpt>columnLevelConstraint<ept id="6">&lt;/xref&gt;</ept><ept id="5">&lt;/i&gt;</ept> ]* [ [ WITH ] DEFAULT <bpt id="7" ctype="x-varname">&lt;varname&gt;</bpt>defaultConstantExpression<ept id="7">&lt;/varname&gt;</ept> | <bpt id="8" ctype="x-i">&lt;i&gt;</bpt><bpt id="9" ctype="x-xref">&lt;xref href="rrefsqljgenerationclause.dita#rrefsqljgenerationclause"&gt;</bpt>generationClause<ept id="9">&lt;/xref&gt;</ept><ept id="8">&lt;/i&gt;</ept> ]<ept id="1">&lt;/b&gt;</ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt><bpt id="2" ctype="x-i">&lt;i&gt;</bpt><bpt id="3" ctype="x-xref">&lt;xref
href="rrefsimplecolumnname.dita#rrefsimplecolumnname"&gt;</bpt>simpleColumnName<ept id="3">&lt;/xref&gt;</ept><ept id="2">&lt;/i&gt;</ept> [ <bpt id="4" ctype="x-i">&lt;i&gt;</bpt>dataType<ept id="4">&lt;/i&gt;</ept> ] [ <bpt id="5" ctype="x-i">&lt;i&gt;</bpt><bpt id="6" ctype="x-xref">&lt;xref href="rrefsqlj16095.dita#rrefsqlj16095"&gt;</bpt>columnLevelConstraint<ept id="6">&lt;/xref&gt;</ept><ept id="5">&lt;/i&gt;</ept> ]* [ [ WITH ] DEFAULT <bpt id="7" ctype="x-varname">&lt;varname&gt;</bpt>defaultConstantExpression<ept id="7">&lt;/varname&gt;</ept> | <bpt id="8" ctype="x-i">&lt;i&gt;</bpt><bpt id="9" ctype="x-xref">&lt;xref href="rrefsqljgenerationclause.dita#rrefsqljgenerationclause"&gt;</bpt>generationClause<ept id="9">&lt;/xref&gt;</ept><ept id="8">&lt;/i&gt;</ept> ]<ept id="1">&lt;/b&gt;</ept></mrk></target>
</trans-unit>
<trans-unit id="tu39">
<source xml:lang="en">The syntax for the <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>columnDefinition<ept id="1">&lt;/i&gt;</ept> for a new column is a subset of the syntax for a column in a <bpt id="2" ctype="x-xref">&lt;xref href="rrefsqlj24513.dita#rrefsqlj24513"&gt;</bpt>CREATE TABLE statement<ept id="2">&lt;/xref&gt;</ept>.</source>
<seg-source><mrk mid="0" mtype="seg">The syntax for the <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>columnDefinition<ept id="1">&lt;/i&gt;</ept> for a new column is a subset of the syntax for a column in a <bpt id="2" ctype="x-xref">&lt;xref href="rrefsqlj24513.dita#rrefsqlj24513"&gt;</bpt>CREATE TABLE statement<ept id="2">&lt;/xref&gt;</ept>.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">The syntax for the <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>columnDefinition<ept id="1">&lt;/i&gt;</ept> for a new column is a subset of the syntax for a column in a <bpt id="2" ctype="x-xref">&lt;xref href="rrefsqlj24513.dita#rrefsqlj24513"&gt;</bpt>CREATE TABLE statement<ept id="2">&lt;/xref&gt;</ept>.</mrk></target>
</trans-unit>
<trans-unit id="tu40">
<source xml:lang="en">The syntax of <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>DataType<ept id="1">&lt;/i&gt;</ept> is described in <bpt id="2" ctype="x-xref">&lt;xref href="crefsqlj31068.dita#crefsqlj31068"&gt;</bpt><ept id="2">&lt;/xref&gt;</ept>. The <bpt id="3" ctype="x-i">&lt;i&gt;</bpt>DataType<ept id="3">&lt;/i&gt;</ept> can be omitted only if you specify a <bpt id="4" ctype="x-i">&lt;i&gt;</bpt>generationClause<ept id="4">&lt;/i&gt;</ept>. If you omit the <bpt id="5" ctype="x-i">&lt;i&gt;</bpt>DataType<ept id="5">&lt;/i&gt;</ept>, the type of the generated column is the type of the <bpt id="6" ctype="x-i">&lt;i&gt;</bpt>generationClause<ept id="6">&lt;/i&gt;</ept>. If you specify both a <bpt id="7" ctype="x-i">&lt;i&gt;</bpt>DataType<ept id="7">&lt;/i&gt;</ept> and a <bpt id="8" ctype="x-i">&lt;i&gt;</bpt>generationClause<ept id="8">&lt;/i&gt;</ept>, the type of the <bpt id="9" ctype="x-i">&lt;i&gt;</bpt>generationClause<ept id="9">&lt;/i&gt;</ept> must be assignable to <bpt id="10" ctype="x-i">&lt;i&gt;</bpt>DataType<ept id="10">&lt;/i&gt;</ept>.</source>
<seg-source><mrk mid="0" mtype="seg">The syntax of <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>DataType<ept id="1">&lt;/i&gt;</ept> is described in <bpt id="2" ctype="x-xref">&lt;xref href="crefsqlj31068.dita#crefsqlj31068"&gt;</bpt><ept id="2">&lt;/xref&gt;</ept>.</mrk><mrk mid="1" mtype="seg"> The <bpt id="3" ctype="x-i">&lt;i&gt;</bpt>DataType<ept id="3">&lt;/i&gt;</ept> can be omitted only if you specify a <bpt id="4" ctype="x-i">&lt;i&gt;</bpt>generationClause<ept id="4">&lt;/i&gt;</ept>.</mrk><mrk mid="2" mtype="seg"> If you omit the <bpt id="5" ctype="x-i">&lt;i&gt;</bpt>DataType<ept id="5">&lt;/i&gt;</ept>, the type of the generated column is the type of the <bpt id="6" ctype="x-i">&lt;i&gt;</bpt>generationClause<ept id="6">&lt;/i&gt;</ept>.</mrk><mrk mid="3" mtype="seg"> If you specify both a <bpt id="7" ctype="x-i">&lt;i&gt;</bpt>DataType<ept id="7">&lt;/i&gt;</ept> and a <bpt id="8" ctype="x-i">&lt;i&gt;</bpt>generationClause<ept id="8">&lt;/i&gt;</ept>, the type of the <bpt id="9" ctype="x-i">&lt;i&gt;</bpt>generationClause<ept id="9">&lt;/i&gt;</ept> must be assignable to <bpt id="10" ctype="x-i">&lt;i&gt;</bpt>DataType<ept id="10">&lt;/i&gt;</ept>.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">The syntax of <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>DataType<ept id="1">&lt;/i&gt;</ept> is described in <bpt id="2" ctype="x-xref">&lt;xref href="crefsqlj31068.dita#crefsqlj31068"&gt;</bpt><ept id="2">&lt;/xref&gt;</ept>.</mrk><mrk mid="1" mtype="seg"> The <bpt id="3" ctype="x-i">&lt;i&gt;</bpt>DataType<ept id="3">&lt;/i&gt;</ept> can be omitted only if you specify a <bpt id="4" ctype="x-i">&lt;i&gt;</bpt>generationClause<ept id="4">&lt;/i&gt;</ept>.</mrk><mrk mid="2" mtype="seg"> If you omit the <bpt id="5" ctype="x-i">&lt;i&gt;</bpt>DataType<ept id="5">&lt;/i&gt;</ept>, the type of the generated column is the type of the <bpt id="6" ctype="x-i">&lt;i&gt;</bpt>generationClause<ept id="6">&lt;/i&gt;</ept>.</mrk><mrk mid="3" mtype="seg"> If you specify both a <bpt id="7" ctype="x-i">&lt;i&gt;</bpt>DataType<ept id="7">&lt;/i&gt;</ept> and a <bpt id="8" ctype="x-i">&lt;i&gt;</bpt>generationClause<ept id="8">&lt;/i&gt;</ept>, the type of the <bpt id="9" ctype="x-i">&lt;i&gt;</bpt>generationClause<ept id="9">&lt;/i&gt;</ept> must be assignable to <bpt id="10" ctype="x-i">&lt;i&gt;</bpt>DataType<ept id="10">&lt;/i&gt;</ept>.</mrk></target>
</trans-unit>
<trans-unit id="tu41">
<source xml:lang="en">For details on <bpt id="1" ctype="x-varname">&lt;varname&gt;</bpt>defaultConstantExpression<ept id="1">&lt;/varname&gt;</ept>, see <bpt id="2" ctype="x-xref">&lt;xref href="rrefsqlj30540.dita#rrefsqlj30540/sqlj64478"&gt;</bpt>Column default<ept id="2">&lt;/xref&gt;</ept>.</source>
<seg-source><mrk mid="0" mtype="seg">For details on <bpt id="1" ctype="x-varname">&lt;varname&gt;</bpt>defaultConstantExpression<ept id="1">&lt;/varname&gt;</ept>, see <bpt id="2" ctype="x-xref">&lt;xref href="rrefsqlj30540.dita#rrefsqlj30540/sqlj64478"&gt;</bpt>Column default<ept id="2">&lt;/xref&gt;</ept>.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">For details on <bpt id="1" ctype="x-varname">&lt;varname&gt;</bpt>defaultConstantExpression<ept id="1">&lt;/varname&gt;</ept>, see <bpt id="2" ctype="x-xref">&lt;xref href="rrefsqlj30540.dita#rrefsqlj30540/sqlj64478"&gt;</bpt>Column default<ept id="2">&lt;/xref&gt;</ept>.</mrk></target>
</trans-unit>
<trans-unit id="tu42">
<source xml:lang="en">columnAlteration</source>
<seg-source><mrk mid="0" mtype="seg">columnAlteration</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">columnAlteration</mrk></target>
</trans-unit>
<trans-unit id="tu43">
<source xml:lang="en"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt><bpt id="2" ctype="x-i">&lt;i&gt;</bpt>columnName<ept id="2">&lt;/i&gt;</ept> SET DATA TYPE VARCHAR( <bpt id="3" ctype="x-i">&lt;i&gt;</bpt>integer<ept id="3">&lt;/i&gt;</ept> ) | <bpt id="4" ctype="x-i">&lt;i&gt;</bpt>columnName<ept id="4">&lt;/i&gt;</ept> SET DATA TYPE VARCHAR FOR BIT DATA( <bpt id="5" ctype="x-i">&lt;i&gt;</bpt>integer<ept id="5">&lt;/i&gt;</ept> ) | <bpt id="6" ctype="x-i">&lt;i&gt;</bpt>columnName<ept id="6">&lt;/i&gt;</ept> SET INCREMENT BY <bpt id="7" ctype="x-i">&lt;i&gt;</bpt>integerConstant<ept id="7">&lt;/i&gt;</ept> | <bpt id="8" ctype="x-i">&lt;i&gt;</bpt>columnName<ept id="8">&lt;/i&gt;</ept> RESTART WITH <bpt id="9" ctype="x-i">&lt;i&gt;</bpt>integerConstant<ept id="9">&lt;/i&gt;</ept> | <bpt id="10" ctype="x-i">&lt;i&gt;</bpt>columnName<ept id="10">&lt;/i&gt;</ept> [ NOT ] NULL | <bpt id="11" ctype="x-i">&lt;i&gt;</bpt>columnName<ept id="11">&lt;/i&gt;</ept> [ WITH | SET ] DEFAULT <bpt id="12" ctype="x-i">&lt;i&gt;</bpt>defaultValue<ept id="12">&lt;/i&gt;</ept> | <bpt id="13" ctype="x-i">&lt;i&gt;</bpt>columnName<ept id="13">&lt;/i&gt;</ept> DROP DEFAULT<ept id="1">&lt;/b&gt;</ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt><bpt id="2" ctype="x-i">&lt;i&gt;</bpt>columnName<ept id="2">&lt;/i&gt;</ept> SET DATA TYPE VARCHAR( <bpt id="3" ctype="x-i">&lt;i&gt;</bpt>integer<ept id="3">&lt;/i&gt;</ept> ) | <bpt id="4" ctype="x-i">&lt;i&gt;</bpt>columnName<ept id="4">&lt;/i&gt;</ept> SET DATA TYPE VARCHAR FOR BIT DATA( <bpt id="5" ctype="x-i">&lt;i&gt;</bpt>integer<ept id="5">&lt;/i&gt;</ept> ) | <bpt id="6" ctype="x-i">&lt;i&gt;</bpt>columnName<ept id="6">&lt;/i&gt;</ept> SET INCREMENT BY <bpt id="7" ctype="x-i">&lt;i&gt;</bpt>integerConstant<ept id="7">&lt;/i&gt;</ept> | <bpt id="8" ctype="x-i">&lt;i&gt;</bpt>columnName<ept id="8">&lt;/i&gt;</ept> RESTART WITH <bpt id="9" ctype="x-i">&lt;i&gt;</bpt>integerConstant<ept id="9">&lt;/i&gt;</ept> | <bpt id="10" ctype="x-i">&lt;i&gt;</bpt>columnName<ept id="10">&lt;/i&gt;</ept> [ NOT ] NULL | <bpt id="11" ctype="x-i">&lt;i&gt;</bpt>columnName<ept id="11">&lt;/i&gt;</ept> [ WITH | SET ] DEFAULT <bpt id="12" ctype="x-i">&lt;i&gt;</bpt>defaultValue<ept id="12">&lt;/i&gt;</ept> | <bpt id="13" ctype="x-i">&lt;i&gt;</bpt>columnName<ept id="13">&lt;/i&gt;</ept> DROP DEFAULT<ept id="1">&lt;/b&gt;</ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt><bpt id="2" ctype="x-i">&lt;i&gt;</bpt>columnName<ept id="2">&lt;/i&gt;</ept> SET DATA TYPE VARCHAR( <bpt id="3" ctype="x-i">&lt;i&gt;</bpt>integer<ept id="3">&lt;/i&gt;</ept> ) | <bpt id="4" ctype="x-i">&lt;i&gt;</bpt>columnName<ept id="4">&lt;/i&gt;</ept> SET DATA TYPE VARCHAR FOR BIT DATA( <bpt id="5" ctype="x-i">&lt;i&gt;</bpt>integer<ept id="5">&lt;/i&gt;</ept> ) | <bpt id="6" ctype="x-i">&lt;i&gt;</bpt>columnName<ept id="6">&lt;/i&gt;</ept> SET INCREMENT BY <bpt id="7" ctype="x-i">&lt;i&gt;</bpt>integerConstant<ept id="7">&lt;/i&gt;</ept> | <bpt id="8" ctype="x-i">&lt;i&gt;</bpt>columnName<ept id="8">&lt;/i&gt;</ept> RESTART WITH <bpt id="9" ctype="x-i">&lt;i&gt;</bpt>integerConstant<ept id="9">&lt;/i&gt;</ept> | <bpt id="10" ctype="x-i">&lt;i&gt;</bpt>columnName<ept id="10">&lt;/i&gt;</ept> [ NOT ] NULL | <bpt id="11" ctype="x-i">&lt;i&gt;</bpt>columnName<ept id="11">&lt;/i&gt;</ept> [ WITH | SET ] DEFAULT <bpt id="12" ctype="x-i">&lt;i&gt;</bpt>defaultValue<ept id="12">&lt;/i&gt;</ept> | <bpt id="13" ctype="x-i">&lt;i&gt;</bpt>columnName<ept id="13">&lt;/i&gt;</ept> DROP DEFAULT<ept id="1">&lt;/b&gt;</ept></mrk></target>
</trans-unit>
<trans-unit id="tu44">
<source xml:lang="en">In the <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>columnAlteration<ept id="1">&lt;/i&gt;</ept>, SET INCREMENT BY <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>integerConstant<ept id="2">&lt;/i&gt;</ept> specifies the interval between consecutive values of the identity column. The next value to be generated for the identity column will be determined from the last assigned value with the increment applied. The column must already be defined with the IDENTITY attribute.</source>
<seg-source><mrk mid="0" mtype="seg">In the <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>columnAlteration<ept id="1">&lt;/i&gt;</ept>, SET INCREMENT BY <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>integerConstant<ept id="2">&lt;/i&gt;</ept> specifies the interval between consecutive values of the identity column.</mrk><mrk mid="1" mtype="seg"> The next value to be generated for the identity column will be determined from the last assigned value with the increment applied.</mrk><mrk mid="2" mtype="seg"> The column must already be defined with the IDENTITY attribute.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">In the <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>columnAlteration<ept id="1">&lt;/i&gt;</ept>, SET INCREMENT BY <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>integerConstant<ept id="2">&lt;/i&gt;</ept> specifies the interval between consecutive values of the identity column.</mrk><mrk mid="1" mtype="seg"> The next value to be generated for the identity column will be determined from the last assigned value with the increment applied.</mrk><mrk mid="2" mtype="seg"> The column must already be defined with the IDENTITY attribute.</mrk></target>
</trans-unit>
<trans-unit id="tu45">
<source xml:lang="en">RESTART WITH <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>integerConstant<ept id="1">&lt;/i&gt;</ept> specifies the next value to be generated for the identity column. RESTART WITH is useful for a table that has an identity column that was defined as GENERATED BY DEFAULT and that has a unique key defined on that identity column. Because GENERATED BY DEFAULT allows both manual inserts and system generated values, it is possible that manually inserted values can conflict with system generated values. To work around such conflicts, use the RESTART WITH syntax to specify the next value that will be generated for the identity column. Consider the following example, which involves a combination of automatically generated data and manually inserted data:</source>
<seg-source><mrk mid="0" mtype="seg">RESTART WITH <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>integerConstant<ept id="1">&lt;/i&gt;</ept> specifies the next value to be generated for the identity column.</mrk><mrk mid="1" mtype="seg"> RESTART WITH is useful for a table that has an identity column that was defined as GENERATED BY DEFAULT and that has a unique key defined on that identity column.</mrk><mrk mid="2" mtype="seg"> Because GENERATED BY DEFAULT allows both manual inserts and system generated values, it is possible that manually inserted values can conflict with system generated values.</mrk><mrk mid="3" mtype="seg"> To work around such conflicts, use the RESTART WITH syntax to specify the next value that will be generated for the identity column.</mrk><mrk mid="4" mtype="seg"> Consider the following example, which involves a combination of automatically generated data and manually inserted data:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">RESTART WITH <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>integerConstant<ept id="1">&lt;/i&gt;</ept> specifies the next value to be generated for the identity column.</mrk><mrk mid="1" mtype="seg"> RESTART WITH is useful for a table that has an identity column that was defined as GENERATED BY DEFAULT and that has a unique key defined on that identity column.</mrk><mrk mid="2" mtype="seg"> Because GENERATED BY DEFAULT allows both manual inserts and system generated values, it is possible that manually inserted values can conflict with system generated values.</mrk><mrk mid="3" mtype="seg"> To work around such conflicts, use the RESTART WITH syntax to specify the next value that will be generated for the identity column.</mrk><mrk mid="4" mtype="seg"> Consider the following example, which involves a combination of automatically generated data and manually inserted data:</mrk></target>
</trans-unit>
<trans-unit id="tu46">
<source xml:lang="en"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>CREATE TABLE tauto(i INT GENERATED BY DEFAULT AS IDENTITY, k INT) CREATE UNIQUE INDEX tautoInd ON tauto(i) INSERT INTO tauto(k) values 1,2<ept id="1">&lt;/b&gt;</ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>CREATE TABLE tauto(i INT GENERATED BY DEFAULT AS IDENTITY, k INT) CREATE UNIQUE INDEX tautoInd ON tauto(i) INSERT INTO tauto(k) values 1,2<ept id="1">&lt;/b&gt;</ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>CREATE TABLE tauto(i INT GENERATED BY DEFAULT AS IDENTITY, k INT) CREATE UNIQUE INDEX tautoInd ON tauto(i) INSERT INTO tauto(k) values 1,2<ept id="1">&lt;/b&gt;</ept></mrk></target>
</trans-unit>
<trans-unit id="tu47">
<source xml:lang="en">The system will automatically generate values for the identity column. But now you need to manually insert some data into the identity column:</source>
<seg-source><mrk mid="0" mtype="seg">The system will automatically generate values for the identity column.</mrk><mrk mid="1" mtype="seg"> But now you need to manually insert some data into the identity column:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">The system will automatically generate values for the identity column.</mrk><mrk mid="1" mtype="seg"> But now you need to manually insert some data into the identity column:</mrk></target>
</trans-unit>
<trans-unit id="tu48">
<source xml:lang="en"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>INSERT INTO tauto VALUES (3,3) INSERT INTO tauto VALUES (4,4) INSERT INTO tauto VALUES (5,5)<ept id="1">&lt;/b&gt;</ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>INSERT INTO tauto VALUES (3,3) INSERT INTO tauto VALUES (4,4) INSERT INTO tauto VALUES (5,5)<ept id="1">&lt;/b&gt;</ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>INSERT INTO tauto VALUES (3,3) INSERT INTO tauto VALUES (4,4) INSERT INTO tauto VALUES (5,5)<ept id="1">&lt;/b&gt;</ept></mrk></target>
</trans-unit>
<trans-unit id="tu49">
<source xml:lang="en">The identity column has used values 1 through 5 at this point. If you now want the system to generate a value, the system will generate a 3, which will result in a unique key exception because the value 3 has already been manually inserted. To compensate for the manual inserts, issue an ALTER TABLE statement for the identity column with RESTART WITH 6:</source>
<seg-source><mrk mid="0" mtype="seg">The identity column has used values 1 through 5 at this point.</mrk><mrk mid="1" mtype="seg"> If you now want the system to generate a value, the system will generate a 3, which will result in a unique key exception because the value 3 has already been manually inserted.</mrk><mrk mid="2" mtype="seg"> To compensate for the manual inserts, issue an ALTER TABLE statement for the identity column with RESTART WITH 6:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">The identity column has used values 1 through 5 at this point.</mrk><mrk mid="1" mtype="seg"> If you now want the system to generate a value, the system will generate a 3, which will result in a unique key exception because the value 3 has already been manually inserted.</mrk><mrk mid="2" mtype="seg"> To compensate for the manual inserts, issue an ALTER TABLE statement for the identity column with RESTART WITH 6:</mrk></target>
</trans-unit>
<trans-unit id="tu50">
<source xml:lang="en"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>ALTER TABLE tauto ALTER COLUMN i RESTART WITH 6<ept id="1">&lt;/b&gt;</ept></source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>ALTER TABLE tauto ALTER COLUMN i RESTART WITH 6<ept id="1">&lt;/b&gt;</ept></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-b">&lt;b&gt;</bpt>ALTER TABLE tauto ALTER COLUMN i RESTART WITH 6<ept id="1">&lt;/b&gt;</ept></mrk></target>
</trans-unit>
<trans-unit id="tu51">
<source xml:lang="en">ALTER TABLE does not affect any view that references the table being altered. This includes views that have an "*" in their SELECT list. You must drop and re-create those views if you wish them to return the new columns.</source>
<seg-source><mrk mid="0" mtype="seg">ALTER TABLE does not affect any view that references the table being altered.</mrk><mrk mid="1" mtype="seg"> This includes views that have an "*" in their SELECT list.</mrk><mrk mid="2" mtype="seg"> You must drop and re-create those views if you wish them to return the new columns.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">ALTER TABLE does not affect any view that references the table being altered.</mrk><mrk mid="1" mtype="seg"> This includes views that have an "*" in their SELECT list.</mrk><mrk mid="2" mtype="seg"> You must drop and re-create those views if you wish them to return the new columns.</mrk></target>
</trans-unit>
<trans-unit id="tu52">
<source xml:lang="en"><bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> raises an error if you try to change the <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>DataType<ept id="2">&lt;/i&gt;</ept> of a generated column to a type which is not assignable from the type of the <bpt id="3" ctype="x-i">&lt;i&gt;</bpt>generationClause<ept id="3">&lt;/i&gt;</ept>. <bpt id="4" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="4">&lt;/ph&gt;</ept> also raises an error if you try to add a DEFAULT clause to a generated column.</source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> raises an error if you try to change the <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>DataType<ept id="2">&lt;/i&gt;</ept> of a generated column to a type which is not assignable from the type of the <bpt id="3" ctype="x-i">&lt;i&gt;</bpt>generationClause<ept id="3">&lt;/i&gt;</ept>.</mrk><mrk mid="1" mtype="seg"> <bpt id="4" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="4">&lt;/ph&gt;</ept> also raises an error if you try to add a DEFAULT clause to a generated column.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> raises an error if you try to change the <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>DataType<ept id="2">&lt;/i&gt;</ept> of a generated column to a type which is not assignable from the type of the <bpt id="3" ctype="x-i">&lt;i&gt;</bpt>generationClause<ept id="3">&lt;/i&gt;</ept>.</mrk><mrk mid="1" mtype="seg"> <bpt id="4" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="4">&lt;/ph&gt;</ept> also raises an error if you try to add a DEFAULT clause to a generated column.</mrk></target>
</trans-unit>
<trans-unit id="tu53">
<source xml:lang="en">Adding columns</source>
<seg-source><mrk mid="0" mtype="seg">Adding columns</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Adding columns</mrk></target>
</trans-unit>
<trans-unit id="tu54">
<source xml:lang="en">The syntax for the <bpt id="1" ctype="x-i">&lt;i&gt;</bpt><bpt id="2" ctype="x-xref">&lt;xref
href="rrefsqlj81859.dita#rrefsqlj81859/rrefaltercolumndef"&gt;</bpt>columnDefinition<ept id="2">&lt;/xref
&gt;</ept><ept id="1">&lt;/i&gt;</ept> for a new column is almost the same as for a column in a CREATE TABLE statement. This syntax allows a column constraint to be placed on the new column within the ALTER TABLE ADD COLUMN statement. However, a column with a NOT NULL constraint can be added to an existing table if you give a default value; otherwise, an exception is thrown when the ALTER TABLE statement is executed.</source>
<seg-source><mrk mid="0" mtype="seg">The syntax for the <bpt id="1" ctype="x-i">&lt;i&gt;</bpt><bpt id="2" ctype="x-xref">&lt;xref
href="rrefsqlj81859.dita#rrefsqlj81859/rrefaltercolumndef"&gt;</bpt>columnDefinition<ept id="2">&lt;/xref
&gt;</ept><ept id="1">&lt;/i&gt;</ept> for a new column is almost the same as for a column in a CREATE TABLE statement.</mrk><mrk mid="1" mtype="seg"> This syntax allows a column constraint to be placed on the new column within the ALTER TABLE ADD COLUMN statement.</mrk><mrk mid="2" mtype="seg"> However, a column with a NOT NULL constraint can be added to an existing table if you give a default value; otherwise, an exception is thrown when the ALTER TABLE statement is executed.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">The syntax for the <bpt id="1" ctype="x-i">&lt;i&gt;</bpt><bpt id="2" ctype="x-xref">&lt;xref
href="rrefsqlj81859.dita#rrefsqlj81859/rrefaltercolumndef"&gt;</bpt>columnDefinition<ept id="2">&lt;/xref
&gt;</ept><ept id="1">&lt;/i&gt;</ept> for a new column is almost the same as for a column in a CREATE TABLE statement.</mrk><mrk mid="1" mtype="seg"> This syntax allows a column constraint to be placed on the new column within the ALTER TABLE ADD COLUMN statement.</mrk><mrk mid="2" mtype="seg"> However, a column with a NOT NULL constraint can be added to an existing table if you give a default value; otherwise, an exception is thrown when the ALTER TABLE statement is executed.</mrk></target>
</trans-unit>
<trans-unit id="tu55">
<source xml:lang="en">Just as in CREATE TABLE, if the column definition includes a primary key constraint, the column cannot contain null values, so the NOT NULL attribute must also be specified (SQLSTATE 42831).</source>
<seg-source><mrk mid="0" mtype="seg">Just as in CREATE TABLE, if the column definition includes a primary key constraint, the column cannot contain null values, so the NOT NULL attribute must also be specified (SQLSTATE 42831).</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Just as in CREATE TABLE, if the column definition includes a primary key constraint, the column cannot contain null values, so the NOT NULL attribute must also be specified (SQLSTATE 42831).</mrk></target>
</trans-unit>
<trans-unit id="tu56">
<source xml:lang="en">If a table has an UPDATE trigger without an explicit column list, adding a column to that table in effect adds that column to the implicit update column list upon which the trigger is defined, and all references to transition variables are invalidated so that they pick up the new column.</source>
<seg-source><mrk mid="0" mtype="seg">If a table has an UPDATE trigger without an explicit column list, adding a column to that table in effect adds that column to the implicit update column list upon which the trigger is defined, and all references to transition variables are invalidated so that they pick up the new column.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">If a table has an UPDATE trigger without an explicit column list, adding a column to that table in effect adds that column to the implicit update column list upon which the trigger is defined, and all references to transition variables are invalidated so that they pick up the new column.</mrk></target>
</trans-unit>
<trans-unit id="tu57">
<source xml:lang="en">If you add a generated column to a table, <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> computes the generated values for all existing rows in the table.</source>
<seg-source><mrk mid="0" mtype="seg">If you add a generated column to a table, <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> computes the generated values for all existing rows in the table.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">If you add a generated column to a table, <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> computes the generated values for all existing rows in the table.</mrk></target>
</trans-unit>
<trans-unit id="tu58">
<source xml:lang="en">ALTER TABLE ADD COLUMN adds the new column at the end of the table row. If you need to change a column in a way not permitted by ALTER TABLE ALTER COLUMN (for example, if you need to change its data type), the only way to do so is to drop the column and add a new one, and this changes the ordering of the columns.</source>
<seg-source><mrk mid="0" mtype="seg">ALTER TABLE ADD COLUMN adds the new column at the end of the table row.</mrk><mrk mid="1" mtype="seg"> If you need to change a column in a way not permitted by ALTER TABLE ALTER COLUMN (for example, if you need to change its data type), the only way to do so is to drop the column and add a new one, and this changes the ordering of the columns.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">ALTER TABLE ADD COLUMN adds the new column at the end of the table row.</mrk><mrk mid="1" mtype="seg"> If you need to change a column in a way not permitted by ALTER TABLE ALTER COLUMN (for example, if you need to change its data type), the only way to do so is to drop the column and add a new one, and this changes the ordering of the columns.</mrk></target>
</trans-unit>
<trans-unit id="tu59">
<source xml:lang="en">Adding constraints</source>
<seg-source><mrk mid="0" mtype="seg">Adding constraints</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Adding constraints</mrk></target>
</trans-unit>
<trans-unit id="tu60">
<source xml:lang="en">ALTER TABLE ADD CONSTRAINT adds a table-level constraint to an existing table. Any supported table-level constraint type can be added via ALTER TABLE. The following limitations exist on adding a constraint to an existing table:</source>
<seg-source><mrk mid="0" mtype="seg">ALTER TABLE ADD CONSTRAINT adds a table-level constraint to an existing table.</mrk><mrk mid="1" mtype="seg"> Any supported table-level constraint type can be added via ALTER TABLE.</mrk><mrk mid="2" mtype="seg"> The following limitations exist on adding a constraint to an existing table:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">ALTER TABLE ADD CONSTRAINT adds a table-level constraint to an existing table.</mrk><mrk mid="1" mtype="seg"> Any supported table-level constraint type can be added via ALTER TABLE.</mrk><mrk mid="2" mtype="seg"> The following limitations exist on adding a constraint to an existing table:</mrk></target>
</trans-unit>
<trans-unit id="tu61">
<source xml:lang="en">When adding a foreign key or check constraint to an existing table, <bpt id="1" ctype="x-ph">&lt;ph
conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> checks the table to make sure existing rows satisfy the constraint. If any row is invalid, <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> throws a statement exception and the constraint is not added.</source>
<seg-source><mrk mid="0" mtype="seg">When adding a foreign key or check constraint to an existing table, <bpt id="1" ctype="x-ph">&lt;ph
conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> checks the table to make sure existing rows satisfy the constraint.</mrk><mrk mid="1" mtype="seg"> If any row is invalid, <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> throws a statement exception and the constraint is not added.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">When adding a foreign key or check constraint to an existing table, <bpt id="1" ctype="x-ph">&lt;ph
conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> checks the table to make sure existing rows satisfy the constraint.</mrk><mrk mid="1" mtype="seg"> If any row is invalid, <bpt id="2" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="2">&lt;/ph&gt;</ept> throws a statement exception and the constraint is not added.</mrk></target>
</trans-unit>
<trans-unit id="tu62">
<source xml:lang="en">All columns included in a primary key must contain non null data and be unique.</source>
<seg-source><mrk mid="0" mtype="seg">All columns included in a primary key must contain non null data and be unique.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">All columns included in a primary key must contain non null data and be unique.</mrk></target>
</trans-unit>
<trans-unit id="tu63">
<source xml:lang="en">ALTER TABLE ADD UNIQUE or PRIMARY KEY provide a shorthand method of defining a primary key composed of a single column. If PRIMARY KEY is specified in the definition of column C, the effect is the same as if the PRIMARY KEY(C) clause were specified as a separate clause. The column cannot contain null values, so the NOT NULL attribute must also be specified.</source>
<seg-source><mrk mid="0" mtype="seg">ALTER TABLE ADD UNIQUE or PRIMARY KEY provide a shorthand method of defining a primary key composed of a single column.</mrk><mrk mid="1" mtype="seg"> If PRIMARY KEY is specified in the definition of column C, the effect is the same as if the PRIMARY KEY(C) clause were specified as a separate clause.</mrk><mrk mid="2" mtype="seg"> The column cannot contain null values, so the NOT NULL attribute must also be specified.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">ALTER TABLE ADD UNIQUE or PRIMARY KEY provide a shorthand method of defining a primary key composed of a single column.</mrk><mrk mid="1" mtype="seg"> If PRIMARY KEY is specified in the definition of column C, the effect is the same as if the PRIMARY KEY(C) clause were specified as a separate clause.</mrk><mrk mid="2" mtype="seg"> The column cannot contain null values, so the NOT NULL attribute must also be specified.</mrk></target>
</trans-unit>
<trans-unit id="tu64">
<source xml:lang="en">For information on the syntax of constraints, see <bpt id="1" ctype="x-xref">&lt;xref href="rrefsqlj13590.dita#rrefsqlj13590"&gt;</bpt><ept id="1">&lt;/xref&gt;</ept>. Use the syntax for table-level constraint when adding a constraint with the ADD TABLE ADD CONSTRAINT syntax.</source>
<seg-source><mrk mid="0" mtype="seg">For information on the syntax of constraints, see <bpt id="1" ctype="x-xref">&lt;xref href="rrefsqlj13590.dita#rrefsqlj13590"&gt;</bpt><ept id="1">&lt;/xref&gt;</ept>.</mrk><mrk mid="1" mtype="seg"> Use the syntax for table-level constraint when adding a constraint with the ADD TABLE ADD CONSTRAINT syntax.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">For information on the syntax of constraints, see <bpt id="1" ctype="x-xref">&lt;xref href="rrefsqlj13590.dita#rrefsqlj13590"&gt;</bpt><ept id="1">&lt;/xref&gt;</ept>.</mrk><mrk mid="1" mtype="seg"> Use the syntax for table-level constraint when adding a constraint with the ADD TABLE ADD CONSTRAINT syntax.</mrk></target>
</trans-unit>
<trans-unit id="tu65">
<source xml:lang="en">Dropping columns</source>
<seg-source><mrk mid="0" mtype="seg">Dropping columns</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Dropping columns</mrk></target>
</trans-unit>
<trans-unit id="tu66">
<source xml:lang="en">ALTER TABLE DROP COLUMN allows you to drop a column from a table.</source>
<seg-source><mrk mid="0" mtype="seg">ALTER TABLE DROP COLUMN allows you to drop a column from a table.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">ALTER TABLE DROP COLUMN allows you to drop a column from a table.</mrk></target>
</trans-unit>
<trans-unit id="tu67">
<source xml:lang="en">The keyword COLUMN is optional.</source>
<seg-source><mrk mid="0" mtype="seg">The keyword COLUMN is optional.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">The keyword COLUMN is optional.</mrk></target>
</trans-unit>
<trans-unit id="tu68">
<source xml:lang="en">The keywords CASCADE and RESTRICT are also optional. If you specify neither CASCADE nor RESTRICT, the default is CASCADE.</source>
<seg-source><mrk mid="0" mtype="seg">The keywords CASCADE and RESTRICT are also optional.</mrk><mrk mid="1" mtype="seg"> If you specify neither CASCADE nor RESTRICT, the default is CASCADE.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">The keywords CASCADE and RESTRICT are also optional.</mrk><mrk mid="1" mtype="seg"> If you specify neither CASCADE nor RESTRICT, the default is CASCADE.</mrk></target>
</trans-unit>
<trans-unit id="tu69">
<source xml:lang="en">If you specify RESTRICT, then the column drop will be rejected if it would cause a dependent schema object to become invalid.</source>
<seg-source><mrk mid="0" mtype="seg">If you specify RESTRICT, then the column drop will be rejected if it would cause a dependent schema object to become invalid.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">If you specify RESTRICT, then the column drop will be rejected if it would cause a dependent schema object to become invalid.</mrk></target>
</trans-unit>
<trans-unit id="tu70">
<source xml:lang="en">If you specify CASCADE, then the column drop should additionally drop other schema objects which have become invalid.</source>
<seg-source><mrk mid="0" mtype="seg">If you specify CASCADE, then the column drop should additionally drop other schema objects which have become invalid.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">If you specify CASCADE, then the column drop should additionally drop other schema objects which have become invalid.</mrk></target>
</trans-unit>
<trans-unit id="tu71">
<source xml:lang="en">The schema objects which can cause a DROP COLUMN RESTRICT to be rejected include: views, triggers, primary key constraints, foreign key constraints, unique key constraints, check constraints, and column privileges. If one of these types of objects depends on the column being dropped, DROP COLUMN RESTRICT will reject the statement.</source>
<seg-source><mrk mid="0" mtype="seg">The schema objects which can cause a DROP COLUMN RESTRICT to be rejected include: views, triggers, primary key constraints, foreign key constraints, unique key constraints, check constraints, and column privileges.</mrk><mrk mid="1" mtype="seg"> If one of these types of objects depends on the column being dropped, DROP COLUMN RESTRICT will reject the statement.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">The schema objects which can cause a DROP COLUMN RESTRICT to be rejected include: views, triggers, primary key constraints, foreign key constraints, unique key constraints, check constraints, and column privileges.</mrk><mrk mid="1" mtype="seg"> If one of these types of objects depends on the column being dropped, DROP COLUMN RESTRICT will reject the statement.</mrk></target>
</trans-unit>
<trans-unit id="tu72">
<source xml:lang="en"><bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> also raises an error if you specify RESTRICT when you drop a column referenced by the <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>generationClause<ept id="2">&lt;/i&gt;</ept> of a generated column. However, if you specify CASCADE, the generated column is also dropped with CASCADE semantics.</source>
<seg-source><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> also raises an error if you specify RESTRICT when you drop a column referenced by the <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>generationClause<ept id="2">&lt;/i&gt;</ept> of a generated column.</mrk><mrk mid="1" mtype="seg"> However, if you specify CASCADE, the generated column is also dropped with CASCADE semantics.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> also raises an error if you specify RESTRICT when you drop a column referenced by the <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>generationClause<ept id="2">&lt;/i&gt;</ept> of a generated column.</mrk><mrk mid="1" mtype="seg"> However, if you specify CASCADE, the generated column is also dropped with CASCADE semantics.</mrk></target>
</trans-unit>
<trans-unit id="tu73">
<source xml:lang="en">You may not drop the last (only) column in a table.</source>
<seg-source><mrk mid="0" mtype="seg">You may not drop the last (only) column in a table.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">You may not drop the last (only) column in a table.</mrk></target>
</trans-unit>
<trans-unit id="tu74">
<source xml:lang="en">CASCADE/RESTRICT doesn't consider whether the column being dropped is used in any indexes. When a column is dropped, it is removed from any indexes which contain it. If that column was the only column in the index, the entire index is dropped.</source>
<seg-source><mrk mid="0" mtype="seg">CASCADE/RESTRICT doesn't consider whether the column being dropped is used in any indexes.</mrk><mrk mid="1" mtype="seg"> When a column is dropped, it is removed from any indexes which contain it.</mrk><mrk mid="2" mtype="seg"> If that column was the only column in the index, the entire index is dropped.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">CASCADE/RESTRICT doesn't consider whether the column being dropped is used in any indexes.</mrk><mrk mid="1" mtype="seg"> When a column is dropped, it is removed from any indexes which contain it.</mrk><mrk mid="2" mtype="seg"> If that column was the only column in the index, the entire index is dropped.</mrk></target>
</trans-unit>
<trans-unit id="tu75">
<source xml:lang="en">Dropping constraints</source>
<seg-source><mrk mid="0" mtype="seg">Dropping constraints</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Dropping constraints</mrk></target>
</trans-unit>
<trans-unit id="tu76">
<source xml:lang="en">ALTER TABLE DROP CONSTRAINT drops a constraint on an existing table. To drop an unnamed constraint, you must specify the generated constraint name stored in <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>SYS.SYSCONSTRAINTS<ept id="1">&lt;/i&gt;</ept> as a delimited identifier.</source>
<seg-source><mrk mid="0" mtype="seg">ALTER TABLE DROP CONSTRAINT drops a constraint on an existing table.</mrk><mrk mid="1" mtype="seg"> To drop an unnamed constraint, you must specify the generated constraint name stored in <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>SYS.SYSCONSTRAINTS<ept id="1">&lt;/i&gt;</ept> as a delimited identifier.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">ALTER TABLE DROP CONSTRAINT drops a constraint on an existing table.</mrk><mrk mid="1" mtype="seg"> To drop an unnamed constraint, you must specify the generated constraint name stored in <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>SYS.SYSCONSTRAINTS<ept id="1">&lt;/i&gt;</ept> as a delimited identifier.</mrk></target>
</trans-unit>
<trans-unit id="tu77">
<source xml:lang="en">Dropping a primary key, unique, or foreign key constraint drops the physical index that enforces the constraint (also known as a <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>backing index<ept id="1">&lt;/i&gt;</ept>).</source>
<seg-source><mrk mid="0" mtype="seg">Dropping a primary key, unique, or foreign key constraint drops the physical index that enforces the constraint (also known as a <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>backing index<ept id="1">&lt;/i&gt;</ept>).</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Dropping a primary key, unique, or foreign key constraint drops the physical index that enforces the constraint (also known as a <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>backing index<ept id="1">&lt;/i&gt;</ept>).</mrk></target>
</trans-unit>
<trans-unit id="tu78">
<source xml:lang="en">Modifying columns</source>
<seg-source><mrk mid="0" mtype="seg">Modifying columns</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Modifying columns</mrk></target>
</trans-unit>
<trans-unit id="tu79">
<source xml:lang="en">The <bpt id="1" ctype="x-i">&lt;i&gt;</bpt><bpt id="2" ctype="x-xref">&lt;xref href="rrefsqlj81859.dita#rrefsqlj81859/rrefsqlj37860"&gt;</bpt>columnAlteration<ept id="2">&lt;/xref&gt;</ept><ept id="1">&lt;/i&gt;</ept> allows you to alter the named column in the following ways:</source>
<seg-source><mrk mid="0" mtype="seg">The <bpt id="1" ctype="x-i">&lt;i&gt;</bpt><bpt id="2" ctype="x-xref">&lt;xref href="rrefsqlj81859.dita#rrefsqlj81859/rrefsqlj37860"&gt;</bpt>columnAlteration<ept id="2">&lt;/xref&gt;</ept><ept id="1">&lt;/i&gt;</ept> allows you to alter the named column in the following ways:</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">The <bpt id="1" ctype="x-i">&lt;i&gt;</bpt><bpt id="2" ctype="x-xref">&lt;xref href="rrefsqlj81859.dita#rrefsqlj81859/rrefsqlj37860"&gt;</bpt>columnAlteration<ept id="2">&lt;/xref&gt;</ept><ept id="1">&lt;/i&gt;</ept> allows you to alter the named column in the following ways:</mrk></target>
</trans-unit>
<trans-unit id="tu80">
<source xml:lang="en">Increasing the width of an existing VARCHAR or VARCHAR FOR BIT DATA column. CHARACTER VARYING or CHAR VARYING can be used as synonyms for the VARCHAR keyword.</source>
<seg-source><mrk mid="0" mtype="seg">Increasing the width of an existing VARCHAR or VARCHAR FOR BIT DATA column.</mrk><mrk mid="1" mtype="seg"> CHARACTER VARYING or CHAR VARYING can be used as synonyms for the VARCHAR keyword.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Increasing the width of an existing VARCHAR or VARCHAR FOR BIT DATA column.</mrk><mrk mid="1" mtype="seg"> CHARACTER VARYING or CHAR VARYING can be used as synonyms for the VARCHAR keyword.</mrk></target>
</trans-unit>
<trans-unit id="tu81">
<source xml:lang="en">To increase the width of a column of these types, specify the data type and new size after the column name.</source>
<seg-source><mrk mid="0" mtype="seg">To increase the width of a column of these types, specify the data type and new size after the column name.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">To increase the width of a column of these types, specify the data type and new size after the column name.</mrk></target>
</trans-unit>
<trans-unit id="tu82">
<source xml:lang="en">You are not allowed to decrease the width or to change the data type. You are not allowed to increase the width of a column that is part of a primary or unique key referenced by a foreign key constraint or that is part of a foreign key constraint.</source>
<seg-source><mrk mid="0" mtype="seg">You are not allowed to decrease the width or to change the data type.</mrk><mrk mid="1" mtype="seg"> You are not allowed to increase the width of a column that is part of a primary or unique key referenced by a foreign key constraint or that is part of a foreign key constraint.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">You are not allowed to decrease the width or to change the data type.</mrk><mrk mid="1" mtype="seg"> You are not allowed to increase the width of a column that is part of a primary or unique key referenced by a foreign key constraint or that is part of a foreign key constraint.</mrk></target>
</trans-unit>
<trans-unit id="tu83">
<source xml:lang="en">Specifying the interval between consecutive values of the identity column.</source>
<seg-source><mrk mid="0" mtype="seg">Specifying the interval between consecutive values of the identity column.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Specifying the interval between consecutive values of the identity column.</mrk></target>
</trans-unit>
<trans-unit id="tu84">
<source xml:lang="en">To set an interval between consecutive values of the identity column, specify the <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>integerConstant<ept id="1">&lt;/i&gt;</ept>. You must previously define the column with the IDENTITY attribute (SQLSTATE 42837). If there are existing rows in the table, the values in the column for which the SET INCREMENT default was added do not change.</source>
<seg-source><mrk mid="0" mtype="seg">To set an interval between consecutive values of the identity column, specify the <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>integerConstant<ept id="1">&lt;/i&gt;</ept>.</mrk><mrk mid="1" mtype="seg"> You must previously define the column with the IDENTITY attribute (SQLSTATE 42837).</mrk><mrk mid="2" mtype="seg"> If there are existing rows in the table, the values in the column for which the SET INCREMENT default was added do not change.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">To set an interval between consecutive values of the identity column, specify the <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>integerConstant<ept id="1">&lt;/i&gt;</ept>.</mrk><mrk mid="1" mtype="seg"> You must previously define the column with the IDENTITY attribute (SQLSTATE 42837).</mrk><mrk mid="2" mtype="seg"> If there are existing rows in the table, the values in the column for which the SET INCREMENT default was added do not change.</mrk></target>
</trans-unit>
<trans-unit id="tu85">
<source xml:lang="en">Modifying the nullability constraint of a column.</source>
<seg-source><mrk mid="0" mtype="seg">Modifying the nullability constraint of a column.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Modifying the nullability constraint of a column.</mrk></target>
</trans-unit>
<trans-unit id="tu86">
<source xml:lang="en">You can add the NOT NULL constraint to an existing column. To do so there must not be existing NULL values for the column in the table.</source>
<seg-source><mrk mid="0" mtype="seg">You can add the NOT NULL constraint to an existing column.</mrk><mrk mid="1" mtype="seg"> To do so there must not be existing NULL values for the column in the table.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">You can add the NOT NULL constraint to an existing column.</mrk><mrk mid="1" mtype="seg"> To do so there must not be existing NULL values for the column in the table.</mrk></target>
</trans-unit>
<trans-unit id="tu87">
<source xml:lang="en">You can remove the NOT NULL constraint from an existing column. To do so the column must not be used in a PRIMARY KEY constraint.</source>
<seg-source><mrk mid="0" mtype="seg">You can remove the NOT NULL constraint from an existing column.</mrk><mrk mid="1" mtype="seg"> To do so the column must not be used in a PRIMARY KEY constraint.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">You can remove the NOT NULL constraint from an existing column.</mrk><mrk mid="1" mtype="seg"> To do so the column must not be used in a PRIMARY KEY constraint.</mrk></target>
</trans-unit>
<trans-unit id="tu88">
<source xml:lang="en">Changing the default value for a column.</source>
<seg-source><mrk mid="0" mtype="seg">Changing the default value for a column.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Changing the default value for a column.</mrk></target>
</trans-unit>
<trans-unit id="tu89">
<source xml:lang="en">You can use DEFAULT <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>default-value<ept id="1">&lt;/i&gt;</ept> to change a column default. To disable a previously set default, use DROP DEFAULT (alternatively, you can specify NULL as the <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>default-value<ept id="2">&lt;/i&gt;</ept>).</source>
<seg-source><mrk mid="0" mtype="seg">You can use DEFAULT <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>default-value<ept id="1">&lt;/i&gt;</ept> to change a column default.</mrk><mrk mid="1" mtype="seg"> To disable a previously set default, use DROP DEFAULT (alternatively, you can specify NULL as the <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>default-value<ept id="2">&lt;/i&gt;</ept>).</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">You can use DEFAULT <bpt id="1" ctype="x-i">&lt;i&gt;</bpt>default-value<ept id="1">&lt;/i&gt;</ept> to change a column default.</mrk><mrk mid="1" mtype="seg"> To disable a previously set default, use DROP DEFAULT (alternatively, you can specify NULL as the <bpt id="2" ctype="x-i">&lt;i&gt;</bpt>default-value<ept id="2">&lt;/i&gt;</ept>).</mrk></target>
</trans-unit>
<trans-unit id="tu90">
<source xml:lang="en">Setting defaults</source>
<seg-source><mrk mid="0" mtype="seg">Setting defaults</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Setting defaults</mrk></target>
</trans-unit>
<trans-unit id="tu91">
<source xml:lang="en">You can specify a default value for a new column. A default value is the value that is inserted into a column if no other value is specified. If not explicitly specified, the default value of a column is NULL. If you add a default to a new column, existing rows in the table gain the default value in the new column.</source>
<seg-source><mrk mid="0" mtype="seg">You can specify a default value for a new column.</mrk><mrk mid="1" mtype="seg"> A default value is the value that is inserted into a column if no other value is specified.</mrk><mrk mid="2" mtype="seg"> If not explicitly specified, the default value of a column is NULL.</mrk><mrk mid="3" mtype="seg"> If you add a default to a new column, existing rows in the table gain the default value in the new column.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">You can specify a default value for a new column.</mrk><mrk mid="1" mtype="seg"> A default value is the value that is inserted into a column if no other value is specified.</mrk><mrk mid="2" mtype="seg"> If not explicitly specified, the default value of a column is NULL.</mrk><mrk mid="3" mtype="seg"> If you add a default to a new column, existing rows in the table gain the default value in the new column.</mrk></target>
</trans-unit>
<trans-unit id="tu92">
<source xml:lang="en">For more information about defaults, see <bpt id="1" ctype="x-xref">&lt;xref href="rrefsqlj24513.dita#rrefsqlj24513"&gt;</bpt><ept id="1">&lt;/xref&gt;</ept>.</source>
<seg-source><mrk mid="0" mtype="seg">For more information about defaults, see <bpt id="1" ctype="x-xref">&lt;xref href="rrefsqlj24513.dita#rrefsqlj24513"&gt;</bpt><ept id="1">&lt;/xref&gt;</ept>.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">For more information about defaults, see <bpt id="1" ctype="x-xref">&lt;xref href="rrefsqlj24513.dita#rrefsqlj24513"&gt;</bpt><ept id="1">&lt;/xref&gt;</ept>.</mrk></target>
</trans-unit>
<trans-unit id="tu93">
<source xml:lang="en">Changing the lock granularity for the table</source>
<seg-source><mrk mid="0" mtype="seg">Changing the lock granularity for the table</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Changing the lock granularity for the table</mrk></target>
</trans-unit>
<trans-unit id="tu94">
<source xml:lang="en">The LOCKSIZE clause allows you to override row-level locking for the specific table, if your system uses the default setting of row-level locking. (If your system is set for table-level locking, you cannot change the locking granularity to row-level locking, although <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> allows you to use the LOCKSIZE clause in such a situation without throwing an exception.) To override row-level locking for the specific table, set locking for the table to TABLE. If you created the table with table-level locking granularity, you can change locking back to ROW with the LOCKSIZE clause in the ALTER TABLE STATEMENT. For information about why this is sometimes useful, see <bpt id="2" ctype="x-cite">&lt;cite&gt;</bpt><bpt id="3" ctype="x-ph">&lt;ph
conref="../conrefs.dita#pub/cittuning"&gt;</bpt><ept id="3">&lt;/ph&gt;</ept><ept id="2">&lt;/cite&gt;</ept>.</source>
<seg-source><mrk mid="0" mtype="seg">The LOCKSIZE clause allows you to override row-level locking for the specific table, if your system uses the default setting of row-level locking.</mrk><mrk mid="1" mtype="seg"> (If your system is set for table-level locking, you cannot change the locking granularity to row-level locking, although <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> allows you to use the LOCKSIZE clause in such a situation without throwing an exception.) To override row-level locking for the specific table, set locking for the table to TABLE.</mrk><mrk mid="2" mtype="seg"> If you created the table with table-level locking granularity, you can change locking back to ROW with the LOCKSIZE clause in the ALTER TABLE STATEMENT.</mrk><mrk mid="3" mtype="seg"> For information about why this is sometimes useful, see <bpt id="2" ctype="x-cite">&lt;cite&gt;</bpt><bpt id="3" ctype="x-ph">&lt;ph
conref="../conrefs.dita#pub/cittuning"&gt;</bpt><ept id="3">&lt;/ph&gt;</ept><ept id="2">&lt;/cite&gt;</ept>.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">The LOCKSIZE clause allows you to override row-level locking for the specific table, if your system uses the default setting of row-level locking.</mrk><mrk mid="1" mtype="seg"> (If your system is set for table-level locking, you cannot change the locking granularity to row-level locking, although <bpt id="1" ctype="x-ph">&lt;ph conref="../conrefs.dita#prod/productshortname"&gt;</bpt><ept id="1">&lt;/ph&gt;</ept> allows you to use the LOCKSIZE clause in such a situation without throwing an exception.) To override row-level locking for the specific table, set locking for the table to TABLE.</mrk><mrk mid="2" mtype="seg"> If you created the table with table-level locking granularity, you can change locking back to ROW with the LOCKSIZE clause in the ALTER TABLE STATEMENT.</mrk><mrk mid="3" mtype="seg"> For information about why this is sometimes useful, see <bpt id="2" ctype="x-cite">&lt;cite&gt;</bpt><bpt id="3" ctype="x-ph">&lt;ph
conref="../conrefs.dita#pub/cittuning"&gt;</bpt><ept id="3">&lt;/ph&gt;</ept><ept id="2">&lt;/cite&gt;</ept>.</mrk></target>
</trans-unit>
<trans-unit id="tu95">
<source xml:lang="en">Examples</source>
<seg-source><mrk mid="0" mtype="seg">Examples</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Examples</mrk></target>
</trans-unit>
<trans-unit id="tu96">
<source xml:lang="en"><it id="1" ctype="x-b" pos="open">&lt;b&gt;</it><bpt id="2" ctype="x-ph">&lt;ph&gt;</bpt>-- Add a new column with a column-level constraint -- to an existing table -- An exception will be thrown if the table -- contains any rows -- since the newcol will be initialized to NULL -- in all existing rows in the table<ept id="2">&lt;/ph&gt;</ept> ALTER TABLE CITIES ADD COLUMN REGION VARCHAR(26) CONSTRAINT NEW_CONSTRAINT CHECK (REGION IS NOT NULL); <bpt id="3" ctype="x-ph">&lt;ph&gt;</bpt>-- Add a new unique constraint to an existing table -- An exception will be thrown if duplicate keys are found<ept id="3">&lt;/ph&gt;</ept> ALTER TABLE SAMP.DEPARTMENT ADD CONSTRAINT NEW_UNIQUE UNIQUE (DEPTNO); <it id="4" ctype="x-ph" pos="open">&lt;ph&gt;</it>-- add a new foreign key constraint to the -- Cities table. Each row in Cities is checked -- to make sure it satisfied the constraints. -- if any rows don't satisfy the constraint, the -- constraint is not added<it id="4" ctype="x-ph" pos="close">&lt;/ph&gt;</it> ALTER TABLE CITIES ADD CONSTRAINT COUNTRY_FK Foreign Key (COUNTRY) REFERENCES COUNTRIES (COUNTRY); <bpt id="5" ctype="x-ph">&lt;ph&gt;</bpt>-- Add a primary key constraint to a table -- First, create a new table<ept id="5">&lt;/ph&gt;</ept> CREATE TABLE ACTIVITIES (CITY_ID INT NOT NULL, SEASON CHAR(2), ACTIVITY VARCHAR(32) NOT NULL); <bpt id="6" ctype="x-ph">&lt;ph&gt;</bpt>-- You will not be able to add this constraint if the -- columns you are including in the primary key have -- null data or duplicate values.<ept id="6">&lt;/ph&gt;</ept> ALTER TABLE Activities ADD PRIMARY KEY (city_id, activity); <bpt id="7" ctype="x-ph">&lt;ph&gt;</bpt>-- Drop the city_id column if there are no dependent objects:<ept id="7">&lt;/ph&gt;</ept> ALTER TABLE Cities DROP COLUMN city_id RESTRICT; <bpt id="8" ctype="x-ph">&lt;ph&gt;</bpt>-- Drop the city_id column, also dropping all dependent objects:<ept id="8">&lt;/ph&gt;</ept> ALTER TABLE Cities DROP COLUMN city_id CASCADE; <bpt id="9" ctype="x-ph">&lt;ph&gt;</bpt>-- Drop a primary key constraint from the CITIES table <ept id="9">&lt;/ph&gt;</ept> ALTER TABLE Cities DROP CONSTRAINT Cities_PK; <bpt id="10" ctype="x-ph">&lt;ph&gt;</bpt>-- Drop a foreign key constraint from the CITIES table<ept id="10">&lt;/ph&gt;</ept> ALTER TABLE Cities DROP CONSTRAINT COUNTRIES_FK; <bpt id="11" ctype="x-ph">&lt;ph&gt;</bpt>-- add a DEPTNO column with a default value of 1<ept id="11">&lt;/ph&gt;</ept> ALTER TABLE SAMP.EMP_ACT ADD COLUMN DEPTNO INT DEFAULT 1; <bpt id="12" ctype="x-ph">&lt;ph&gt;</bpt>-- increase the width of a VARCHAR column<ept id="12">&lt;/ph&gt;</ept> ALTER TABLE SAMP.EMP_PHOTO ALTER PHOTO_FORMAT SET DATA TYPE VARCHAR(30); <bpt id="13" ctype="x-ph">&lt;ph&gt;</bpt>-- change the lock granularity of a table<ept id="13">&lt;/ph&gt;</ept> ALTER TABLE SAMP.SALES LOCKSIZE TABLE; <bpt id="14" ctype="x-ph">&lt;ph&gt;</bpt>-- Remove the NOT NULL constraint from the MANAGER column<ept id="14">&lt;/ph&gt;</ept> ALTER TABLE Employees ALTER COLUMN Manager NULL; <bpt id="15" ctype="x-ph">&lt;ph&gt;</bpt>-- Add the NOT NULL constraint to the SSN column<ept id="15">&lt;/ph&gt;</ept> ALTER TABLE Employees ALTER COLUMN ssn NOT NULL; <bpt id="16" ctype="x-ph">&lt;ph&gt;</bpt>-- Change the default value for the SALARY column<ept id="16">&lt;/ph&gt;</ept> ALTER TABLE Employees ALTER COLUMN Salary DEFAULT 1000.0 ALTER TABLE Employees ALTER COLUMN Salary DROP DEFAULT <it id="1" ctype="x-b" pos="close">&lt;/b&gt;</it></source>
<seg-source><mrk mid="0" mtype="seg"><it id="1" ctype="x-b" pos="open">&lt;b&gt;</it><bpt id="2" ctype="x-ph">&lt;ph&gt;</bpt>-- Add a new column with a column-level constraint -- to an existing table -- An exception will be thrown if the table -- contains any rows -- since the newcol will be initialized to NULL -- in all existing rows in the table<ept id="2">&lt;/ph&gt;</ept> ALTER TABLE CITIES ADD COLUMN REGION VARCHAR(26) CONSTRAINT NEW_CONSTRAINT CHECK (REGION IS NOT NULL); <bpt id="3" ctype="x-ph">&lt;ph&gt;</bpt>-- Add a new unique constraint to an existing table -- An exception will be thrown if duplicate keys are found<ept id="3">&lt;/ph&gt;</ept> ALTER TABLE SAMP.DEPARTMENT ADD CONSTRAINT NEW_UNIQUE UNIQUE (DEPTNO); <it id="4" ctype="x-ph" pos="open">&lt;ph&gt;</it>-- add a new foreign key constraint to the -- Cities table.</mrk><mrk mid="1" mtype="seg"> Each row in Cities is checked -- to make sure it satisfied the constraints.</mrk><mrk mid="2" mtype="seg"> -- if any rows don't satisfy the constraint, the -- constraint is not added<it id="4" ctype="x-ph" pos="close">&lt;/ph&gt;</it> ALTER TABLE CITIES ADD CONSTRAINT COUNTRY_FK Foreign Key (COUNTRY) REFERENCES COUNTRIES (COUNTRY); <bpt id="5" ctype="x-ph">&lt;ph&gt;</bpt>-- Add a primary key constraint to a table -- First, create a new table<ept id="5">&lt;/ph&gt;</ept> CREATE TABLE ACTIVITIES (CITY_ID INT NOT NULL, SEASON CHAR(2), ACTIVITY VARCHAR(32) NOT NULL); <bpt id="6" ctype="x-ph">&lt;ph&gt;</bpt>-- You will not be able to add this constraint if the -- columns you are including in the primary key have -- null data or duplicate values.<ept id="6">&lt;/ph&gt;</ept></mrk><mrk mid="3" mtype="seg"> ALTER TABLE Activities ADD PRIMARY KEY (city_id, activity); <bpt id="7" ctype="x-ph">&lt;ph&gt;</bpt>-- Drop the city_id column if there are no dependent objects:<ept id="7">&lt;/ph&gt;</ept> ALTER TABLE Cities DROP COLUMN city_id RESTRICT; <bpt id="8" ctype="x-ph">&lt;ph&gt;</bpt>-- Drop the city_id column, also dropping all dependent objects:<ept id="8">&lt;/ph&gt;</ept> ALTER TABLE Cities DROP COLUMN city_id CASCADE; <bpt id="9" ctype="x-ph">&lt;ph&gt;</bpt>-- Drop a primary key constraint from the CITIES table <ept id="9">&lt;/ph&gt;</ept> ALTER TABLE Cities DROP CONSTRAINT Cities_PK; <bpt id="10" ctype="x-ph">&lt;ph&gt;</bpt>-- Drop a foreign key constraint from the CITIES table<ept id="10">&lt;/ph&gt;</ept> ALTER TABLE Cities DROP CONSTRAINT COUNTRIES_FK; <bpt id="11" ctype="x-ph">&lt;ph&gt;</bpt>-- add a DEPTNO column with a default value of 1<ept id="11">&lt;/ph&gt;</ept> ALTER TABLE SAMP.EMP_ACT ADD COLUMN DEPTNO INT DEFAULT 1; <bpt id="12" ctype="x-ph">&lt;ph&gt;</bpt>-- increase the width of a VARCHAR column<ept id="12">&lt;/ph&gt;</ept> ALTER TABLE SAMP.EMP_PHOTO ALTER PHOTO_FORMAT SET DATA TYPE VARCHAR(30); <bpt id="13" ctype="x-ph">&lt;ph&gt;</bpt>-- change the lock granularity of a table<ept id="13">&lt;/ph&gt;</ept> ALTER TABLE SAMP.SALES LOCKSIZE TABLE; <bpt id="14" ctype="x-ph">&lt;ph&gt;</bpt>-- Remove the NOT NULL constraint from the MANAGER column<ept id="14">&lt;/ph&gt;</ept> ALTER TABLE Employees ALTER COLUMN Manager NULL; <bpt id="15" ctype="x-ph">&lt;ph&gt;</bpt>-- Add the NOT NULL constraint to the SSN column<ept id="15">&lt;/ph&gt;</ept> ALTER TABLE Employees ALTER COLUMN ssn NOT NULL; <bpt id="16" ctype="x-ph">&lt;ph&gt;</bpt>-- Change the default value for the SALARY column<ept id="16">&lt;/ph&gt;</ept> ALTER TABLE Employees ALTER COLUMN Salary DEFAULT 1000.0 ALTER TABLE Employees ALTER COLUMN Salary DROP DEFAULT <it id="1" ctype="x-b" pos="close">&lt;/b&gt;</it></mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg"><it id="1" ctype="x-b" pos="open">&lt;b&gt;</it><bpt id="2" ctype="x-ph">&lt;ph&gt;</bpt>-- Add a new column with a column-level constraint -- to an existing table -- An exception will be thrown if the table -- contains any rows -- since the newcol will be initialized to NULL -- in all existing rows in the table<ept id="2">&lt;/ph&gt;</ept> ALTER TABLE CITIES ADD COLUMN REGION VARCHAR(26) CONSTRAINT NEW_CONSTRAINT CHECK (REGION IS NOT NULL); <bpt id="3" ctype="x-ph">&lt;ph&gt;</bpt>-- Add a new unique constraint to an existing table -- An exception will be thrown if duplicate keys are found<ept id="3">&lt;/ph&gt;</ept> ALTER TABLE SAMP.DEPARTMENT ADD CONSTRAINT NEW_UNIQUE UNIQUE (DEPTNO); <it id="4" ctype="x-ph" pos="open">&lt;ph&gt;</it>-- add a new foreign key constraint to the -- Cities table.</mrk><mrk mid="1" mtype="seg"> Each row in Cities is checked -- to make sure it satisfied the constraints.</mrk><mrk mid="2" mtype="seg"> -- if any rows don't satisfy the constraint, the -- constraint is not added<it id="4" ctype="x-ph" pos="close">&lt;/ph&gt;</it> ALTER TABLE CITIES ADD CONSTRAINT COUNTRY_FK Foreign Key (COUNTRY) REFERENCES COUNTRIES (COUNTRY); <bpt id="5" ctype="x-ph">&lt;ph&gt;</bpt>-- Add a primary key constraint to a table -- First, create a new table<ept id="5">&lt;/ph&gt;</ept> CREATE TABLE ACTIVITIES (CITY_ID INT NOT NULL, SEASON CHAR(2), ACTIVITY VARCHAR(32) NOT NULL); <bpt id="6" ctype="x-ph">&lt;ph&gt;</bpt>-- You will not be able to add this constraint if the -- columns you are including in the primary key have -- null data or duplicate values.<ept id="6">&lt;/ph&gt;</ept></mrk><mrk mid="3" mtype="seg"> ALTER TABLE Activities ADD PRIMARY KEY (city_id, activity); <bpt id="7" ctype="x-ph">&lt;ph&gt;</bpt>-- Drop the city_id column if there are no dependent objects:<ept id="7">&lt;/ph&gt;</ept> ALTER TABLE Cities DROP COLUMN city_id RESTRICT; <bpt id="8" ctype="x-ph">&lt;ph&gt;</bpt>-- Drop the city_id column, also dropping all dependent objects:<ept id="8">&lt;/ph&gt;</ept> ALTER TABLE Cities DROP COLUMN city_id CASCADE; <bpt id="9" ctype="x-ph">&lt;ph&gt;</bpt>-- Drop a primary key constraint from the CITIES table <ept id="9">&lt;/ph&gt;</ept> ALTER TABLE Cities DROP CONSTRAINT Cities_PK; <bpt id="10" ctype="x-ph">&lt;ph&gt;</bpt>-- Drop a foreign key constraint from the CITIES table<ept id="10">&lt;/ph&gt;</ept> ALTER TABLE Cities DROP CONSTRAINT COUNTRIES_FK; <bpt id="11" ctype="x-ph">&lt;ph&gt;</bpt>-- add a DEPTNO column with a default value of 1<ept id="11">&lt;/ph&gt;</ept> ALTER TABLE SAMP.EMP_ACT ADD COLUMN DEPTNO INT DEFAULT 1; <bpt id="12" ctype="x-ph">&lt;ph&gt;</bpt>-- increase the width of a VARCHAR column<ept id="12">&lt;/ph&gt;</ept> ALTER TABLE SAMP.EMP_PHOTO ALTER PHOTO_FORMAT SET DATA TYPE VARCHAR(30); <bpt id="13" ctype="x-ph">&lt;ph&gt;</bpt>-- change the lock granularity of a table<ept id="13">&lt;/ph&gt;</ept> ALTER TABLE SAMP.SALES LOCKSIZE TABLE; <bpt id="14" ctype="x-ph">&lt;ph&gt;</bpt>-- Remove the NOT NULL constraint from the MANAGER column<ept id="14">&lt;/ph&gt;</ept> ALTER TABLE Employees ALTER COLUMN Manager NULL; <bpt id="15" ctype="x-ph">&lt;ph&gt;</bpt>-- Add the NOT NULL constraint to the SSN column<ept id="15">&lt;/ph&gt;</ept> ALTER TABLE Employees ALTER COLUMN ssn NOT NULL; <bpt id="16" ctype="x-ph">&lt;ph&gt;</bpt>-- Change the default value for the SALARY column<ept id="16">&lt;/ph&gt;</ept> ALTER TABLE Employees ALTER COLUMN Salary DEFAULT 1000.0 ALTER TABLE Employees ALTER COLUMN Salary DROP DEFAULT <it id="1" ctype="x-b" pos="close">&lt;/b&gt;</it></mrk></target>
</trans-unit>
<trans-unit id="tu97">
<source xml:lang="en">Results</source>
<seg-source><mrk mid="0" mtype="seg">Results</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">Results</mrk></target>
</trans-unit>
<trans-unit id="tu98">
<source xml:lang="en">An ALTER TABLE statement causes all statements that are dependent on the table being altered to be recompiled before their next execution. ALTER TABLE is not allowed if there are any open cursors that reference the table being altered.</source>
<seg-source><mrk mid="0" mtype="seg">An ALTER TABLE statement causes all statements that are dependent on the table being altered to be recompiled before their next execution.</mrk><mrk mid="1" mtype="seg"> ALTER TABLE is not allowed if there are any open cursors that reference the table being altered.</mrk></seg-source>
<target xml:lang="fr"><mrk mid="0" mtype="seg">An ALTER TABLE statement causes all statements that are dependent on the table being altered to be recompiled before their next execution.</mrk><mrk mid="1" mtype="seg"> ALTER TABLE is not allowed if there are any open cursors that reference the table being altered.</mrk></target>
</trans-unit>
</body>
</file>
</xliff>
